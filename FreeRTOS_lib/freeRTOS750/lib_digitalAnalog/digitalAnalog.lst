   1               		.file	"digitalAnalog.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  76               	.global	getIORegisters
  78               	getIORegisters:
  79               		.stabd	46,0,0
   1:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** /*
   2:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  * Derived from Ben Schmidel, August 11, 2009.
   3:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  * Copyright (c) 2009 Pololu Corporation. For more information, see
   4:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  *
   5:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  *   http://www.pololu.com
   6:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  *   http://forum.pololu.com
   7:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  *   http://www.pololu.com/docs/0J18
   8:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  *
   9:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  * You may freely modify and share this code, as long as you keep this
  10:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  * notice intact (including the two links above).  Licensed under the
  11:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  * Creative Commons BY-SA 3.0 license:
  12:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  *
  13:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  *   http://creativecommons.org/licenses/by-sa/3.0/
  14:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  *
  15:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  * Disclaimer: To the extent permitted by law, Pololu provides this work
  16:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  * without any warranty.  It might be defective, in which case you agree
  17:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  * to be responsible for all resulting costs and damages.
  18:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c ****  */
  19:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
  20:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** #include <freeRTOSBoardDefs.h>
  21:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** #include <digitalAnalog.h>
  22:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
  23:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** /*--------------- declarations here ----------------------------------*/
  24:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
  25:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** struct IOStructure
  26:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
  27:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// if these aren't volatile, the compiler sometimes incorrectly optimises away operations involvin
  28:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	volatile uint8_t* pinRegister;
  29:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	volatile uint8_t* portRegister;
  30:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	volatile uint8_t* ddrRegister;
  31:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	volatile uint8_t* didRegister;
  32:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	uint8_t bitmask;
  33:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** };
  34:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
  35:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** inline void getIORegisters(struct IOStructure* io, uint8_t pin);
  36:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** inline void setDataDirection(struct IOStructure* ioPin, uint8_t val);
  37:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** inline void setOutputValue(struct IOStructure* ioPin, uint8_t val);
  38:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** inline uint8_t getInputValue(struct IOStructure* ioPin);
  39:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** inline void setDIDValue(struct IOStructure* ioPin, uint8_t val);
  40:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
  41:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** /*--------------- inline functions here ----------------------------------*/
  42:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
  43:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // gets a structure with pointers to the four digital I/O registers associated
  44:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // with the specified pin (DDR, PORT, PIN, DIDR) along with a bitmask with a
  45:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // 1 in the position of the specified pin and 0s everywhere else.
  46:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** void getIORegisters(struct IOStructure* io, uint8_t pin)
  47:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
  81               	.LM0:
  82               	.LFBB1:
  83               	/* prologue: function */
  84               	/* frame size = 0 */
  85               	/* stack size = 0 */
  86               	.L__stack_usage = 0
  87 0000 FC01      		movw r30,r24
  48:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	io->pinRegister = 0;
  89               	.LM1:
  90 0002 1182      		std Z+1,__zero_reg__
  91 0004 1082      		st Z,__zero_reg__
  49:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	io->portRegister = 0;
  93               	.LM2:
  94 0006 1382      		std Z+3,__zero_reg__
  95 0008 1282      		std Z+2,__zero_reg__
  50:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	io->ddrRegister = 0;
  97               	.LM3:
  98 000a 1582      		std Z+5,__zero_reg__
  99 000c 1482      		std Z+4,__zero_reg__
  51:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	io->didRegister = 0;
 101               	.LM4:
 102 000e 1782      		std Z+7,__zero_reg__
 103 0010 1682      		std Z+6,__zero_reg__
  52:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	io->bitmask = 0;
 105               	.LM5:
 106 0012 1086      		std Z+8,__zero_reg__
  53:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
  54:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** #if defined(_MEGA_)
  55:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // Setting this to match some random (linear) pin definitions for Arduino MEGA
  56:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // The MEGA so randomises its pins around the board, it is boring to try to rationalise this.
  57:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
  58:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (pin < 8)			// pin 0 = PA0, ..., 7 = PA7
  59:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
  60:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINA;
  61:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTA;
  62:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRA;
  63:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 0);
  64:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
  65:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 16)		// pin 8 = PB0, ..., 15 = PB7
  66:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
  67:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINB;
  68:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTB;
  69:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRB;
  70:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 8);
  71:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
  72:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 24)		// pin 16 = PC0, ..., 23 = PC7
  73:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
  74:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINC;
  75:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTC;
  76:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRC;
  77:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 16);
  78:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
  79:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 32)		// pin 24 = PD0, ..., 31 = PD7
  80:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
  81:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PIND;
  82:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTD;
  83:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRD;
  84:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 24);
  85:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
  86:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 40)		// pin 32 = PE0, ..., 39 = PE7
  87:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
  88:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINE;
  89:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTE;
  90:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRE;
  91:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 32);
  92:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
  93:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 48)		// pin 40 = PF0, ..., 47 = PF7
  94:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
  95:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINF;
  96:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTF;
  97:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRF;
  98:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->didRegister = (uint8_t*)&DIDR0;
  99:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 40);
 100:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 101:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 54)		// pin 48 = PG0, ..., 53 = PG5 PG6 & PG7 don't exist.
 102:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 103:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PING;
 104:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTG;
 105:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRG;
 106:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 48);
 107:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 108:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 56) {}	// Do nothing. These pins don't exist.
 109:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 110:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 64)		// pin 56 = PH0, ..., 63 = PH7
 111:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 112:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINH;
 113:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTH;
 114:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRH;
 115:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 56);
 116:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 117:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 72)		// pin 64 = PJ0, ..., 71 = PJ7
 118:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 119:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINJ;
 120:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTJ;
 121:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRJ;
 122:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 64);
 123:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 124:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 80)		// pin 72 = PK0, ..., 79 = PK7
 125:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 126:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINK;
 127:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTK;
 128:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRK;
 129:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->didRegister = (uint8_t*)&DIDR2;
 130:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 72);
 131:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 132:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 88)		// pin 80 = PL0, ..., 87 = PL7
 133:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 134:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINL;
 135:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTL;
 136:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRL;
 137:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 80);
 138:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 139:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 140:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** #elif defined(_GOLDILOCKS_)
 141:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // Setting this to match the pin definitions for Goldilocks
 142:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 143:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (pin < 8)			// pin 0 = PD0, ..., 7 = PD7
 144:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 145:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PIND;
 146:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTD;
 147:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRD;
 148:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 0);
 149:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 150:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 16)		// pin 8 = PB2,... pin 13 = PB7, 14 = PB0, 15 = PB1
 151:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 152:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINB;
 153:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTB;
 154:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRB;
 155:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 8);
 156:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 157:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 18)		// pin 16 = PC0, ..., 23 = PC7
 158:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 159:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINC;
 160:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTC;
 161:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRC;
 162:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 16);
 163:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 164:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 32)		// pin 24 = PA0, ..., 31 = PA7
 165:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 166:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINA;
 167:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTA;
 168:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRA;
 169:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->didRegister = (uint8_t*)&DIDR0;
 170:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 24);
 171:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 172:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 173:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** #elif defined(_U2DUINO_)
 174:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // Arduino Serial I/O MCU Compatible notation.
 175:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 176:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (pin < 8)			// pin 0 = PD0, ..., 7 = PD7
 177:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 178:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PIND;
 179:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTD;
 180:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRD;
 181:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 0);
 182:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 183:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 15)		// pin 8 = PB0, ..., 13 = PB5 (PB7 reserved for Hardware Boot)
 184:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 185:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINB;
 186:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTB;
 187:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRB;
 188:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 8);
 189:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 190:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 191:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 192:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** #elif defined(_UNO_)
 193:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // Arduino UNO ATmega328p Compatible notation.
 194:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 195:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (pin < 8)			// pin 0 = PD0, ..., 7 = PD7
 108               	.LM6:
 109 0014 6830      		cpi r22,lo8(8)
 110 0016 00F4      		brsh .L2
 196:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 197:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PIND;
 112               	.LM7:
 113 0018 89E2      		ldi r24,lo8(41)
 114 001a 90E0      		ldi r25,0
 115 001c 9183      		std Z+1,r25
 116 001e 8083      		st Z,r24
 198:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTD;
 118               	.LM8:
 119 0020 8BE2      		ldi r24,lo8(43)
 120 0022 90E0      		ldi r25,0
 121 0024 9383      		std Z+3,r25
 122 0026 8283      		std Z+2,r24
 199:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRD;
 124               	.LM9:
 125 0028 8AE2      		ldi r24,lo8(42)
 126 002a 90E0      		ldi r25,0
 127 002c 9583      		std Z+5,r25
 128 002e 8483      		std Z+4,r24
 129 0030 00C0      		rjmp .L5
 130               	.L2:
 200:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 0);
 201:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 202:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 14)		// pin 8 = PB0, ..., 13 = PB5 (PB6 and PB7 reserved for external clock)
 132               	.LM10:
 133 0032 6E30      		cpi r22,lo8(14)
 134 0034 00F4      		brsh .L4
 203:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 204:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINB;
 136               	.LM11:
 137 0036 83E2      		ldi r24,lo8(35)
 138 0038 90E0      		ldi r25,0
 139 003a 9183      		std Z+1,r25
 140 003c 8083      		st Z,r24
 205:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTB;
 142               	.LM12:
 143 003e 85E2      		ldi r24,lo8(37)
 144 0040 90E0      		ldi r25,0
 145 0042 9383      		std Z+3,r25
 146 0044 8283      		std Z+2,r24
 206:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRB;
 148               	.LM13:
 149 0046 84E2      		ldi r24,lo8(36)
 150 0048 90E0      		ldi r25,0
 151 004a 9583      		std Z+5,r25
 152 004c 8483      		std Z+4,r24
 207:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 8);
 154               	.LM14:
 155 004e 70E0      		ldi r23,0
 156 0050 6850      		subi r22,8
 157 0052 7109      		sbc r23,__zero_reg__
 158 0054 00C0      		rjmp .L5
 159               	.L4:
 208:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 209:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (pin < 20)		// pin 14 = PC0, ..., 19 = PC5 (PC6 is reset, PC7 doesn't exist)
 161               	.LM15:
 162 0056 6431      		cpi r22,lo8(20)
 163 0058 00F4      		brsh .L1
 164               	.LBB6:
 165               	.LBB7:
 210:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 211:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->pinRegister = (uint8_t*)&PINC;
 167               	.LM16:
 168 005a 86E2      		ldi r24,lo8(38)
 169 005c 90E0      		ldi r25,0
 170 005e 9183      		std Z+1,r25
 171 0060 8083      		st Z,r24
 212:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->portRegister = (uint8_t*)&PORTC;
 173               	.LM17:
 174 0062 88E2      		ldi r24,lo8(40)
 175 0064 90E0      		ldi r25,0
 176 0066 9383      		std Z+3,r25
 177 0068 8283      		std Z+2,r24
 213:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->ddrRegister = (uint8_t*)&DDRC;
 179               	.LM18:
 180 006a 87E2      		ldi r24,lo8(39)
 181 006c 90E0      		ldi r25,0
 182 006e 9583      		std Z+5,r25
 183 0070 8483      		std Z+4,r24
 214:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->didRegister = (uint8_t*)&DIDR0;
 185               	.LM19:
 186 0072 8EE7      		ldi r24,lo8(126)
 187 0074 90E0      		ldi r25,0
 188 0076 9783      		std Z+7,r25
 189 0078 8683      		std Z+6,r24
 215:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		io->bitmask = 1 << (pin - 14);
 191               	.LM20:
 192 007a 70E0      		ldi r23,0
 193 007c 6E50      		subi r22,14
 194 007e 7109      		sbc r23,__zero_reg__
 195               	.L5:
 196 0080 81E0      		ldi r24,lo8(1)
 197 0082 90E0      		ldi r25,0
 198 0084 00C0      		rjmp 2f
 199               		1:
 200 0086 880F      		lsl r24
 201               		2:
 202 0088 6A95      		dec r22
 203 008a 02F4      		brpl 1b
 204 008c 8087      		std Z+8,r24
 205               	.L1:
 206 008e 0895      		ret
 207               	.LBE7:
 208               	.LBE6:
 210               	.Lscope1:
 212               		.stabd	78,0,0
 216               	.global	setDataDirection
 218               	setDataDirection:
 219               		.stabd	46,0,0
 216:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 217:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** #endif
 218:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 219:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 220:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 221:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // low-level method for setting the data direction (i.e. input or output) of an pin or set of pins
 222:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // described by an IOStruct pointer.
 223:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** void setDataDirection(struct IOStructure* ioPin, uint8_t val)
 224:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 221               	.LM21:
 222               	.LFBB2:
 223               	/* prologue: function */
 224               	/* frame size = 0 */
 225               	/* stack size = 0 */
 226               	.L__stack_usage = 0
 227 0090 DC01      		movw r26,r24
 228 0092 1496      		adiw r26,4
 229 0094 ED91      		ld r30,X+
 230 0096 FC91      		ld r31,X
 231 0098 1597      		sbiw r26,4+1
 232 009a 1896      		adiw r26,8
 233 009c 8C91      		ld r24,X
 234               	.LBB10:
 235               	.LBB11:
 225:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (val)
 226:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		*(ioPin->ddrRegister) |= ioPin->bitmask;
 237               	.LM22:
 238 009e 9081      		ld r25,Z
 239               	.LBE11:
 240               	.LBE10:
 225:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (val)
 242               	.LM23:
 243 00a0 6623      		tst r22
 244 00a2 01F0      		breq .L7
 245               	.LBB13:
 246               	.LBB12:
 248               	.LM24:
 249 00a4 982B      		or r25,r24
 250 00a6 9083      		st Z,r25
 251 00a8 0895      		ret
 252               	.L7:
 253               	.LBE12:
 254               	.LBE13:
 227:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else
 228:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		*(ioPin->ddrRegister) &= ~ioPin->bitmask;
 256               	.LM25:
 257 00aa 8095      		com r24
 258 00ac 8923      		and r24,r25
 259 00ae 8083      		st Z,r24
 260 00b0 0895      		ret
 262               	.Lscope2:
 264               		.stabd	78,0,0
 268               	.global	setOutputValue
 270               	setOutputValue:
 271               		.stabd	46,0,0
 229:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 230:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 231:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 232:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // low-level method for setting the PORT register value of an pin or set of pins
 233:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // described by an IOStruct pointer.  If the pin is an input, this lets you choose between
 234:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // setting it as high-impedance (val = 0) or enabling the internal pull-up (val = 1).  If the pin i
 235:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // output, this lets you choose between driving low (val = 0) and driving high (val = 1).
 236:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // NOTE: if val is 0xFF (255), this method will toggle the PORT register pin(s).
 237:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** void setOutputValue(struct IOStructure* ioPin, uint8_t val)
 238:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 273               	.LM26:
 274               	.LFBB3:
 275               	/* prologue: function */
 276               	/* frame size = 0 */
 277               	/* stack size = 0 */
 278               	.L__stack_usage = 0
 279 00b2 DC01      		movw r26,r24
 280 00b4 1296      		adiw r26,2
 281 00b6 ED91      		ld r30,X+
 282 00b8 FC91      		ld r31,X
 283 00ba 1397      		sbiw r26,2+1
 239:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (val == 0xFF)
 285               	.LM27:
 286 00bc 6F3F      		cpi r22,lo8(-1)
 287 00be 01F4      		brne .L10
 288               	.LBB16:
 289               	.LBB17:
 240:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		*(ioPin->portRegister) ^= ioPin->bitmask;
 291               	.LM28:
 292 00c0 8081      		ld r24,Z
 293 00c2 1896      		adiw r26,8
 294 00c4 9C91      		ld r25,X
 295 00c6 8927      		eor r24,r25
 296 00c8 00C0      		rjmp .L13
 297               	.L10:
 298 00ca 1896      		adiw r26,8
 299 00cc 8C91      		ld r24,X
 300               	.LBE17:
 301               	.LBE16:
 241:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (val)
 242:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		*(ioPin->portRegister) |= ioPin->bitmask;
 303               	.LM29:
 304 00ce 9081      		ld r25,Z
 241:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else if (val)
 306               	.LM30:
 307 00d0 6623      		tst r22
 308 00d2 01F0      		breq .L12
 310               	.LM31:
 311 00d4 982B      		or r25,r24
 312 00d6 9083      		st Z,r25
 313 00d8 0895      		ret
 314               	.L12:
 243:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else
 244:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		*(ioPin->portRegister) &= ~ioPin->bitmask;
 316               	.LM32:
 317 00da 8095      		com r24
 318 00dc 8923      		and r24,r25
 319               	.L13:
 320 00de 8083      		st Z,r24
 321 00e0 0895      		ret
 323               	.Lscope3:
 325               		.stabd	78,0,0
 328               	.global	getInputValue
 330               	getInputValue:
 331               		.stabd	46,0,0
 245:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 246:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 247:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 248:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // low-level method for reading the value of the PIN register for an pin or set of pins
 249:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // described by an IOStruct pointer.
 250:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** uint8_t getInputValue(struct IOStructure* ioPin)
 251:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 333               	.LM33:
 334               	.LFBB4:
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 339 00e2 FC01      		movw r30,r24
 252:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	return *(ioPin->pinRegister) & ioPin->bitmask;
 341               	.LM34:
 342 00e4 A081      		ld r26,Z
 343 00e6 B181      		ldd r27,Z+1
 344 00e8 9C91      		ld r25,X
 345 00ea 8085      		ldd r24,Z+8
 253:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 347               	.LM35:
 348 00ec 8923      		and r24,r25
 349 00ee 0895      		ret
 351               	.Lscope4:
 353               		.stabd	78,0,0
 357               	.global	setDIDValue
 359               	setDIDValue:
 360               		.stabd	46,0,0
 254:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 255:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 256:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // low-level method for setting the value of the DIDR register for a pin
 257:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // described by an IOStruct pointer.
 258:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** void setDIDValue(struct IOStructure* ioPin, uint8_t val)
 259:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 362               	.LM36:
 363               	.LFBB5:
 364               	/* prologue: function */
 365               	/* frame size = 0 */
 366               	/* stack size = 0 */
 367               	.L__stack_usage = 0
 260:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (!(ioPin->didRegister == 0))
 369               	.LM37:
 370 00f0 DC01      		movw r26,r24
 371 00f2 1696      		adiw r26,6
 372 00f4 ED91      		ld r30,X+
 373 00f6 FC91      		ld r31,X
 374 00f8 1797      		sbiw r26,6+1
 375 00fa 3097      		sbiw r30,0
 376 00fc 01F0      		breq .L15
 377 00fe 1896      		adiw r26,8
 378 0100 8C91      		ld r24,X
 261:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 262:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		if (val)
 263:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 			*(ioPin->didRegister) |= ioPin->bitmask;
 380               	.LM38:
 381 0102 9081      		ld r25,Z
 262:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		if (val)
 383               	.LM39:
 384 0104 6623      		tst r22
 385 0106 01F0      		breq .L17
 387               	.LM40:
 388 0108 982B      		or r25,r24
 389 010a 9083      		st Z,r25
 390 010c 0895      		ret
 391               	.L17:
 264:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		else
 265:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 			*(ioPin->didRegister) &= ~ioPin->bitmask;
 393               	.LM41:
 394 010e 8095      		com r24
 395 0110 8923      		and r24,r25
 396 0112 8083      		st Z,r24
 397               	.L15:
 398 0114 0895      		ret
 400               	.Lscope5:
 402               		.stabd	78,0,0
 406               	.global	setDigitalOutput
 408               	setDigitalOutput:
 409               		.stabd	46,0,0
 266:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 267:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 268:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 269:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 270:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** /*--------------------------------------------------------------------*/
 271:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 272:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // high-level method for setting the specified pin as an output with the specified output state.
 273:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // An outputState value of 0 will cause the pin to drive low; a value of 1 will cause the pin to
 274:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // drive high.  A value of 0xFF (255) will toggle the output state of the pin (i.e. high -> low and
 275:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // low -> high).
 276:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** void setDigitalOutput(uint8_t pin, uint8_t outputState)
 277:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 411               	.LM42:
 412               	.LFBB6:
 413 0116 1F93      		push r17
 414 0118 CF93      		push r28
 415 011a DF93      		push r29
 416 011c CDB7      		in r28,__SP_L__
 417 011e DEB7      		in r29,__SP_H__
 418 0120 2997      		sbiw r28,9
 419 0122 0FB6      		in __tmp_reg__,__SREG__
 420 0124 F894      		cli
 421 0126 DEBF      		out __SP_H__,r29
 422 0128 0FBE      		out __SREG__,__tmp_reg__
 423 012a CDBF      		out __SP_L__,r28
 424               	/* prologue: function */
 425               	/* frame size = 9 */
 426               	/* stack size = 12 */
 427               	.L__stack_usage = 12
 428 012c 162F      		mov r17,r22
 278:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	struct IOStructure registers;
 279:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	getIORegisters(&registers, pin);
 430               	.LM43:
 431 012e 682F      		mov r22,r24
 432 0130 CE01      		movw r24,r28
 433 0132 0196      		adiw r24,1
 434 0134 0E94 0000 		call getIORegisters
 280:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	setOutputValue(&registers, outputState);
 436               	.LM44:
 437 0138 612F      		mov r22,r17
 438 013a CE01      		movw r24,r28
 439 013c 0196      		adiw r24,1
 440 013e 0E94 0000 		call setOutputValue
 441               	.LBB22:
 442               	.LBB23:
 443               	.LBB24:
 226:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		*(ioPin->ddrRegister) |= ioPin->bitmask;
 445               	.LM45:
 446 0142 ED81      		ldd r30,Y+5
 447 0144 FE81      		ldd r31,Y+6
 448 0146 8081      		ld r24,Z
 449 0148 9985      		ldd r25,Y+9
 450 014a 892B      		or r24,r25
 451 014c 8083      		st Z,r24
 452               	/* epilogue start */
 453               	.LBE24:
 454               	.LBE23:
 455               	.LBE22:
 281:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	setDataDirection(&registers, 1);
 282:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 457               	.LM46:
 458 014e 2996      		adiw r28,9
 459 0150 0FB6      		in __tmp_reg__,__SREG__
 460 0152 F894      		cli
 461 0154 DEBF      		out __SP_H__,r29
 462 0156 0FBE      		out __SREG__,__tmp_reg__
 463 0158 CDBF      		out __SP_L__,r28
 464 015a DF91      		pop r29
 465 015c CF91      		pop r28
 466 015e 1F91      		pop r17
 467 0160 0895      		ret
 472               	.Lscope6:
 474               		.stabd	78,0,0
 478               	.global	setDigitalInput
 480               	setDigitalInput:
 481               		.stabd	46,0,0
 283:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 284:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // high-level method for setting the specified pin as an input with the specified input state.
 285:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // An inputState value of 0 will cause the pin to be a high-impedance input; a value of 1 will enab
 286:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // pin's internal pull-up resistor, which weakly pulls it to Vcc.  A value of 0xFF (255) will toggl
 287:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // input state.
 288:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** void setDigitalInput(uint8_t pin, uint8_t inputState)
 289:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 483               	.LM47:
 484               	.LFBB7:
 485 0162 1F93      		push r17
 486 0164 CF93      		push r28
 487 0166 DF93      		push r29
 488 0168 CDB7      		in r28,__SP_L__
 489 016a DEB7      		in r29,__SP_H__
 490 016c 2997      		sbiw r28,9
 491 016e 0FB6      		in __tmp_reg__,__SREG__
 492 0170 F894      		cli
 493 0172 DEBF      		out __SP_H__,r29
 494 0174 0FBE      		out __SREG__,__tmp_reg__
 495 0176 CDBF      		out __SP_L__,r28
 496               	/* prologue: function */
 497               	/* frame size = 9 */
 498               	/* stack size = 12 */
 499               	.L__stack_usage = 12
 500 0178 162F      		mov r17,r22
 290:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	struct IOStructure registers;
 291:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	getIORegisters(&registers, pin);
 502               	.LM48:
 503 017a 682F      		mov r22,r24
 504 017c CE01      		movw r24,r28
 505 017e 0196      		adiw r24,1
 506 0180 0E94 0000 		call getIORegisters
 292:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	setDataDirection(&registers, 0);
 508               	.LM49:
 509 0184 60E0      		ldi r22,0
 510 0186 CE01      		movw r24,r28
 511 0188 0196      		adiw r24,1
 512 018a 0E94 0000 		call setDataDirection
 293:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	setOutputValue(&registers, inputState);
 514               	.LM50:
 515 018e 612F      		mov r22,r17
 516 0190 CE01      		movw r24,r28
 517 0192 0196      		adiw r24,1
 518 0194 0E94 0000 		call setOutputValue
 519               	/* epilogue start */
 294:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 521               	.LM51:
 522 0198 2996      		adiw r28,9
 523 019a 0FB6      		in __tmp_reg__,__SREG__
 524 019c F894      		cli
 525 019e DEBF      		out __SP_H__,r29
 526 01a0 0FBE      		out __SREG__,__tmp_reg__
 527 01a2 CDBF      		out __SP_L__,r28
 528 01a4 DF91      		pop r29
 529 01a6 CF91      		pop r28
 530 01a8 1F91      		pop r17
 531 01aa 0895      		ret
 536               	.Lscope7:
 538               		.stabd	78,0,0
 541               	.global	disableDigitalInput
 543               	disableDigitalInput:
 544               		.stabd	46,0,0
 295:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 296:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // high-level method for disabling the digital input circuitry of specified pin.
 297:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // Do this to avoid loading during analogue sampling on the pin.
 298:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** void disableDigitalInput(uint8_t pin)
 299:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 546               	.LM52:
 547               	.LFBB8:
 548 01ac CF93      		push r28
 549 01ae DF93      		push r29
 550 01b0 CDB7      		in r28,__SP_L__
 551 01b2 DEB7      		in r29,__SP_H__
 552 01b4 2997      		sbiw r28,9
 553 01b6 0FB6      		in __tmp_reg__,__SREG__
 554 01b8 F894      		cli
 555 01ba DEBF      		out __SP_H__,r29
 556 01bc 0FBE      		out __SREG__,__tmp_reg__
 557 01be CDBF      		out __SP_L__,r28
 558               	/* prologue: function */
 559               	/* frame size = 9 */
 560               	/* stack size = 11 */
 561               	.L__stack_usage = 11
 300:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	struct IOStructure registers;
 301:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	getIORegisters(&registers, pin);
 563               	.LM53:
 564 01c0 682F      		mov r22,r24
 565 01c2 CE01      		movw r24,r28
 566 01c4 0196      		adiw r24,1
 567 01c6 0E94 0000 		call getIORegisters
 302:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	setDIDValue(&registers, 1);
 569               	.LM54:
 570 01ca 61E0      		ldi r22,lo8(1)
 571 01cc CE01      		movw r24,r28
 572 01ce 0196      		adiw r24,1
 573 01d0 0E94 0000 		call setDIDValue
 574               	/* epilogue start */
 303:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 576               	.LM55:
 577 01d4 2996      		adiw r28,9
 578 01d6 0FB6      		in __tmp_reg__,__SREG__
 579 01d8 F894      		cli
 580 01da DEBF      		out __SP_H__,r29
 581 01dc 0FBE      		out __SREG__,__tmp_reg__
 582 01de CDBF      		out __SP_L__,r28
 583 01e0 DF91      		pop r29
 584 01e2 CF91      		pop r28
 585 01e4 0895      		ret
 590               	.Lscope8:
 592               		.stabd	78,0,0
 595               	.global	isDigitalInputHigh
 597               	isDigitalInputHigh:
 598               		.stabd	46,0,0
 304:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 305:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // high-level method for reading the input value of the specified pin.  If the voltage on the pin i
 306:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // this method will return 0.  Otherwise, it will return a non-zero result that depends on the valu
 307:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // the pin.
 308:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** uint8_t isDigitalInputHigh(uint8_t pin)
 309:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 600               	.LM56:
 601               	.LFBB9:
 602 01e6 CF93      		push r28
 603 01e8 DF93      		push r29
 604 01ea CDB7      		in r28,__SP_L__
 605 01ec DEB7      		in r29,__SP_H__
 606 01ee 2997      		sbiw r28,9
 607 01f0 0FB6      		in __tmp_reg__,__SREG__
 608 01f2 F894      		cli
 609 01f4 DEBF      		out __SP_H__,r29
 610 01f6 0FBE      		out __SREG__,__tmp_reg__
 611 01f8 CDBF      		out __SP_L__,r28
 612               	/* prologue: function */
 613               	/* frame size = 9 */
 614               	/* stack size = 11 */
 615               	.L__stack_usage = 11
 310:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	struct IOStructure registers;
 311:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	getIORegisters(&registers, pin);
 617               	.LM57:
 618 01fa 682F      		mov r22,r24
 619 01fc CE01      		movw r24,r28
 620 01fe 0196      		adiw r24,1
 621 0200 0E94 0000 		call getIORegisters
 622               	.LBB25:
 623               	.LBB26:
 252:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	return *(ioPin->pinRegister) & ioPin->bitmask;
 625               	.LM58:
 626 0204 E981      		ldd r30,Y+1
 627 0206 FA81      		ldd r31,Y+2
 628 0208 9081      		ld r25,Z
 629 020a 8985      		ldd r24,Y+9
 630               	.LBE26:
 631               	.LBE25:
 312:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	return getInputValue(&registers);
 313:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 633               	.LM59:
 634 020c 8923      		and r24,r25
 635               	/* epilogue start */
 636 020e 2996      		adiw r28,9
 637 0210 0FB6      		in __tmp_reg__,__SREG__
 638 0212 F894      		cli
 639 0214 DEBF      		out __SP_H__,r29
 640 0216 0FBE      		out __SREG__,__tmp_reg__
 641 0218 CDBF      		out __SP_L__,r28
 642 021a DF91      		pop r29
 643 021c CF91      		pop r28
 644 021e 0895      		ret
 649               	.Lscope9:
 651               		.stabd	78,0,0
 654               	.global	setAnalogMode
 656               	setAnalogMode:
 657               		.stabd	46,0,0
 314:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 315:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** /*--------------------------------------------------------------------*/
 316:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 317:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 318:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // set the ADC to run in either 8-bit mode (MODE_8_BIT) or
 319:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // 10-bit mode (MODE_10_BIT)
 320:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** void setAnalogMode(uint8_t mode)
 321:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 659               	.LM60:
 660               	.LFBB10:
 661               	/* prologue: function */
 662               	/* frame size = 0 */
 663               	/* stack size = 0 */
 664               	.L__stack_usage = 0
 322:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (mode == MODE_10_BIT)
 666               	.LM61:
 667 0220 8111      		cpse r24,__zero_reg__
 668 0222 00C0      		rjmp .L26
 323:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		ADMUX &= ~(1 << ADLAR);	// right-adjust result (ADC has result)
 670               	.LM62:
 671 0224 8091 7C00 		lds r24,124
 672 0228 8F7D      		andi r24,lo8(-33)
 673 022a 00C0      		rjmp .L28
 674               	.L26:
 324:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else
 325:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		ADMUX |= 1 << ADLAR;		// left-adjust result (ADCH has result)
 676               	.LM63:
 677 022c 8091 7C00 		lds r24,124
 678 0230 8062      		ori r24,lo8(32)
 679               	.L28:
 680 0232 8093 7C00 		sts 124,r24
 681 0236 0895      		ret
 683               	.Lscope10:
 685               		.stabd	78,0,0
 687               	.global	getAnalogMode
 689               	getAnalogMode:
 690               		.stabd	46,0,0
 326:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 327:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 328:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // returns 0 if in 10-bit mode, otherwise returns non-zero.  The return
 329:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // value of this method can be directly compared against the macros
 330:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // MODE_8_BIT and MODE_10_BIT:
 331:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // For example: if (getMode() == MODE_8_BIT) ...
 332:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 333:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** uint8_t getAnalogMode()
 334:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 692               	.LM64:
 693               	.LFBB11:
 694               	/* prologue: function */
 695               	/* frame size = 0 */
 696               	/* stack size = 0 */
 697               	.L__stack_usage = 0
 335:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	return (ADMUX >> ADLAR) & 1;
 699               	.LM65:
 700 0238 8091 7C00 		lds r24,124
 336:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 702               	.LM66:
 703 023c 85FB      		bst r24,5
 704 023e 8827      		clr r24
 705 0240 80F9      		bld r24,0
 706 0242 0895      		ret
 708               	.Lscope11:
 710               		.stabd	78,0,0
 712               	.global	analogIsConverting
 714               	analogIsConverting:
 715               		.stabd	46,0,0
 337:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 338:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // returns 1 if the ADC is in the middle of an conversion, otherwise
 339:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // returns 0
 340:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** uint8_t analogIsConverting()
 341:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 717               	.LM67:
 718               	.LFBB12:
 719               	/* prologue: function */
 720               	/* frame size = 0 */
 721               	/* stack size = 0 */
 722               	.L__stack_usage = 0
 342:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	return (ADCSRA >> ADSC) & 1;
 724               	.LM68:
 725 0244 8091 7A00 		lds r24,122
 343:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 727               	.LM69:
 728 0248 86FB      		bst r24,6
 729 024a 8827      		clr r24
 730 024c 80F9      		bld r24,0
 731 024e 0895      		ret
 733               	.Lscope12:
 735               		.stabd	78,0,0
 739               	.global	startAnalogConversion
 741               	startAnalogConversion:
 742               		.stabd	46,0,0
 344:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 345:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // the following method can be used to initiate an ADC conversion
 346:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // that runs in the background, allowing the CPU to perform other tasks
 347:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // while the conversion is in progress.  The procedure is to start a
 348:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // conversion on a channel with startConversion(channel), and then
 349:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // poll isConverting in your main loop.  Once isConverting() returns
 350:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // a zero, the result can be obtained through a call to conversionResult().
 351:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // NOTE: Some Orangutans and 3pis have their AREF pin connected directly to VCC.
 352:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** //  On these Orangutans, you must not use the internal voltage reference as
 353:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** //  doing so will short the internal reference voltage to VCC and could damage
 354:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** //  the AVR.  It is safe to use the internal reference voltage on the
 355:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** //  Orangutan SVP.
 356:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 357:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** void startAnalogConversion(uint8_t channel, uint8_t use_internal_reference)
 358:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 744               	.LM70:
 745               	.LFBB13:
 746               	/* prologue: function */
 747               	/* frame size = 0 */
 748               	/* stack size = 0 */
 749               	.L__stack_usage = 0
 359:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// Channel numbers greater than 15 on 328p or 1284p or 31 on 2560 are invalid.
 360:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (channel > 0x1F)
 751               	.LM71:
 752 0250 8032      		cpi r24,lo8(32)
 753 0252 00F4      		brsh .L31
 361:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 362:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		return;
 363:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 364:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 365:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	ADCSRA = _BV(ADEN) | _BV(ADPS2)|_BV(ADPS1)|_BV(ADPS0);
 755               	.LM72:
 756 0254 97E8      		ldi r25,lo8(-121)
 757 0256 9093 7A00 		sts 122,r25
 366:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** //	ADCSRA = 0x86;		// We're going to be running faster than Pololu suggests. Good for 8 bit convers
 367:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 						// bit 7 set: ADC enabled
 368:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 						// bit 6 clear: don't start conversion
 369:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 						// bit 5 clear: disable autotrigger
 370:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 						// bit 4: ADC interrupt flag
 371:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 						// bit 3 clear: disable ADC interrupt
 372:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 						// bits 0-2 set: ADC clock prescaler is 128
 373:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 						//  128 prescaler required for 10-bit resolution when FCPU = 20 MHz
 374:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 375:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// NOTE: it is important to make changes to a temporary variable and then set the ADMUX
 376:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// register in a single atomic operation rather than incrementally changing bits of ADMUX.
 377:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// Specifically, setting the ADC channel by first clearing the channel bits of ADMUX and
 378:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// then setting the ones corresponding to the desired channel briefly connects the ADC
 379:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// to channel 0, which can affect the ADC charge capacitor.  For example, if you have a
 380:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// high output impedance voltage on channel 1 and a low output impedance voltage on channel
 381:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// 0, the voltage on channel 0 be briefly applied to the ADC capacitor before every conversion,
 382:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// which could prevent the capacitor from settling to the voltage on channel 1, even over
 383:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	// many reads.
 384:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	uint8_t tempADMUX = ADMUX;
 759               	.LM73:
 760 025a 9091 7C00 		lds r25,124
 385:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 386:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	tempADMUX |= _BV(REFS0);		// Use external capacitor on ARef
 387:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if(use_internal_reference)		// Note: internal reference should NOT be used on devices
 762               	.LM74:
 763 025e 6623      		tst r22
 764 0260 01F0      		breq .L33
 388:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{								//  where AREF is connected to an external voltage!
 389:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		// use the internal voltage reference
 390:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		tempADMUX |= _BV(REFS1);	// Internal reference: 1.1 V on ATmega48/168/328; 2.56 V on ATmega324/64
 766               	.LM75:
 767 0262 906C      		ori r25,lo8(-64)
 768 0264 00C0      		rjmp .L34
 769               	.L33:
 391:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 392:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else
 393:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 394:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		// use AVcc as a reference
 395:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		tempADMUX &= ~_BV(REFS1);	// External reference: on AVcc
 771               	.LM76:
 772 0266 9F77      		andi r25,lo8(127)
 773 0268 9064      		ori r25,lo8(64)
 774               	.L34:
 396:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 397:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 398:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	tempADMUX &= ~0x1F;		 // clear channel selection bits of ADMUX
 776               	.LM77:
 777 026a 907E      		andi r25,lo8(-32)
 399:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	tempADMUX |= channel;    // we only get this far if channel is less than 32
 779               	.LM78:
 780 026c 982B      		or r25,r24
 400:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	ADMUX = tempADMUX;
 782               	.LM79:
 783 026e 9093 7C00 		sts 124,r25
 401:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	ADCSRA |= _BV(ADSC); // start the conversion
 785               	.LM80:
 786 0272 8091 7A00 		lds r24,122
 787 0276 8064      		ori r24,lo8(64)
 788 0278 8093 7A00 		sts 122,r24
 789               	.L31:
 790 027c 0895      		ret
 792               	.Lscope13:
 794               		.stabd	78,0,0
 796               	.global	analogConversionResult
 798               	analogConversionResult:
 799               		.stabd	46,0,0
 402:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 403:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 
 404:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** // returns the result of the previous ADC conversion.
 405:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** uint16_t analogConversionResult()
 406:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** {
 801               	.LM81:
 802               	.LFBB14:
 803               	/* prologue: function */
 804               	/* frame size = 0 */
 805               	/* stack size = 0 */
 806               	.L__stack_usage = 0
 407:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	if (getAnalogMode())				// if left-adjusted (i.e. 8-bit mode)
 808               	.LM82:
 809 027e 0E94 0000 		call getAnalogMode
 810 0282 8823      		tst r24
 811 0284 01F0      		breq .L36
 408:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 409:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		return (uint16_t) ADCH;			// 8-bit result
 813               	.LM83:
 814 0286 2091 7900 		lds r18,121
 815 028a 30E0      		ldi r19,0
 816 028c 00C0      		rjmp .L37
 817               	.L36:
 410:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 411:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	else
 412:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	{
 413:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 		return ADC;				// 10-bit result
 819               	.LM84:
 820 028e 2091 7800 		lds r18,120
 821 0292 3091 7900 		lds r19,120+1
 822               	.L37:
 414:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** 	}
 415:../freeRTOS750/lib_digitalAnalog/digitalAnalog.c **** }
 824               	.LM85:
 825 0296 C901      		movw r24,r18
 826 0298 0895      		ret
 828               	.Lscope14:
 830               		.stabd	78,0,0
 832               	.Letext0:
 833               		.ident	"GCC: (GNU) 4.7.2"
DEFINED SYMBOLS
                            *ABS*:00000000 digitalAnalog.c
     /tmp/ccd0csDz.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccd0csDz.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccd0csDz.s:4      *ABS*:0000003f __SREG__
     /tmp/ccd0csDz.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccd0csDz.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccd0csDz.s:78     .text:00000000 getIORegisters
     /tmp/ccd0csDz.s:218    .text:00000090 setDataDirection
     /tmp/ccd0csDz.s:270    .text:000000b2 setOutputValue
     /tmp/ccd0csDz.s:330    .text:000000e2 getInputValue
     /tmp/ccd0csDz.s:359    .text:000000f0 setDIDValue
     /tmp/ccd0csDz.s:408    .text:00000116 setDigitalOutput
     /tmp/ccd0csDz.s:480    .text:00000162 setDigitalInput
     /tmp/ccd0csDz.s:543    .text:000001ac disableDigitalInput
     /tmp/ccd0csDz.s:597    .text:000001e6 isDigitalInputHigh
     /tmp/ccd0csDz.s:656    .text:00000220 setAnalogMode
     /tmp/ccd0csDz.s:689    .text:00000238 getAnalogMode
     /tmp/ccd0csDz.s:714    .text:00000244 analogIsConverting
     /tmp/ccd0csDz.s:741    .text:00000250 startAnalogConversion
     /tmp/ccd0csDz.s:798    .text:0000027e analogConversionResult

NO UNDEFINED SYMBOLS
