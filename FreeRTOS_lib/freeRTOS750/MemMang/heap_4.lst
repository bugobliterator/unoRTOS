   1               		.file	"heap_4.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 123               	prvInsertBlockIntoFreeList:
 124               		.stabd	46,0,0
   1:../freeRTOS750/MemMang/heap_4.c **** /*
   2:../freeRTOS750/MemMang/heap_4.c ****     FreeRTOS V7.5.0 - Copyright (C) 2013 Real Time Engineers Ltd.
   3:../freeRTOS750/MemMang/heap_4.c **** 
   4:../freeRTOS750/MemMang/heap_4.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   5:../freeRTOS750/MemMang/heap_4.c **** 
   6:../freeRTOS750/MemMang/heap_4.c ****     ***************************************************************************
   7:../freeRTOS750/MemMang/heap_4.c ****      *                                                                       *
   8:../freeRTOS750/MemMang/heap_4.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
   9:../freeRTOS750/MemMang/heap_4.c ****      *    robust, strictly quality controlled, supported, and cross          *
  10:../freeRTOS750/MemMang/heap_4.c ****      *    platform software that has become a de facto standard.             *
  11:../freeRTOS750/MemMang/heap_4.c ****      *                                                                       *
  12:../freeRTOS750/MemMang/heap_4.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  13:../freeRTOS750/MemMang/heap_4.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  14:../freeRTOS750/MemMang/heap_4.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  15:../freeRTOS750/MemMang/heap_4.c ****      *                                                                       *
  16:../freeRTOS750/MemMang/heap_4.c ****      *    Thank you!                                                         *
  17:../freeRTOS750/MemMang/heap_4.c ****      *                                                                       *
  18:../freeRTOS750/MemMang/heap_4.c ****     ***************************************************************************
  19:../freeRTOS750/MemMang/heap_4.c **** 
  20:../freeRTOS750/MemMang/heap_4.c ****     This file is part of the FreeRTOS distribution.
  21:../freeRTOS750/MemMang/heap_4.c **** 
  22:../freeRTOS750/MemMang/heap_4.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  23:../freeRTOS750/MemMang/heap_4.c ****     the terms of the GNU General Public License (version 2) as published by the
  24:../freeRTOS750/MemMang/heap_4.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  25:../freeRTOS750/MemMang/heap_4.c **** 
  26:../freeRTOS750/MemMang/heap_4.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  27:../freeRTOS750/MemMang/heap_4.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  28:../freeRTOS750/MemMang/heap_4.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  29:../freeRTOS750/MemMang/heap_4.c ****     >>! kernel.
  30:../freeRTOS750/MemMang/heap_4.c **** 
  31:../freeRTOS750/MemMang/heap_4.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  32:../freeRTOS750/MemMang/heap_4.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  33:../freeRTOS750/MemMang/heap_4.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  34:../freeRTOS750/MemMang/heap_4.c ****     link: http://www.freertos.org/a00114.html
  35:../freeRTOS750/MemMang/heap_4.c **** 
  36:../freeRTOS750/MemMang/heap_4.c ****     1 tab == 4 spaces!
  37:../freeRTOS750/MemMang/heap_4.c **** 
  38:../freeRTOS750/MemMang/heap_4.c ****     ***************************************************************************
  39:../freeRTOS750/MemMang/heap_4.c ****      *                                                                       *
  40:../freeRTOS750/MemMang/heap_4.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  41:../freeRTOS750/MemMang/heap_4.c ****      *    not run, what could be wrong?"                                     *
  42:../freeRTOS750/MemMang/heap_4.c ****      *                                                                       *
  43:../freeRTOS750/MemMang/heap_4.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  44:../freeRTOS750/MemMang/heap_4.c ****      *                                                                       *
  45:../freeRTOS750/MemMang/heap_4.c ****     ***************************************************************************
  46:../freeRTOS750/MemMang/heap_4.c **** 
  47:../freeRTOS750/MemMang/heap_4.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  48:../freeRTOS750/MemMang/heap_4.c ****     license and Real Time Engineers Ltd. contact details.
  49:../freeRTOS750/MemMang/heap_4.c **** 
  50:../freeRTOS750/MemMang/heap_4.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  51:../freeRTOS750/MemMang/heap_4.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  52:../freeRTOS750/MemMang/heap_4.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  53:../freeRTOS750/MemMang/heap_4.c **** 
  54:../freeRTOS750/MemMang/heap_4.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  55:../freeRTOS750/MemMang/heap_4.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  56:../freeRTOS750/MemMang/heap_4.c ****     licenses offer ticketed support, indemnification and middleware.
  57:../freeRTOS750/MemMang/heap_4.c **** 
  58:../freeRTOS750/MemMang/heap_4.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  59:../freeRTOS750/MemMang/heap_4.c ****     engineered and independently SIL3 certified version for use in safety and
  60:../freeRTOS750/MemMang/heap_4.c ****     mission critical applications that require provable dependability.
  61:../freeRTOS750/MemMang/heap_4.c **** 
  62:../freeRTOS750/MemMang/heap_4.c ****     1 tab == 4 spaces!
  63:../freeRTOS750/MemMang/heap_4.c **** */
  64:../freeRTOS750/MemMang/heap_4.c **** 
  65:../freeRTOS750/MemMang/heap_4.c **** /*
  66:../freeRTOS750/MemMang/heap_4.c ****  * A sample implementation of pvPortMalloc() and vPortFree() that combines 
  67:../freeRTOS750/MemMang/heap_4.c ****  * (coalescences) adjacent memory blocks as they are freed, and in so doing 
  68:../freeRTOS750/MemMang/heap_4.c ****  * limits memory fragmentation.
  69:../freeRTOS750/MemMang/heap_4.c ****  *
  70:../freeRTOS750/MemMang/heap_4.c ****  * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the 
  71:../freeRTOS750/MemMang/heap_4.c ****  * memory management pages of http://www.FreeRTOS.org for more information.
  72:../freeRTOS750/MemMang/heap_4.c ****  */
  73:../freeRTOS750/MemMang/heap_4.c **** #include <stdlib.h>
  74:../freeRTOS750/MemMang/heap_4.c **** 
  75:../freeRTOS750/MemMang/heap_4.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  76:../freeRTOS750/MemMang/heap_4.c **** all the API functions to use the MPU wrappers.  That should only be done when
  77:../freeRTOS750/MemMang/heap_4.c **** task.h is included from an application file. */
  78:../freeRTOS750/MemMang/heap_4.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  79:../freeRTOS750/MemMang/heap_4.c **** 
  80:../freeRTOS750/MemMang/heap_4.c **** #include "FreeRTOS.h"
  81:../freeRTOS750/MemMang/heap_4.c **** #include "task.h"
  82:../freeRTOS750/MemMang/heap_4.c **** 
  83:../freeRTOS750/MemMang/heap_4.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  84:../freeRTOS750/MemMang/heap_4.c **** 
  85:../freeRTOS750/MemMang/heap_4.c **** /* Block sizes must not get too small. */
  86:../freeRTOS750/MemMang/heap_4.c **** #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )
  87:../freeRTOS750/MemMang/heap_4.c **** 
  88:../freeRTOS750/MemMang/heap_4.c **** /* Assumes 8bit bytes! */
  89:../freeRTOS750/MemMang/heap_4.c **** #define heapBITS_PER_BYTE		( ( size_t ) 8 )
  90:../freeRTOS750/MemMang/heap_4.c **** 
  91:../freeRTOS750/MemMang/heap_4.c **** /* A few bytes might be lost to byte aligning the heap start address. */
  92:../freeRTOS750/MemMang/heap_4.c **** #define heapADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
  93:../freeRTOS750/MemMang/heap_4.c **** 
  94:../freeRTOS750/MemMang/heap_4.c **** /* Allocate the memory for the heap. */
  95:../freeRTOS750/MemMang/heap_4.c **** #if ( defined(portEXT_RAM) && !defined(portEXT_RAMFS) )
  96:../freeRTOS750/MemMang/heap_4.c **** static unsigned char ucHeap[ configTOTAL_HEAP_SIZE ]  __attribute__((section(".ext_ram_heap"))); //
  97:../freeRTOS750/MemMang/heap_4.c **** #else
  98:../freeRTOS750/MemMang/heap_4.c **** static unsigned char ucHeap[ configTOTAL_HEAP_SIZE ];
  99:../freeRTOS750/MemMang/heap_4.c **** #endif
 100:../freeRTOS750/MemMang/heap_4.c **** 
 101:../freeRTOS750/MemMang/heap_4.c **** /* Define the linked list structure.  This is used to link free blocks in order
 102:../freeRTOS750/MemMang/heap_4.c **** of their memory address. */
 103:../freeRTOS750/MemMang/heap_4.c **** typedef struct A_BLOCK_LINK
 104:../freeRTOS750/MemMang/heap_4.c **** {
 105:../freeRTOS750/MemMang/heap_4.c **** 	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
 106:../freeRTOS750/MemMang/heap_4.c **** 	size_t xBlockSize;						/*<< The size of the free block. */
 107:../freeRTOS750/MemMang/heap_4.c **** } xBlockLink;
 108:../freeRTOS750/MemMang/heap_4.c **** 
 109:../freeRTOS750/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 110:../freeRTOS750/MemMang/heap_4.c **** 
 111:../freeRTOS750/MemMang/heap_4.c **** /*
 112:../freeRTOS750/MemMang/heap_4.c ****  * Inserts a block of memory that is being freed into the correct position in 
 113:../freeRTOS750/MemMang/heap_4.c ****  * the list of free memory blocks.  The block being freed will be merged with
 114:../freeRTOS750/MemMang/heap_4.c ****  * the block in front it and/or the block behind it if the memory blocks are
 115:../freeRTOS750/MemMang/heap_4.c ****  * adjacent to each other.
 116:../freeRTOS750/MemMang/heap_4.c ****  */
 117:../freeRTOS750/MemMang/heap_4.c **** static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert );
 118:../freeRTOS750/MemMang/heap_4.c **** 
 119:../freeRTOS750/MemMang/heap_4.c **** /*
 120:../freeRTOS750/MemMang/heap_4.c ****  * Called automatically to setup the required heap structures the first time
 121:../freeRTOS750/MemMang/heap_4.c ****  * pvPortMalloc() is called.
 122:../freeRTOS750/MemMang/heap_4.c ****  */
 123:../freeRTOS750/MemMang/heap_4.c **** static void prvHeapInit( void );
 124:../freeRTOS750/MemMang/heap_4.c **** 
 125:../freeRTOS750/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 126:../freeRTOS750/MemMang/heap_4.c **** 
 127:../freeRTOS750/MemMang/heap_4.c **** /* The size of the structure placed at the beginning of each allocated memory
 128:../freeRTOS750/MemMang/heap_4.c **** block must by correctly byte aligned. */
 129:../freeRTOS750/MemMang/heap_4.c **** static const unsigned short heapSTRUCT_SIZE	= ( ( sizeof ( xBlockLink ) + ( portBYTE_ALIGNMENT - 1 
 130:../freeRTOS750/MemMang/heap_4.c **** 
 131:../freeRTOS750/MemMang/heap_4.c **** /* Ensure the pxEnd pointer will end up on the correct byte alignment. */
 132:../freeRTOS750/MemMang/heap_4.c **** static const size_t xTotalHeapSize = ( ( size_t ) heapADJUSTED_HEAP_SIZE ) & ( ( size_t ) ~portBYTE
 133:../freeRTOS750/MemMang/heap_4.c **** 
 134:../freeRTOS750/MemMang/heap_4.c **** /* Create a couple of list links to mark the start and end of the list. */
 135:../freeRTOS750/MemMang/heap_4.c **** static xBlockLink xStart, *pxEnd = NULL;
 136:../freeRTOS750/MemMang/heap_4.c **** 
 137:../freeRTOS750/MemMang/heap_4.c **** /* Keeps track of the number of free bytes remaining, but says nothing about
 138:../freeRTOS750/MemMang/heap_4.c **** fragmentation. */
 139:../freeRTOS750/MemMang/heap_4.c **** static size_t xFreeBytesRemaining = ( ( size_t ) heapADJUSTED_HEAP_SIZE ) & ( ( size_t ) ~portBYTE_
 140:../freeRTOS750/MemMang/heap_4.c **** 
 141:../freeRTOS750/MemMang/heap_4.c **** /* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize 
 142:../freeRTOS750/MemMang/heap_4.c **** member of an xBlockLink structure is set then the block belongs to the 
 143:../freeRTOS750/MemMang/heap_4.c **** application.  When the bit is free the block is still part of the free heap
 144:../freeRTOS750/MemMang/heap_4.c **** space. */
 145:../freeRTOS750/MemMang/heap_4.c **** static size_t xBlockAllocatedBit = 0;
 146:../freeRTOS750/MemMang/heap_4.c **** 
 147:../freeRTOS750/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 148:../freeRTOS750/MemMang/heap_4.c **** 
 149:../freeRTOS750/MemMang/heap_4.c **** void *pvPortMalloc( size_t xWantedSize )
 150:../freeRTOS750/MemMang/heap_4.c **** {
 151:../freeRTOS750/MemMang/heap_4.c **** xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
 152:../freeRTOS750/MemMang/heap_4.c **** void *pvReturn = NULL;
 153:../freeRTOS750/MemMang/heap_4.c **** 
 154:../freeRTOS750/MemMang/heap_4.c **** 	vTaskSuspendAll();
 155:../freeRTOS750/MemMang/heap_4.c **** 	{
 156:../freeRTOS750/MemMang/heap_4.c **** 		/* If this is the first call to malloc then the heap will require
 157:../freeRTOS750/MemMang/heap_4.c **** 		initialisation to setup the list of free blocks. */
 158:../freeRTOS750/MemMang/heap_4.c **** 		if( pxEnd == NULL )
 159:../freeRTOS750/MemMang/heap_4.c **** 		{
 160:../freeRTOS750/MemMang/heap_4.c **** 			prvHeapInit();
 161:../freeRTOS750/MemMang/heap_4.c **** 		}
 162:../freeRTOS750/MemMang/heap_4.c **** 
 163:../freeRTOS750/MemMang/heap_4.c **** 		/* Check the requested block size is not so large that the top bit is
 164:../freeRTOS750/MemMang/heap_4.c **** 		set.  The top bit of the block size member of the xBlockLink structure 
 165:../freeRTOS750/MemMang/heap_4.c **** 		is used to determine who owns the block - the application or the
 166:../freeRTOS750/MemMang/heap_4.c **** 		kernel, so it must be free. */
 167:../freeRTOS750/MemMang/heap_4.c **** 		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 168:../freeRTOS750/MemMang/heap_4.c **** 		{
 169:../freeRTOS750/MemMang/heap_4.c **** 			/* The wanted size is increased so it can contain a xBlockLink
 170:../freeRTOS750/MemMang/heap_4.c **** 			structure in addition to the requested amount of bytes. */
 171:../freeRTOS750/MemMang/heap_4.c **** 			if( xWantedSize > 0 )
 172:../freeRTOS750/MemMang/heap_4.c **** 			{
 173:../freeRTOS750/MemMang/heap_4.c **** 				xWantedSize += heapSTRUCT_SIZE;
 174:../freeRTOS750/MemMang/heap_4.c **** 
 175:../freeRTOS750/MemMang/heap_4.c **** 				/* Ensure that blocks are always aligned to the required number 
 176:../freeRTOS750/MemMang/heap_4.c **** 				of bytes. */
 177:../freeRTOS750/MemMang/heap_4.c **** 				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 178:../freeRTOS750/MemMang/heap_4.c **** 				{
 179:../freeRTOS750/MemMang/heap_4.c **** 					/* Byte alignment required. */
 180:../freeRTOS750/MemMang/heap_4.c **** 					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 181:../freeRTOS750/MemMang/heap_4.c **** 				}
 182:../freeRTOS750/MemMang/heap_4.c **** 			}
 183:../freeRTOS750/MemMang/heap_4.c **** 
 184:../freeRTOS750/MemMang/heap_4.c **** 			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 185:../freeRTOS750/MemMang/heap_4.c **** 			{
 186:../freeRTOS750/MemMang/heap_4.c **** 				/* Traverse the list from the start	(lowest address) block until 
 187:../freeRTOS750/MemMang/heap_4.c **** 				one	of adequate size is found. */
 188:../freeRTOS750/MemMang/heap_4.c **** 				pxPreviousBlock = &xStart;
 189:../freeRTOS750/MemMang/heap_4.c **** 				pxBlock = xStart.pxNextFreeBlock;
 190:../freeRTOS750/MemMang/heap_4.c **** 				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 191:../freeRTOS750/MemMang/heap_4.c **** 				{
 192:../freeRTOS750/MemMang/heap_4.c **** 					pxPreviousBlock = pxBlock;
 193:../freeRTOS750/MemMang/heap_4.c **** 					pxBlock = pxBlock->pxNextFreeBlock;
 194:../freeRTOS750/MemMang/heap_4.c **** 				}
 195:../freeRTOS750/MemMang/heap_4.c **** 
 196:../freeRTOS750/MemMang/heap_4.c **** 				/* If the end marker was reached then a block of adequate size 
 197:../freeRTOS750/MemMang/heap_4.c **** 				was	not found. */
 198:../freeRTOS750/MemMang/heap_4.c **** 				if( pxBlock != pxEnd )
 199:../freeRTOS750/MemMang/heap_4.c **** 				{
 200:../freeRTOS750/MemMang/heap_4.c **** 					/* Return the memory space pointed to - jumping over the 
 201:../freeRTOS750/MemMang/heap_4.c **** 					xBlockLink structure at its start. */
 202:../freeRTOS750/MemMang/heap_4.c **** 					pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_
 203:../freeRTOS750/MemMang/heap_4.c **** 
 204:../freeRTOS750/MemMang/heap_4.c **** 					/* This block is being returned for use so must be taken out 
 205:../freeRTOS750/MemMang/heap_4.c **** 					of the list of free blocks. */
 206:../freeRTOS750/MemMang/heap_4.c **** 					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 207:../freeRTOS750/MemMang/heap_4.c **** 
 208:../freeRTOS750/MemMang/heap_4.c **** 					/* If the block is larger than required it can be split into 
 209:../freeRTOS750/MemMang/heap_4.c **** 					two. */
 210:../freeRTOS750/MemMang/heap_4.c **** 					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 211:../freeRTOS750/MemMang/heap_4.c **** 					{
 212:../freeRTOS750/MemMang/heap_4.c **** 						/* This block is to be split into two.  Create a new 
 213:../freeRTOS750/MemMang/heap_4.c **** 						block following the number of bytes requested. The void 
 214:../freeRTOS750/MemMang/heap_4.c **** 						cast is used to prevent byte alignment warnings from the 
 215:../freeRTOS750/MemMang/heap_4.c **** 						compiler. */
 216:../freeRTOS750/MemMang/heap_4.c **** 						pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
 217:../freeRTOS750/MemMang/heap_4.c **** 
 218:../freeRTOS750/MemMang/heap_4.c **** 						/* Calculate the sizes of two blocks split from the 
 219:../freeRTOS750/MemMang/heap_4.c **** 						single block. */
 220:../freeRTOS750/MemMang/heap_4.c **** 						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 221:../freeRTOS750/MemMang/heap_4.c **** 						pxBlock->xBlockSize = xWantedSize;
 222:../freeRTOS750/MemMang/heap_4.c **** 
 223:../freeRTOS750/MemMang/heap_4.c **** 						/* Insert the new block into the list of free blocks. */
 224:../freeRTOS750/MemMang/heap_4.c **** 						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 225:../freeRTOS750/MemMang/heap_4.c **** 					}
 226:../freeRTOS750/MemMang/heap_4.c **** 
 227:../freeRTOS750/MemMang/heap_4.c **** 					xFreeBytesRemaining -= pxBlock->xBlockSize;
 228:../freeRTOS750/MemMang/heap_4.c **** 
 229:../freeRTOS750/MemMang/heap_4.c **** 					/* The block is being returned - it is allocated and owned
 230:../freeRTOS750/MemMang/heap_4.c **** 					by the application and has no "next" block. */
 231:../freeRTOS750/MemMang/heap_4.c **** 					pxBlock->xBlockSize |= xBlockAllocatedBit;
 232:../freeRTOS750/MemMang/heap_4.c **** 					pxBlock->pxNextFreeBlock = NULL;
 233:../freeRTOS750/MemMang/heap_4.c **** 				}
 234:../freeRTOS750/MemMang/heap_4.c **** 			}
 235:../freeRTOS750/MemMang/heap_4.c **** 		}
 236:../freeRTOS750/MemMang/heap_4.c **** 	}
 237:../freeRTOS750/MemMang/heap_4.c **** 	xTaskResumeAll();
 238:../freeRTOS750/MemMang/heap_4.c **** 
 239:../freeRTOS750/MemMang/heap_4.c **** 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
 240:../freeRTOS750/MemMang/heap_4.c **** 	{
 241:../freeRTOS750/MemMang/heap_4.c **** 		if( pvReturn == NULL )
 242:../freeRTOS750/MemMang/heap_4.c **** 		{
 243:../freeRTOS750/MemMang/heap_4.c **** 			extern void vApplicationMallocFailedHook( void );
 244:../freeRTOS750/MemMang/heap_4.c **** 			vApplicationMallocFailedHook();
 245:../freeRTOS750/MemMang/heap_4.c **** 		}
 246:../freeRTOS750/MemMang/heap_4.c **** 	}
 247:../freeRTOS750/MemMang/heap_4.c **** 	#endif
 248:../freeRTOS750/MemMang/heap_4.c **** 
 249:../freeRTOS750/MemMang/heap_4.c **** 	return pvReturn;
 250:../freeRTOS750/MemMang/heap_4.c **** }
 251:../freeRTOS750/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 252:../freeRTOS750/MemMang/heap_4.c **** 
 253:../freeRTOS750/MemMang/heap_4.c **** void vPortFree( void *pv )
 254:../freeRTOS750/MemMang/heap_4.c **** {
 255:../freeRTOS750/MemMang/heap_4.c **** unsigned char *puc = ( unsigned char * ) pv;
 256:../freeRTOS750/MemMang/heap_4.c **** xBlockLink *pxLink;
 257:../freeRTOS750/MemMang/heap_4.c **** 
 258:../freeRTOS750/MemMang/heap_4.c **** 	if( pv != NULL )
 259:../freeRTOS750/MemMang/heap_4.c **** 	{
 260:../freeRTOS750/MemMang/heap_4.c **** 		/* The memory being freed will have an xBlockLink structure immediately
 261:../freeRTOS750/MemMang/heap_4.c **** 		before it. */
 262:../freeRTOS750/MemMang/heap_4.c **** 		puc -= heapSTRUCT_SIZE;
 263:../freeRTOS750/MemMang/heap_4.c **** 
 264:../freeRTOS750/MemMang/heap_4.c **** 		/* This casting is to keep the compiler from issuing warnings. */
 265:../freeRTOS750/MemMang/heap_4.c **** 		pxLink = ( void * ) puc;
 266:../freeRTOS750/MemMang/heap_4.c **** 
 267:../freeRTOS750/MemMang/heap_4.c **** 		/* Check the block is actually allocated. */
 268:../freeRTOS750/MemMang/heap_4.c **** 		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 269:../freeRTOS750/MemMang/heap_4.c **** 		configASSERT( pxLink->pxNextFreeBlock == NULL );
 270:../freeRTOS750/MemMang/heap_4.c **** 		
 271:../freeRTOS750/MemMang/heap_4.c **** 		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 272:../freeRTOS750/MemMang/heap_4.c **** 		{
 273:../freeRTOS750/MemMang/heap_4.c **** 			if( pxLink->pxNextFreeBlock == NULL )
 274:../freeRTOS750/MemMang/heap_4.c **** 			{
 275:../freeRTOS750/MemMang/heap_4.c **** 				/* The block is being returned to the heap - it is no longer
 276:../freeRTOS750/MemMang/heap_4.c **** 				allocated. */
 277:../freeRTOS750/MemMang/heap_4.c **** 				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 278:../freeRTOS750/MemMang/heap_4.c **** 
 279:../freeRTOS750/MemMang/heap_4.c **** 				vTaskSuspendAll();
 280:../freeRTOS750/MemMang/heap_4.c **** 				{
 281:../freeRTOS750/MemMang/heap_4.c **** 					/* Add this block to the list of free blocks. */
 282:../freeRTOS750/MemMang/heap_4.c **** 					xFreeBytesRemaining += pxLink->xBlockSize;
 283:../freeRTOS750/MemMang/heap_4.c **** 					prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 284:../freeRTOS750/MemMang/heap_4.c **** 				}
 285:../freeRTOS750/MemMang/heap_4.c **** 				xTaskResumeAll();
 286:../freeRTOS750/MemMang/heap_4.c **** 			}
 287:../freeRTOS750/MemMang/heap_4.c **** 		}
 288:../freeRTOS750/MemMang/heap_4.c **** 	}
 289:../freeRTOS750/MemMang/heap_4.c **** }
 290:../freeRTOS750/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 291:../freeRTOS750/MemMang/heap_4.c **** 
 292:../freeRTOS750/MemMang/heap_4.c **** size_t xPortGetFreeHeapSize( void )
 293:../freeRTOS750/MemMang/heap_4.c **** {
 294:../freeRTOS750/MemMang/heap_4.c **** 	return xFreeBytesRemaining;
 295:../freeRTOS750/MemMang/heap_4.c **** }
 296:../freeRTOS750/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 297:../freeRTOS750/MemMang/heap_4.c **** 
 298:../freeRTOS750/MemMang/heap_4.c **** void vPortInitialiseBlocks( void )
 299:../freeRTOS750/MemMang/heap_4.c **** {
 300:../freeRTOS750/MemMang/heap_4.c **** 	/* This just exists to keep the linker quiet. */
 301:../freeRTOS750/MemMang/heap_4.c **** }
 302:../freeRTOS750/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 303:../freeRTOS750/MemMang/heap_4.c **** 
 304:../freeRTOS750/MemMang/heap_4.c **** static void prvHeapInit( void )
 305:../freeRTOS750/MemMang/heap_4.c **** {
 306:../freeRTOS750/MemMang/heap_4.c **** xBlockLink *pxFirstFreeBlock;
 307:../freeRTOS750/MemMang/heap_4.c **** unsigned char *pucHeapEnd, *pucAlignedHeap;
 308:../freeRTOS750/MemMang/heap_4.c **** 
 309:../freeRTOS750/MemMang/heap_4.c **** 	/* Ensure the heap starts on a correctly aligned boundary. */
 310:../freeRTOS750/MemMang/heap_4.c **** 	pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] )
 311:../freeRTOS750/MemMang/heap_4.c **** 
 312:../freeRTOS750/MemMang/heap_4.c **** 	/* xStart is used to hold a pointer to the first item in the list of free
 313:../freeRTOS750/MemMang/heap_4.c **** 	blocks.  The void cast is used to prevent compiler warnings. */
 314:../freeRTOS750/MemMang/heap_4.c **** 	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 315:../freeRTOS750/MemMang/heap_4.c **** 	xStart.xBlockSize = ( size_t ) 0;
 316:../freeRTOS750/MemMang/heap_4.c **** 
 317:../freeRTOS750/MemMang/heap_4.c **** 	/* pxEnd is used to mark the end of the list of free blocks and is inserted
 318:../freeRTOS750/MemMang/heap_4.c **** 	at the end of the heap space. */
 319:../freeRTOS750/MemMang/heap_4.c **** 	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
 320:../freeRTOS750/MemMang/heap_4.c **** 	pucHeapEnd -= heapSTRUCT_SIZE;
 321:../freeRTOS750/MemMang/heap_4.c **** 	pxEnd = ( void * ) pucHeapEnd;
 322:../freeRTOS750/MemMang/heap_4.c **** 	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0
 323:../freeRTOS750/MemMang/heap_4.c **** 	pxEnd->xBlockSize = 0;
 324:../freeRTOS750/MemMang/heap_4.c **** 	pxEnd->pxNextFreeBlock = NULL;
 325:../freeRTOS750/MemMang/heap_4.c **** 
 326:../freeRTOS750/MemMang/heap_4.c **** 	/* To start with there is a single free block that is sized to take up the
 327:../freeRTOS750/MemMang/heap_4.c **** 	entire heap space, minus the space taken by pxEnd. */
 328:../freeRTOS750/MemMang/heap_4.c **** 	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 329:../freeRTOS750/MemMang/heap_4.c **** 	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
 330:../freeRTOS750/MemMang/heap_4.c **** 	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 331:../freeRTOS750/MemMang/heap_4.c **** 
 332:../freeRTOS750/MemMang/heap_4.c **** 	/* The heap now contains pxEnd. */
 333:../freeRTOS750/MemMang/heap_4.c **** 	xFreeBytesRemaining -= heapSTRUCT_SIZE;
 334:../freeRTOS750/MemMang/heap_4.c **** 
 335:../freeRTOS750/MemMang/heap_4.c **** 	/* Work out the position of the top bit in a size_t variable. */
 336:../freeRTOS750/MemMang/heap_4.c **** 	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 337:../freeRTOS750/MemMang/heap_4.c **** }
 338:../freeRTOS750/MemMang/heap_4.c **** /*-----------------------------------------------------------*/
 339:../freeRTOS750/MemMang/heap_4.c **** 
 340:../freeRTOS750/MemMang/heap_4.c **** static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
 341:../freeRTOS750/MemMang/heap_4.c **** {
 126               	.LM0:
 127               	.LFBB1:
 128 0000 CF93      		push r28
 129 0002 DF93      		push r29
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134 0004 FC01      		movw r30,r24
 342:../freeRTOS750/MemMang/heap_4.c **** xBlockLink *pxIterator;
 343:../freeRTOS750/MemMang/heap_4.c **** unsigned char *puc;
 344:../freeRTOS750/MemMang/heap_4.c **** 
 345:../freeRTOS750/MemMang/heap_4.c **** 	/* Iterate through the list until a block is found that has a higher address
 346:../freeRTOS750/MemMang/heap_4.c **** 	than the block being inserted. */
 347:../freeRTOS750/MemMang/heap_4.c **** 	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator-
 136               	.LM1:
 137 0006 A0E0      		ldi r26,lo8(xStart)
 138 0008 B0E0      		ldi r27,hi8(xStart)
 139 000a 00C0      		rjmp .L2
 140               	.L8:
 141 000c DE01      		movw r26,r28
 142               	.L2:
 144               	.LM2:
 145 000e CD91      		ld r28,X+
 146 0010 DC91      		ld r29,X
 147 0012 1197      		sbiw r26,1
 148 0014 CE17      		cp r28,r30
 149 0016 DF07      		cpc r29,r31
 150 0018 00F0      		brlo .L8
 348:../freeRTOS750/MemMang/heap_4.c **** 	{
 349:../freeRTOS750/MemMang/heap_4.c **** 		/* Nothing to do here, just iterate to the right position. */
 350:../freeRTOS750/MemMang/heap_4.c **** 	}
 351:../freeRTOS750/MemMang/heap_4.c **** 
 352:../freeRTOS750/MemMang/heap_4.c **** 	/* Do the block being inserted, and the block it is being inserted after
 353:../freeRTOS750/MemMang/heap_4.c **** 	make a contiguous block of memory? */	
 354:../freeRTOS750/MemMang/heap_4.c **** 	puc = ( unsigned char * ) pxIterator;
 355:../freeRTOS750/MemMang/heap_4.c **** 	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
 152               	.LM3:
 153 001a 1296      		adiw r26,2
 154 001c 2D91      		ld r18,X+
 155 001e 3C91      		ld r19,X
 156 0020 1397      		sbiw r26,2+1
 157 0022 CD01      		movw r24,r26
 158 0024 820F      		add r24,r18
 159 0026 931F      		adc r25,r19
 160 0028 8E17      		cp r24,r30
 161 002a 9F07      		cpc r25,r31
 162 002c 01F4      		brne .L3
 356:../freeRTOS750/MemMang/heap_4.c **** 	{
 357:../freeRTOS750/MemMang/heap_4.c **** 		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 164               	.LM4:
 165 002e 8281      		ldd r24,Z+2
 166 0030 9381      		ldd r25,Z+3
 167 0032 820F      		add r24,r18
 168 0034 931F      		adc r25,r19
 169 0036 1396      		adiw r26,2+1
 170 0038 9C93      		st X,r25
 171 003a 8E93      		st -X,r24
 172 003c 1297      		sbiw r26,2
 173 003e FD01      		movw r30,r26
 174               	.L3:
 358:../freeRTOS750/MemMang/heap_4.c **** 		pxBlockToInsert = pxIterator;
 359:../freeRTOS750/MemMang/heap_4.c **** 	}
 360:../freeRTOS750/MemMang/heap_4.c **** 
 361:../freeRTOS750/MemMang/heap_4.c **** 	/* Do the block being inserted, and the block it is being inserted before
 362:../freeRTOS750/MemMang/heap_4.c **** 	make a contiguous block of memory? */
 363:../freeRTOS750/MemMang/heap_4.c **** 	puc = ( unsigned char * ) pxBlockToInsert;
 364:../freeRTOS750/MemMang/heap_4.c **** 	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
 176               	.LM5:
 177 0040 2281      		ldd r18,Z+2
 178 0042 3381      		ldd r19,Z+3
 179 0044 CF01      		movw r24,r30
 180 0046 820F      		add r24,r18
 181 0048 931F      		adc r25,r19
 182 004a 8C17      		cp r24,r28
 183 004c 9D07      		cpc r25,r29
 184 004e 01F4      		brne .L4
 365:../freeRTOS750/MemMang/heap_4.c **** 	{
 366:../freeRTOS750/MemMang/heap_4.c **** 		if( pxIterator->pxNextFreeBlock != pxEnd )
 186               	.LM6:
 187 0050 8091 0000 		lds r24,pxEnd
 188 0054 9091 0000 		lds r25,pxEnd+1
 189 0058 C817      		cp r28,r24
 190 005a D907      		cpc r29,r25
 191 005c 01F0      		breq .L4
 367:../freeRTOS750/MemMang/heap_4.c **** 		{
 368:../freeRTOS750/MemMang/heap_4.c **** 			/* Form one big block from the two blocks. */
 369:../freeRTOS750/MemMang/heap_4.c **** 			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 193               	.LM7:
 194 005e 8A81      		ldd r24,Y+2
 195 0060 9B81      		ldd r25,Y+3
 196 0062 820F      		add r24,r18
 197 0064 931F      		adc r25,r19
 198 0066 9383      		std Z+3,r25
 199 0068 8283      		std Z+2,r24
 370:../freeRTOS750/MemMang/heap_4.c **** 			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 201               	.LM8:
 202 006a 8881      		ld r24,Y
 203 006c 9981      		ldd r25,Y+1
 204 006e 9183      		std Z+1,r25
 205 0070 8083      		st Z,r24
 206 0072 00C0      		rjmp .L6
 207               	.L4:
 371:../freeRTOS750/MemMang/heap_4.c **** 		}
 372:../freeRTOS750/MemMang/heap_4.c **** 		else
 373:../freeRTOS750/MemMang/heap_4.c **** 		{
 374:../freeRTOS750/MemMang/heap_4.c **** 			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 375:../freeRTOS750/MemMang/heap_4.c **** 		}
 376:../freeRTOS750/MemMang/heap_4.c **** 	}
 377:../freeRTOS750/MemMang/heap_4.c **** 	else
 378:../freeRTOS750/MemMang/heap_4.c **** 	{
 379:../freeRTOS750/MemMang/heap_4.c **** 		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
 209               	.LM9:
 210 0074 D183      		std Z+1,r29
 211 0076 C083      		st Z,r28
 212               	.L6:
 380:../freeRTOS750/MemMang/heap_4.c **** 	}
 381:../freeRTOS750/MemMang/heap_4.c **** 
 382:../freeRTOS750/MemMang/heap_4.c **** 	/* If the block being inserted plugged a gab, so was merged with the block
 383:../freeRTOS750/MemMang/heap_4.c **** 	before and the block after, then it's pxNextFreeBlock pointer will have
 384:../freeRTOS750/MemMang/heap_4.c **** 	already been set, and should not be set here as that would make it point
 385:../freeRTOS750/MemMang/heap_4.c **** 	to itself. */
 386:../freeRTOS750/MemMang/heap_4.c **** 	if( pxIterator != pxBlockToInsert )
 214               	.LM10:
 215 0078 AE17      		cp r26,r30
 216 007a BF07      		cpc r27,r31
 217 007c 01F0      		breq .L1
 387:../freeRTOS750/MemMang/heap_4.c **** 	{
 388:../freeRTOS750/MemMang/heap_4.c **** 		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 219               	.LM11:
 220 007e ED93      		st X+,r30
 221 0080 FC93      		st X,r31
 222               	.L1:
 223               	/* epilogue start */
 389:../freeRTOS750/MemMang/heap_4.c **** 	}
 390:../freeRTOS750/MemMang/heap_4.c **** }
 225               	.LM12:
 226 0082 DF91      		pop r29
 227 0084 CF91      		pop r28
 228 0086 0895      		ret
 230               	.Lscope1:
 232               		.stabd	78,0,0
 235               	.global	pvPortMalloc
 237               	pvPortMalloc:
 238               		.stabd	46,0,0
 150:../freeRTOS750/MemMang/heap_4.c **** {
 240               	.LM13:
 241               	.LFBB2:
 242 0088 CF92      		push r12
 243 008a DF92      		push r13
 244 008c EF92      		push r14
 245 008e FF92      		push r15
 246 0090 0F93      		push r16
 247 0092 1F93      		push r17
 248 0094 CF93      		push r28
 249 0096 DF93      		push r29
 250               	/* prologue: function */
 251               	/* frame size = 0 */
 252               	/* stack size = 8 */
 253               	.L__stack_usage = 8
 254 0098 EC01      		movw r28,r24
 154:../freeRTOS750/MemMang/heap_4.c **** 	vTaskSuspendAll();
 256               	.LM14:
 257 009a 0E94 0000 		call vTaskSuspendAll
 158:../freeRTOS750/MemMang/heap_4.c **** 		if( pxEnd == NULL )
 259               	.LM15:
 260 009e 8091 0000 		lds r24,pxEnd
 261 00a2 9091 0000 		lds r25,pxEnd+1
 262 00a6 892B      		or r24,r25
 263 00a8 01F4      		brne .L10
 264               	.LBB4:
 265               	.LBB5:
 314:../freeRTOS750/MemMang/heap_4.c **** 	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 267               	.LM16:
 268 00aa 80E0      		ldi r24,lo8(ucHeap+1)
 269 00ac 90E0      		ldi r25,hi8(ucHeap+1)
 270 00ae 9093 0000 		sts xStart+1,r25
 271 00b2 8093 0000 		sts xStart,r24
 315:../freeRTOS750/MemMang/heap_4.c **** 	xStart.xBlockSize = ( size_t ) 0;
 273               	.LM17:
 274 00b6 1092 0000 		sts xStart+2+1,__zero_reg__
 275 00ba 1092 0000 		sts xStart+2,__zero_reg__
 321:../freeRTOS750/MemMang/heap_4.c **** 	pxEnd = ( void * ) pucHeapEnd;
 277               	.LM18:
 278 00be 80E0      		ldi r24,lo8(ucHeap+1496)
 279 00c0 90E0      		ldi r25,hi8(ucHeap+1496)
 280 00c2 9093 0000 		sts pxEnd+1,r25
 281 00c6 8093 0000 		sts pxEnd,r24
 323:../freeRTOS750/MemMang/heap_4.c **** 	pxEnd->xBlockSize = 0;
 283               	.LM19:
 284 00ca 1092 0000 		sts ucHeap+1498+1,__zero_reg__
 285 00ce 1092 0000 		sts ucHeap+1498,__zero_reg__
 324:../freeRTOS750/MemMang/heap_4.c **** 	pxEnd->pxNextFreeBlock = NULL;
 287               	.LM20:
 288 00d2 1092 0000 		sts ucHeap+1496+1,__zero_reg__
 289 00d6 1092 0000 		sts ucHeap+1496,__zero_reg__
 329:../freeRTOS750/MemMang/heap_4.c **** 	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
 291               	.LM21:
 292 00da 27ED      		ldi r18,lo8(-41)
 293 00dc 35E0      		ldi r19,lo8(5)
 294 00de 3093 0000 		sts ucHeap+3+1,r19
 295 00e2 2093 0000 		sts ucHeap+3,r18
 330:../freeRTOS750/MemMang/heap_4.c **** 	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 297               	.LM22:
 298 00e6 9093 0000 		sts ucHeap+1+1,r25
 299 00ea 8093 0000 		sts ucHeap+1,r24
 333:../freeRTOS750/MemMang/heap_4.c **** 	xFreeBytesRemaining -= heapSTRUCT_SIZE;
 301               	.LM23:
 302 00ee 8091 0000 		lds r24,xFreeBytesRemaining
 303 00f2 9091 0000 		lds r25,xFreeBytesRemaining+1
 304 00f6 0497      		sbiw r24,4
 305 00f8 9093 0000 		sts xFreeBytesRemaining+1,r25
 306 00fc 8093 0000 		sts xFreeBytesRemaining,r24
 336:../freeRTOS750/MemMang/heap_4.c **** 	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 308               	.LM24:
 309 0100 80E0      		ldi r24,0
 310 0102 90E8      		ldi r25,lo8(-128)
 311 0104 9093 0000 		sts xBlockAllocatedBit+1,r25
 312 0108 8093 0000 		sts xBlockAllocatedBit,r24
 313               	.L10:
 314               	.LBE5:
 315               	.LBE4:
 167:../freeRTOS750/MemMang/heap_4.c **** 		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 317               	.LM25:
 318 010c E090 0000 		lds r14,xBlockAllocatedBit
 319 0110 F090 0000 		lds r15,xBlockAllocatedBit+1
 320 0114 CE01      		movw r24,r28
 321 0116 8E21      		and r24,r14
 322 0118 9F21      		and r25,r15
 323 011a 892B      		or r24,r25
 324 011c 01F0      		breq .+2
 325 011e 00C0      		rjmp .L20
 171:../freeRTOS750/MemMang/heap_4.c **** 			if( xWantedSize > 0 )
 327               	.LM26:
 328 0120 2097      		sbiw r28,0
 329 0122 01F4      		brne .+2
 330 0124 00C0      		rjmp .L20
 173:../freeRTOS750/MemMang/heap_4.c **** 				xWantedSize += heapSTRUCT_SIZE;
 332               	.LM27:
 333 0126 9E01      		movw r18,r28
 334 0128 2C5F      		subi r18,-4
 335 012a 3F4F      		sbci r19,-1
 184:../freeRTOS750/MemMang/heap_4.c **** 			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 337               	.LM28:
 338 012c 01F4      		brne .+2
 339 012e 00C0      		rjmp .L20
 184:../freeRTOS750/MemMang/heap_4.c **** 			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 341               	.LM29:
 342 0130 C090 0000 		lds r12,xFreeBytesRemaining
 343 0134 D090 0000 		lds r13,xFreeBytesRemaining+1
 344 0138 C216      		cp r12,r18
 345 013a D306      		cpc r13,r19
 346 013c 00F4      		brsh .+2
 347 013e 00C0      		rjmp .L20
 189:../freeRTOS750/MemMang/heap_4.c **** 				pxBlock = xStart.pxNextFreeBlock;
 349               	.LM30:
 350 0140 C091 0000 		lds r28,xStart
 351 0144 D091 0000 		lds r29,xStart+1
 188:../freeRTOS750/MemMang/heap_4.c **** 				pxPreviousBlock = &xStart;
 353               	.LM31:
 354 0148 E0E0      		ldi r30,lo8(xStart)
 355 014a F0E0      		ldi r31,hi8(xStart)
 190:../freeRTOS750/MemMang/heap_4.c **** 				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 357               	.LM32:
 358 014c 00C0      		rjmp .L14
 359               	.L21:
 360 014e EC2F      		mov r30,r28
 361 0150 FD2F      		mov r31,r29
 193:../freeRTOS750/MemMang/heap_4.c **** 					pxBlock = pxBlock->pxNextFreeBlock;
 363               	.LM33:
 364 0152 EC01      		movw r28,r24
 365               	.L14:
 190:../freeRTOS750/MemMang/heap_4.c **** 				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 367               	.LM34:
 368 0154 4A81      		ldd r20,Y+2
 369 0156 5B81      		ldd r21,Y+3
 370 0158 4217      		cp r20,r18
 371 015a 5307      		cpc r21,r19
 372 015c 00F0      		brlo .L12
 373               	.L15:
 198:../freeRTOS750/MemMang/heap_4.c **** 				if( pxBlock != pxEnd )
 375               	.LM35:
 376 015e 8091 0000 		lds r24,pxEnd
 377 0162 9091 0000 		lds r25,pxEnd+1
 378 0166 C817      		cp r28,r24
 379 0168 D907      		cpc r29,r25
 380 016a 01F4      		brne .L13
 381 016c 00C0      		rjmp .L20
 382               	.L12:
 190:../freeRTOS750/MemMang/heap_4.c **** 				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 384               	.LM36:
 385 016e 8881      		ld r24,Y
 386 0170 9981      		ldd r25,Y+1
 387 0172 0097      		sbiw r24,0
 388 0174 01F4      		brne .L21
 389 0176 00C0      		rjmp .L15
 390               	.L13:
 202:../freeRTOS750/MemMang/heap_4.c **** 					pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_
 392               	.LM37:
 393 0178 0081      		ld r16,Z
 394 017a 1181      		ldd r17,Z+1
 395 017c 0C5F      		subi r16,-4
 396 017e 1F4F      		sbci r17,-1
 206:../freeRTOS750/MemMang/heap_4.c **** 					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 398               	.LM38:
 399 0180 8881      		ld r24,Y
 400 0182 9981      		ldd r25,Y+1
 401 0184 9183      		std Z+1,r25
 402 0186 8083      		st Z,r24
 210:../freeRTOS750/MemMang/heap_4.c **** 					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 404               	.LM39:
 405 0188 421B      		sub r20,r18
 406 018a 530B      		sbc r21,r19
 407 018c 4930      		cpi r20,9
 408 018e 5105      		cpc r21,__zero_reg__
 409 0190 00F0      		brlo .L16
 216:../freeRTOS750/MemMang/heap_4.c **** 						pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
 411               	.LM40:
 412 0192 CE01      		movw r24,r28
 413 0194 820F      		add r24,r18
 414 0196 931F      		adc r25,r19
 220:../freeRTOS750/MemMang/heap_4.c **** 						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 416               	.LM41:
 417 0198 FC01      		movw r30,r24
 418 019a 5383      		std Z+3,r21
 419 019c 4283      		std Z+2,r20
 221:../freeRTOS750/MemMang/heap_4.c **** 						pxBlock->xBlockSize = xWantedSize;
 421               	.LM42:
 422 019e 3B83      		std Y+3,r19
 423 01a0 2A83      		std Y+2,r18
 224:../freeRTOS750/MemMang/heap_4.c **** 						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 425               	.LM43:
 426 01a2 0E94 0000 		call prvInsertBlockIntoFreeList
 427               	.L16:
 227:../freeRTOS750/MemMang/heap_4.c **** 					xFreeBytesRemaining -= pxBlock->xBlockSize;
 429               	.LM44:
 430 01a6 8A81      		ldd r24,Y+2
 431 01a8 9B81      		ldd r25,Y+3
 432 01aa C81A      		sub r12,r24
 433 01ac D90A      		sbc r13,r25
 434 01ae D092 0000 		sts xFreeBytesRemaining+1,r13
 435 01b2 C092 0000 		sts xFreeBytesRemaining,r12
 231:../freeRTOS750/MemMang/heap_4.c **** 					pxBlock->xBlockSize |= xBlockAllocatedBit;
 437               	.LM45:
 438 01b6 E82A      		or r14,r24
 439 01b8 F92A      		or r15,r25
 440 01ba FB82      		std Y+3,r15
 441 01bc EA82      		std Y+2,r14
 232:../freeRTOS750/MemMang/heap_4.c **** 					pxBlock->pxNextFreeBlock = NULL;
 443               	.LM46:
 444 01be 1982      		std Y+1,__zero_reg__
 445 01c0 1882      		st Y,__zero_reg__
 446 01c2 00C0      		rjmp .L11
 447               	.L20:
 152:../freeRTOS750/MemMang/heap_4.c **** void *pvReturn = NULL;
 449               	.LM47:
 450 01c4 00E0      		ldi r16,0
 451 01c6 10E0      		ldi r17,0
 452               	.L11:
 237:../freeRTOS750/MemMang/heap_4.c **** 	xTaskResumeAll();
 454               	.LM48:
 455 01c8 0E94 0000 		call xTaskResumeAll
 250:../freeRTOS750/MemMang/heap_4.c **** }
 457               	.LM49:
 458 01cc C801      		movw r24,r16
 459               	/* epilogue start */
 460 01ce DF91      		pop r29
 461 01d0 CF91      		pop r28
 462 01d2 1F91      		pop r17
 463 01d4 0F91      		pop r16
 464 01d6 FF90      		pop r15
 465 01d8 EF90      		pop r14
 466 01da DF90      		pop r13
 467 01dc CF90      		pop r12
 468 01de 0895      		ret
 474               	.Lscope2:
 476               		.stabd	78,0,0
 479               	.global	vPortFree
 481               	vPortFree:
 482               		.stabd	46,0,0
 254:../freeRTOS750/MemMang/heap_4.c **** {
 484               	.LM50:
 485               	.LFBB3:
 486 01e0 CF93      		push r28
 487 01e2 DF93      		push r29
 488               	/* prologue: function */
 489               	/* frame size = 0 */
 490               	/* stack size = 2 */
 491               	.L__stack_usage = 2
 258:../freeRTOS750/MemMang/heap_4.c **** 	if( pv != NULL )
 493               	.LM51:
 494 01e4 0097      		sbiw r24,0
 495 01e6 01F0      		breq .L22
 271:../freeRTOS750/MemMang/heap_4.c **** 		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 497               	.LM52:
 498 01e8 EC01      		movw r28,r24
 499 01ea 2497      		sbiw r28,4
 500 01ec 2A81      		ldd r18,Y+2
 501 01ee 3B81      		ldd r19,Y+3
 502 01f0 8091 0000 		lds r24,xBlockAllocatedBit
 503 01f4 9091 0000 		lds r25,xBlockAllocatedBit+1
 504 01f8 AC01      		movw r20,r24
 505 01fa 4223      		and r20,r18
 506 01fc 5323      		and r21,r19
 507 01fe 452B      		or r20,r21
 508 0200 01F0      		breq .L22
 273:../freeRTOS750/MemMang/heap_4.c **** 			if( pxLink->pxNextFreeBlock == NULL )
 510               	.LM53:
 511 0202 4881      		ld r20,Y
 512 0204 5981      		ldd r21,Y+1
 513 0206 452B      		or r20,r21
 514 0208 01F4      		brne .L22
 277:../freeRTOS750/MemMang/heap_4.c **** 				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 516               	.LM54:
 517 020a 8095      		com r24
 518 020c 9095      		com r25
 519 020e 8223      		and r24,r18
 520 0210 9323      		and r25,r19
 521 0212 9B83      		std Y+3,r25
 522 0214 8A83      		std Y+2,r24
 279:../freeRTOS750/MemMang/heap_4.c **** 				vTaskSuspendAll();
 524               	.LM55:
 525 0216 0E94 0000 		call vTaskSuspendAll
 282:../freeRTOS750/MemMang/heap_4.c **** 					xFreeBytesRemaining += pxLink->xBlockSize;
 527               	.LM56:
 528 021a 8091 0000 		lds r24,xFreeBytesRemaining
 529 021e 9091 0000 		lds r25,xFreeBytesRemaining+1
 530 0222 2A81      		ldd r18,Y+2
 531 0224 3B81      		ldd r19,Y+3
 532 0226 820F      		add r24,r18
 533 0228 931F      		adc r25,r19
 534 022a 9093 0000 		sts xFreeBytesRemaining+1,r25
 535 022e 8093 0000 		sts xFreeBytesRemaining,r24
 283:../freeRTOS750/MemMang/heap_4.c **** 					prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 537               	.LM57:
 538 0232 CE01      		movw r24,r28
 539 0234 0E94 0000 		call prvInsertBlockIntoFreeList
 540               	/* epilogue start */
 289:../freeRTOS750/MemMang/heap_4.c **** }
 542               	.LM58:
 543 0238 DF91      		pop r29
 544 023a CF91      		pop r28
 285:../freeRTOS750/MemMang/heap_4.c **** 				xTaskResumeAll();
 546               	.LM59:
 547 023c 0C94 0000 		jmp xTaskResumeAll
 548               	.L22:
 549               	/* epilogue start */
 289:../freeRTOS750/MemMang/heap_4.c **** }
 551               	.LM60:
 552 0240 DF91      		pop r29
 553 0242 CF91      		pop r28
 554 0244 0895      		ret
 556               	.Lscope3:
 558               		.stabd	78,0,0
 560               	.global	xPortGetFreeHeapSize
 562               	xPortGetFreeHeapSize:
 563               		.stabd	46,0,0
 293:../freeRTOS750/MemMang/heap_4.c **** {
 565               	.LM61:
 566               	.LFBB4:
 567               	/* prologue: function */
 568               	/* frame size = 0 */
 569               	/* stack size = 0 */
 570               	.L__stack_usage = 0
 295:../freeRTOS750/MemMang/heap_4.c **** }
 572               	.LM62:
 573 0246 8091 0000 		lds r24,xFreeBytesRemaining
 574 024a 9091 0000 		lds r25,xFreeBytesRemaining+1
 575 024e 0895      		ret
 577               	.Lscope4:
 579               		.stabd	78,0,0
 581               	.global	vPortInitialiseBlocks
 583               	vPortInitialiseBlocks:
 584               		.stabd	46,0,0
 299:../freeRTOS750/MemMang/heap_4.c **** {
 586               	.LM63:
 587               	.LFBB5:
 588               	/* prologue: function */
 589               	/* frame size = 0 */
 590               	/* stack size = 0 */
 591               	.L__stack_usage = 0
 592 0250 0895      		ret
 594               	.Lscope5:
 596               		.stabd	78,0,0
 597               		.local	pxEnd
 598               		.comm	pxEnd,2,1
 599               		.local	xBlockAllocatedBit
 600               		.comm	xBlockAllocatedBit,2,1
 601               		.data
 604               	xFreeBytesRemaining:
 605 0000 DB05      		.word	1499
 606               		.local	xStart
 607               		.comm	xStart,4,1
 608               		.local	ucHeap
 609               		.comm	ucHeap,1500,1
 617               		.text
 619               	.Letext0:
 620               		.ident	"GCC: (GNU) 4.7.2"
 621               	.global __do_copy_data
 622               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 heap_4.c
     /tmp/ccHsQ0BV.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccHsQ0BV.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccHsQ0BV.s:4      *ABS*:0000003f __SREG__
     /tmp/ccHsQ0BV.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccHsQ0BV.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccHsQ0BV.s:123    .text:00000000 prvInsertBlockIntoFreeList
     /tmp/ccHsQ0BV.s:600    .bss:00000004 xStart
                             .bss:00000000 pxEnd
     /tmp/ccHsQ0BV.s:237    .text:00000088 pvPortMalloc
     /tmp/ccHsQ0BV.s:607    .bss:00000008 ucHeap
     /tmp/ccHsQ0BV.s:604    .data:00000000 xFreeBytesRemaining
     /tmp/ccHsQ0BV.s:598    .bss:00000002 xBlockAllocatedBit
     /tmp/ccHsQ0BV.s:481    .text:000001e0 vPortFree
     /tmp/ccHsQ0BV.s:562    .text:00000246 xPortGetFreeHeapSize
     /tmp/ccHsQ0BV.s:583    .text:00000250 vPortInitialiseBlocks

UNDEFINED SYMBOLS
vTaskSuspendAll
xTaskResumeAll
__do_copy_data
__do_clear_bss
