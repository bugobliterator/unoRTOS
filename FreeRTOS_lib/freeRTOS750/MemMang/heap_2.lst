   1               		.file	"heap_2.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 122               	.global	pvPortMalloc
 124               	pvPortMalloc:
 125               		.stabd	46,0,0
   1:../freeRTOS750/MemMang/heap_2.c **** /*
   2:../freeRTOS750/MemMang/heap_2.c ****     FreeRTOS V7.5.0 - Copyright (C) 2013 Real Time Engineers Ltd.
   3:../freeRTOS750/MemMang/heap_2.c **** 
   4:../freeRTOS750/MemMang/heap_2.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   5:../freeRTOS750/MemMang/heap_2.c **** 
   6:../freeRTOS750/MemMang/heap_2.c ****     ***************************************************************************
   7:../freeRTOS750/MemMang/heap_2.c ****      *                                                                       *
   8:../freeRTOS750/MemMang/heap_2.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
   9:../freeRTOS750/MemMang/heap_2.c ****      *    robust, strictly quality controlled, supported, and cross          *
  10:../freeRTOS750/MemMang/heap_2.c ****      *    platform software that has become a de facto standard.             *
  11:../freeRTOS750/MemMang/heap_2.c ****      *                                                                       *
  12:../freeRTOS750/MemMang/heap_2.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  13:../freeRTOS750/MemMang/heap_2.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  14:../freeRTOS750/MemMang/heap_2.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  15:../freeRTOS750/MemMang/heap_2.c ****      *                                                                       *
  16:../freeRTOS750/MemMang/heap_2.c ****      *    Thank you!                                                         *
  17:../freeRTOS750/MemMang/heap_2.c ****      *                                                                       *
  18:../freeRTOS750/MemMang/heap_2.c ****     ***************************************************************************
  19:../freeRTOS750/MemMang/heap_2.c **** 
  20:../freeRTOS750/MemMang/heap_2.c ****     This file is part of the FreeRTOS distribution.
  21:../freeRTOS750/MemMang/heap_2.c **** 
  22:../freeRTOS750/MemMang/heap_2.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  23:../freeRTOS750/MemMang/heap_2.c ****     the terms of the GNU General Public License (version 2) as published by the
  24:../freeRTOS750/MemMang/heap_2.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  25:../freeRTOS750/MemMang/heap_2.c **** 
  26:../freeRTOS750/MemMang/heap_2.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  27:../freeRTOS750/MemMang/heap_2.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  28:../freeRTOS750/MemMang/heap_2.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  29:../freeRTOS750/MemMang/heap_2.c ****     >>! kernel.
  30:../freeRTOS750/MemMang/heap_2.c **** 
  31:../freeRTOS750/MemMang/heap_2.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  32:../freeRTOS750/MemMang/heap_2.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  33:../freeRTOS750/MemMang/heap_2.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  34:../freeRTOS750/MemMang/heap_2.c ****     link: http://www.freertos.org/a00114.html
  35:../freeRTOS750/MemMang/heap_2.c **** 
  36:../freeRTOS750/MemMang/heap_2.c ****     1 tab == 4 spaces!
  37:../freeRTOS750/MemMang/heap_2.c **** 
  38:../freeRTOS750/MemMang/heap_2.c ****     ***************************************************************************
  39:../freeRTOS750/MemMang/heap_2.c ****      *                                                                       *
  40:../freeRTOS750/MemMang/heap_2.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  41:../freeRTOS750/MemMang/heap_2.c ****      *    not run, what could be wrong?"                                     *
  42:../freeRTOS750/MemMang/heap_2.c ****      *                                                                       *
  43:../freeRTOS750/MemMang/heap_2.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  44:../freeRTOS750/MemMang/heap_2.c ****      *                                                                       *
  45:../freeRTOS750/MemMang/heap_2.c ****     ***************************************************************************
  46:../freeRTOS750/MemMang/heap_2.c **** 
  47:../freeRTOS750/MemMang/heap_2.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  48:../freeRTOS750/MemMang/heap_2.c ****     license and Real Time Engineers Ltd. contact details.
  49:../freeRTOS750/MemMang/heap_2.c **** 
  50:../freeRTOS750/MemMang/heap_2.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  51:../freeRTOS750/MemMang/heap_2.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  52:../freeRTOS750/MemMang/heap_2.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  53:../freeRTOS750/MemMang/heap_2.c **** 
  54:../freeRTOS750/MemMang/heap_2.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  55:../freeRTOS750/MemMang/heap_2.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  56:../freeRTOS750/MemMang/heap_2.c ****     licenses offer ticketed support, indemnification and middleware.
  57:../freeRTOS750/MemMang/heap_2.c **** 
  58:../freeRTOS750/MemMang/heap_2.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  59:../freeRTOS750/MemMang/heap_2.c ****     engineered and independently SIL3 certified version for use in safety and
  60:../freeRTOS750/MemMang/heap_2.c ****     mission critical applications that require provable dependability.
  61:../freeRTOS750/MemMang/heap_2.c **** 
  62:../freeRTOS750/MemMang/heap_2.c ****     1 tab == 4 spaces!
  63:../freeRTOS750/MemMang/heap_2.c **** */
  64:../freeRTOS750/MemMang/heap_2.c **** 
  65:../freeRTOS750/MemMang/heap_2.c **** /*
  66:../freeRTOS750/MemMang/heap_2.c ****  * A sample implementation of pvPortMalloc() and vPortFree() that permits
  67:../freeRTOS750/MemMang/heap_2.c ****  * allocated blocks to be freed, but does not combine adjacent free blocks
  68:../freeRTOS750/MemMang/heap_2.c ****  * into a single larger block (and so will fragment memory).  See heap_4.c for
  69:../freeRTOS750/MemMang/heap_2.c ****  * an equivalent that does combine adjacent blocks into single larger blocks.
  70:../freeRTOS750/MemMang/heap_2.c ****  *
  71:../freeRTOS750/MemMang/heap_2.c ****  * See heap_1.c, heap_3.c and heap_4.c for alternative implementations, and the
  72:../freeRTOS750/MemMang/heap_2.c ****  * memory management pages of http://www.FreeRTOS.org for more information.
  73:../freeRTOS750/MemMang/heap_2.c ****  */
  74:../freeRTOS750/MemMang/heap_2.c **** #include <stdlib.h>
  75:../freeRTOS750/MemMang/heap_2.c **** 
  76:../freeRTOS750/MemMang/heap_2.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  77:../freeRTOS750/MemMang/heap_2.c **** all the API functions to use the MPU wrappers.  That should only be done when
  78:../freeRTOS750/MemMang/heap_2.c **** task.h is included from an application file. */
  79:../freeRTOS750/MemMang/heap_2.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  80:../freeRTOS750/MemMang/heap_2.c **** 
  81:../freeRTOS750/MemMang/heap_2.c **** #include "FreeRTOS.h"
  82:../freeRTOS750/MemMang/heap_2.c **** #include "task.h"
  83:../freeRTOS750/MemMang/heap_2.c **** 
  84:../freeRTOS750/MemMang/heap_2.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  85:../freeRTOS750/MemMang/heap_2.c **** 
  86:../freeRTOS750/MemMang/heap_2.c **** /* A few bytes might be lost to byte aligning the heap start address. */
  87:../freeRTOS750/MemMang/heap_2.c **** #define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
  88:../freeRTOS750/MemMang/heap_2.c **** 
  89:../freeRTOS750/MemMang/heap_2.c **** /* 
  90:../freeRTOS750/MemMang/heap_2.c ****  * Initialises the heap structures before their first use.
  91:../freeRTOS750/MemMang/heap_2.c ****  */
  92:../freeRTOS750/MemMang/heap_2.c **** static void prvHeapInit( void );
  93:../freeRTOS750/MemMang/heap_2.c **** 
  94:../freeRTOS750/MemMang/heap_2.c **** /* Allocate the memory for the heap. */
  95:../freeRTOS750/MemMang/heap_2.c **** #if ( defined(portEXT_RAM) && !defined(portEXT_RAMFS) )
  96:../freeRTOS750/MemMang/heap_2.c **** static unsigned char ucHeap[ configTOTAL_HEAP_SIZE ]  __attribute__((section(".ext_ram_heap"))); //
  97:../freeRTOS750/MemMang/heap_2.c **** #else
  98:../freeRTOS750/MemMang/heap_2.c **** static unsigned char ucHeap[ configTOTAL_HEAP_SIZE ];
  99:../freeRTOS750/MemMang/heap_2.c **** #endif
 100:../freeRTOS750/MemMang/heap_2.c **** 
 101:../freeRTOS750/MemMang/heap_2.c **** /* Define the linked list structure.  This is used to link free blocks in order
 102:../freeRTOS750/MemMang/heap_2.c **** of their size. */
 103:../freeRTOS750/MemMang/heap_2.c **** typedef struct A_BLOCK_LINK
 104:../freeRTOS750/MemMang/heap_2.c **** {
 105:../freeRTOS750/MemMang/heap_2.c **** 	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
 106:../freeRTOS750/MemMang/heap_2.c **** 	size_t xBlockSize;						/*<< The size of the free block. */
 107:../freeRTOS750/MemMang/heap_2.c **** } xBlockLink;
 108:../freeRTOS750/MemMang/heap_2.c **** 
 109:../freeRTOS750/MemMang/heap_2.c **** 
 110:../freeRTOS750/MemMang/heap_2.c **** static const unsigned short heapSTRUCT_SIZE	= ( ( sizeof ( xBlockLink ) + ( portBYTE_ALIGNMENT - 1 
 111:../freeRTOS750/MemMang/heap_2.c **** #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )
 112:../freeRTOS750/MemMang/heap_2.c **** 
 113:../freeRTOS750/MemMang/heap_2.c **** /* Create a couple of list links to mark the start and end of the list. */
 114:../freeRTOS750/MemMang/heap_2.c **** static xBlockLink xStart, xEnd;
 115:../freeRTOS750/MemMang/heap_2.c **** 
 116:../freeRTOS750/MemMang/heap_2.c **** /* Keeps track of the number of free bytes remaining, but says nothing about
 117:../freeRTOS750/MemMang/heap_2.c **** fragmentation. */
 118:../freeRTOS750/MemMang/heap_2.c **** static size_t xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;
 119:../freeRTOS750/MemMang/heap_2.c **** 
 120:../freeRTOS750/MemMang/heap_2.c **** /* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */
 121:../freeRTOS750/MemMang/heap_2.c **** 
 122:../freeRTOS750/MemMang/heap_2.c **** /*
 123:../freeRTOS750/MemMang/heap_2.c ****  * Insert a block into the list of free blocks - which is ordered by size of
 124:../freeRTOS750/MemMang/heap_2.c ****  * the block.  Small blocks at the start of the list and large blocks at the end
 125:../freeRTOS750/MemMang/heap_2.c ****  * of the list.
 126:../freeRTOS750/MemMang/heap_2.c ****  */
 127:../freeRTOS750/MemMang/heap_2.c **** #define prvInsertBlockIntoFreeList( pxBlockToInsert )								\
 128:../freeRTOS750/MemMang/heap_2.c **** {																					\
 129:../freeRTOS750/MemMang/heap_2.c **** xBlockLink *pxIterator;																\
 130:../freeRTOS750/MemMang/heap_2.c **** size_t xBlockSize;																	\
 131:../freeRTOS750/MemMang/heap_2.c **** 																					\
 132:../freeRTOS750/MemMang/heap_2.c **** 	xBlockSize = pxBlockToInsert->xBlockSize;										\
 133:../freeRTOS750/MemMang/heap_2.c **** 																					\
 134:../freeRTOS750/MemMang/heap_2.c **** 	/* Iterate through the list until a block is found that has a larger size */	\
 135:../freeRTOS750/MemMang/heap_2.c **** 	/* than the block we are inserting. */											\
 136:../freeRTOS750/MemMang/heap_2.c **** 	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock->xBlockSize < xBlockSize; pxIterator = pxIt
 137:../freeRTOS750/MemMang/heap_2.c **** 	{																				\
 138:../freeRTOS750/MemMang/heap_2.c **** 		/* There is nothing to do here - just iterate to the correct position. */	\
 139:../freeRTOS750/MemMang/heap_2.c **** 	}																				\
 140:../freeRTOS750/MemMang/heap_2.c **** 																					\
 141:../freeRTOS750/MemMang/heap_2.c **** 	/* Update the list to include the block being inserted in the correct */		\
 142:../freeRTOS750/MemMang/heap_2.c **** 	/* position. */																	\
 143:../freeRTOS750/MemMang/heap_2.c **** 	pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;					\
 144:../freeRTOS750/MemMang/heap_2.c **** 	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
 145:../freeRTOS750/MemMang/heap_2.c **** }
 146:../freeRTOS750/MemMang/heap_2.c **** /*-----------------------------------------------------------*/
 147:../freeRTOS750/MemMang/heap_2.c **** 
 148:../freeRTOS750/MemMang/heap_2.c **** void *pvPortMalloc( size_t xWantedSize )
 149:../freeRTOS750/MemMang/heap_2.c **** {
 127               	.LM0:
 128               	.LFBB1:
 129 0000 0F93      		push r16
 130 0002 1F93      		push r17
 131 0004 CF93      		push r28
 132 0006 DF93      		push r29
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 4 */
 136               	.L__stack_usage = 4
 137 0008 EC01      		movw r28,r24
 150:../freeRTOS750/MemMang/heap_2.c **** xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
 151:../freeRTOS750/MemMang/heap_2.c **** static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
 152:../freeRTOS750/MemMang/heap_2.c **** void *pvReturn = NULL;
 153:../freeRTOS750/MemMang/heap_2.c **** 
 154:../freeRTOS750/MemMang/heap_2.c **** 	vTaskSuspendAll();
 139               	.LM1:
 140 000a 0E94 0000 		call vTaskSuspendAll
 155:../freeRTOS750/MemMang/heap_2.c **** 	{
 156:../freeRTOS750/MemMang/heap_2.c **** 		/* If this is the first call to malloc then the heap will require
 157:../freeRTOS750/MemMang/heap_2.c **** 		initialisation to setup the list of free blocks. */
 158:../freeRTOS750/MemMang/heap_2.c **** 		if( xHeapHasBeenInitialised == pdFALSE )
 142               	.LM2:
 143 000e 8091 0000 		lds r24,xHeapHasBeenInitialised.1673
 144 0012 8111      		cpse r24,__zero_reg__
 145 0014 00C0      		rjmp .L2
 146               	.LBB5:
 147               	.LBB6:
 159:../freeRTOS750/MemMang/heap_2.c **** 		{
 160:../freeRTOS750/MemMang/heap_2.c **** 			prvHeapInit();
 161:../freeRTOS750/MemMang/heap_2.c **** 			xHeapHasBeenInitialised = pdTRUE;
 162:../freeRTOS750/MemMang/heap_2.c **** 		}
 163:../freeRTOS750/MemMang/heap_2.c **** 
 164:../freeRTOS750/MemMang/heap_2.c **** 		/* The wanted size is increased so it can contain a xBlockLink
 165:../freeRTOS750/MemMang/heap_2.c **** 		structure in addition to the requested amount of bytes. */
 166:../freeRTOS750/MemMang/heap_2.c **** 		if( xWantedSize > 0 )
 167:../freeRTOS750/MemMang/heap_2.c **** 		{
 168:../freeRTOS750/MemMang/heap_2.c **** 			xWantedSize += heapSTRUCT_SIZE;
 169:../freeRTOS750/MemMang/heap_2.c **** 
 170:../freeRTOS750/MemMang/heap_2.c **** 			/* Ensure that blocks are always aligned to the required number of bytes. */
 171:../freeRTOS750/MemMang/heap_2.c **** 			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
 172:../freeRTOS750/MemMang/heap_2.c **** 			{
 173:../freeRTOS750/MemMang/heap_2.c **** 				/* Byte alignment required. */
 174:../freeRTOS750/MemMang/heap_2.c **** 				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 175:../freeRTOS750/MemMang/heap_2.c **** 			}
 176:../freeRTOS750/MemMang/heap_2.c **** 		}
 177:../freeRTOS750/MemMang/heap_2.c **** 
 178:../freeRTOS750/MemMang/heap_2.c **** 		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 179:../freeRTOS750/MemMang/heap_2.c **** 		{
 180:../freeRTOS750/MemMang/heap_2.c **** 			/* Blocks are stored in byte order - traverse the list from the start
 181:../freeRTOS750/MemMang/heap_2.c **** 			(smallest) block until one of adequate size is found. */
 182:../freeRTOS750/MemMang/heap_2.c **** 			pxPreviousBlock = &xStart;
 183:../freeRTOS750/MemMang/heap_2.c **** 			pxBlock = xStart.pxNextFreeBlock;
 184:../freeRTOS750/MemMang/heap_2.c **** 			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 185:../freeRTOS750/MemMang/heap_2.c **** 			{
 186:../freeRTOS750/MemMang/heap_2.c **** 				pxPreviousBlock = pxBlock;
 187:../freeRTOS750/MemMang/heap_2.c **** 				pxBlock = pxBlock->pxNextFreeBlock;
 188:../freeRTOS750/MemMang/heap_2.c **** 			}
 189:../freeRTOS750/MemMang/heap_2.c **** 
 190:../freeRTOS750/MemMang/heap_2.c **** 			/* If we found the end marker then a block of adequate size was not found. */
 191:../freeRTOS750/MemMang/heap_2.c **** 			if( pxBlock != &xEnd )
 192:../freeRTOS750/MemMang/heap_2.c **** 			{
 193:../freeRTOS750/MemMang/heap_2.c **** 				/* Return the memory space - jumping over the xBlockLink structure
 194:../freeRTOS750/MemMang/heap_2.c **** 				at its start. */
 195:../freeRTOS750/MemMang/heap_2.c **** 				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_S
 196:../freeRTOS750/MemMang/heap_2.c **** 
 197:../freeRTOS750/MemMang/heap_2.c **** 				/* This block is being returned for use so must be taken out of the
 198:../freeRTOS750/MemMang/heap_2.c **** 				list of free blocks. */
 199:../freeRTOS750/MemMang/heap_2.c **** 				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 200:../freeRTOS750/MemMang/heap_2.c **** 
 201:../freeRTOS750/MemMang/heap_2.c **** 				/* If the block is larger than required it can be split into two. */
 202:../freeRTOS750/MemMang/heap_2.c **** 				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 203:../freeRTOS750/MemMang/heap_2.c **** 				{
 204:../freeRTOS750/MemMang/heap_2.c **** 					/* This block is to be split into two.  Create a new block
 205:../freeRTOS750/MemMang/heap_2.c **** 					following the number of bytes requested. The void cast is
 206:../freeRTOS750/MemMang/heap_2.c **** 					used to prevent byte alignment warnings from the compiler. */
 207:../freeRTOS750/MemMang/heap_2.c **** 					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
 208:../freeRTOS750/MemMang/heap_2.c **** 
 209:../freeRTOS750/MemMang/heap_2.c **** 					/* Calculate the sizes of two blocks split from the single
 210:../freeRTOS750/MemMang/heap_2.c **** 					block. */
 211:../freeRTOS750/MemMang/heap_2.c **** 					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 212:../freeRTOS750/MemMang/heap_2.c **** 					pxBlock->xBlockSize = xWantedSize;
 213:../freeRTOS750/MemMang/heap_2.c **** 
 214:../freeRTOS750/MemMang/heap_2.c **** 					/* Insert the new block into the list of free blocks. */
 215:../freeRTOS750/MemMang/heap_2.c **** 					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 216:../freeRTOS750/MemMang/heap_2.c **** 				}
 217:../freeRTOS750/MemMang/heap_2.c **** 
 218:../freeRTOS750/MemMang/heap_2.c **** 				xFreeBytesRemaining -= pxBlock->xBlockSize;
 219:../freeRTOS750/MemMang/heap_2.c **** 			}
 220:../freeRTOS750/MemMang/heap_2.c **** 		}
 221:../freeRTOS750/MemMang/heap_2.c **** 	}
 222:../freeRTOS750/MemMang/heap_2.c **** 	xTaskResumeAll();
 223:../freeRTOS750/MemMang/heap_2.c **** 
 224:../freeRTOS750/MemMang/heap_2.c **** 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
 225:../freeRTOS750/MemMang/heap_2.c **** 	{
 226:../freeRTOS750/MemMang/heap_2.c **** 		if( pvReturn == NULL )
 227:../freeRTOS750/MemMang/heap_2.c **** 		{
 228:../freeRTOS750/MemMang/heap_2.c **** 			extern void vApplicationMallocFailedHook( void );
 229:../freeRTOS750/MemMang/heap_2.c **** 			vApplicationMallocFailedHook();
 230:../freeRTOS750/MemMang/heap_2.c **** 		}
 231:../freeRTOS750/MemMang/heap_2.c **** 	}
 232:../freeRTOS750/MemMang/heap_2.c **** 	#endif
 233:../freeRTOS750/MemMang/heap_2.c **** 
 234:../freeRTOS750/MemMang/heap_2.c **** 	return pvReturn;
 235:../freeRTOS750/MemMang/heap_2.c **** }
 236:../freeRTOS750/MemMang/heap_2.c **** /*-----------------------------------------------------------*/
 237:../freeRTOS750/MemMang/heap_2.c **** 
 238:../freeRTOS750/MemMang/heap_2.c **** void vPortFree( void *pv )
 239:../freeRTOS750/MemMang/heap_2.c **** {
 240:../freeRTOS750/MemMang/heap_2.c **** unsigned char *puc = ( unsigned char * ) pv;
 241:../freeRTOS750/MemMang/heap_2.c **** xBlockLink *pxLink;
 242:../freeRTOS750/MemMang/heap_2.c **** 
 243:../freeRTOS750/MemMang/heap_2.c **** 	if( pv != NULL )
 244:../freeRTOS750/MemMang/heap_2.c **** 	{
 245:../freeRTOS750/MemMang/heap_2.c **** 		/* The memory being freed will have an xBlockLink structure immediately
 246:../freeRTOS750/MemMang/heap_2.c **** 		before it. */
 247:../freeRTOS750/MemMang/heap_2.c **** 		puc -= heapSTRUCT_SIZE;
 248:../freeRTOS750/MemMang/heap_2.c **** 
 249:../freeRTOS750/MemMang/heap_2.c **** 		/* This unexpected casting is to keep some compilers from issuing 
 250:../freeRTOS750/MemMang/heap_2.c **** 		byte alignment warnings. */
 251:../freeRTOS750/MemMang/heap_2.c **** 		pxLink = ( void * ) puc;
 252:../freeRTOS750/MemMang/heap_2.c **** 
 253:../freeRTOS750/MemMang/heap_2.c **** 		vTaskSuspendAll();
 254:../freeRTOS750/MemMang/heap_2.c **** 		{
 255:../freeRTOS750/MemMang/heap_2.c **** 			/* Add this block to the list of free blocks. */
 256:../freeRTOS750/MemMang/heap_2.c **** 			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 257:../freeRTOS750/MemMang/heap_2.c **** 			xFreeBytesRemaining += pxLink->xBlockSize;
 258:../freeRTOS750/MemMang/heap_2.c **** 		}
 259:../freeRTOS750/MemMang/heap_2.c **** 		xTaskResumeAll();
 260:../freeRTOS750/MemMang/heap_2.c **** 	}
 261:../freeRTOS750/MemMang/heap_2.c **** }
 262:../freeRTOS750/MemMang/heap_2.c **** /*-----------------------------------------------------------*/
 263:../freeRTOS750/MemMang/heap_2.c **** 
 264:../freeRTOS750/MemMang/heap_2.c **** size_t xPortGetFreeHeapSize( void )
 265:../freeRTOS750/MemMang/heap_2.c **** {
 266:../freeRTOS750/MemMang/heap_2.c **** 	return xFreeBytesRemaining;
 267:../freeRTOS750/MemMang/heap_2.c **** }
 268:../freeRTOS750/MemMang/heap_2.c **** /*-----------------------------------------------------------*/
 269:../freeRTOS750/MemMang/heap_2.c **** 
 270:../freeRTOS750/MemMang/heap_2.c **** void vPortInitialiseBlocks( void )
 271:../freeRTOS750/MemMang/heap_2.c **** {
 272:../freeRTOS750/MemMang/heap_2.c **** 	/* This just exists to keep the linker quiet. */
 273:../freeRTOS750/MemMang/heap_2.c **** }
 274:../freeRTOS750/MemMang/heap_2.c **** /*-----------------------------------------------------------*/
 275:../freeRTOS750/MemMang/heap_2.c **** 
 276:../freeRTOS750/MemMang/heap_2.c **** static void prvHeapInit( void )
 277:../freeRTOS750/MemMang/heap_2.c **** {
 278:../freeRTOS750/MemMang/heap_2.c **** xBlockLink *pxFirstFreeBlock;
 279:../freeRTOS750/MemMang/heap_2.c **** unsigned char *pucAlignedHeap;
 280:../freeRTOS750/MemMang/heap_2.c **** 
 281:../freeRTOS750/MemMang/heap_2.c **** 	/* Ensure the heap starts on a correctly aligned boundary. */
 282:../freeRTOS750/MemMang/heap_2.c **** 	pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] )
 283:../freeRTOS750/MemMang/heap_2.c **** 
 284:../freeRTOS750/MemMang/heap_2.c **** 	/* xStart is used to hold a pointer to the first item in the list of free
 285:../freeRTOS750/MemMang/heap_2.c **** 	blocks.  The void cast is used to prevent compiler warnings. */
 286:../freeRTOS750/MemMang/heap_2.c **** 	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 149               	.LM3:
 150 0016 80E0      		ldi r24,lo8(ucHeap+1)
 151 0018 90E0      		ldi r25,hi8(ucHeap+1)
 152 001a 9093 0000 		sts xStart+1,r25
 153 001e 8093 0000 		sts xStart,r24
 287:../freeRTOS750/MemMang/heap_2.c **** 	xStart.xBlockSize = ( size_t ) 0;
 155               	.LM4:
 156 0022 1092 0000 		sts xStart+2+1,__zero_reg__
 157 0026 1092 0000 		sts xStart+2,__zero_reg__
 288:../freeRTOS750/MemMang/heap_2.c **** 
 289:../freeRTOS750/MemMang/heap_2.c **** 	/* xEnd is used to mark the end of the list of free blocks. */
 290:../freeRTOS750/MemMang/heap_2.c **** 	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 159               	.LM5:
 160 002a 8BED      		ldi r24,lo8(-37)
 161 002c 95E0      		ldi r25,lo8(5)
 162 002e 9093 0000 		sts xEnd+2+1,r25
 163 0032 8093 0000 		sts xEnd+2,r24
 291:../freeRTOS750/MemMang/heap_2.c **** 	xEnd.pxNextFreeBlock = NULL;
 165               	.LM6:
 166 0036 1092 0000 		sts xEnd+1,__zero_reg__
 167 003a 1092 0000 		sts xEnd,__zero_reg__
 292:../freeRTOS750/MemMang/heap_2.c **** 
 293:../freeRTOS750/MemMang/heap_2.c **** 	/* To start with there is a single free block that is sized to take up the
 294:../freeRTOS750/MemMang/heap_2.c **** 	entire heap space. */
 295:../freeRTOS750/MemMang/heap_2.c **** 	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 296:../freeRTOS750/MemMang/heap_2.c **** 	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 169               	.LM7:
 170 003e 9093 0000 		sts ucHeap+3+1,r25
 171 0042 8093 0000 		sts ucHeap+3,r24
 297:../freeRTOS750/MemMang/heap_2.c **** 	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 173               	.LM8:
 174 0046 80E0      		ldi r24,lo8(xEnd)
 175 0048 90E0      		ldi r25,hi8(xEnd)
 176 004a 9093 0000 		sts ucHeap+1+1,r25
 177 004e 8093 0000 		sts ucHeap+1,r24
 178               	.LBE6:
 179               	.LBE5:
 161:../freeRTOS750/MemMang/heap_2.c **** 			xHeapHasBeenInitialised = pdTRUE;
 181               	.LM9:
 182 0052 81E0      		ldi r24,lo8(1)
 183 0054 8093 0000 		sts xHeapHasBeenInitialised.1673,r24
 184               	.L2:
 166:../freeRTOS750/MemMang/heap_2.c **** 		if( xWantedSize > 0 )
 186               	.LM10:
 187 0058 2097      		sbiw r28,0
 188 005a 01F0      		breq .L3
 168:../freeRTOS750/MemMang/heap_2.c **** 			xWantedSize += heapSTRUCT_SIZE;
 190               	.LM11:
 191 005c 2496      		adiw r28,4
 192               	.L3:
 178:../freeRTOS750/MemMang/heap_2.c **** 		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 194               	.LM12:
 195 005e CE01      		movw r24,r28
 196 0060 0197      		sbiw r24,1
 197 0062 8A3D      		cpi r24,-38
 198 0064 9540      		sbci r25,5
 199 0066 00F0      		brlo .+2
 200 0068 00C0      		rjmp .L11
 183:../freeRTOS750/MemMang/heap_2.c **** 			pxBlock = xStart.pxNextFreeBlock;
 202               	.LM13:
 203 006a E091 0000 		lds r30,xStart
 204 006e F091 0000 		lds r31,xStart+1
 182:../freeRTOS750/MemMang/heap_2.c **** 			pxPreviousBlock = &xStart;
 206               	.LM14:
 207 0072 A0E0      		ldi r26,lo8(xStart)
 208 0074 B0E0      		ldi r27,hi8(xStart)
 184:../freeRTOS750/MemMang/heap_2.c **** 			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 210               	.LM15:
 211 0076 00C0      		rjmp .L7
 212               	.L12:
 213 0078 DF01      		movw r26,r30
 187:../freeRTOS750/MemMang/heap_2.c **** 				pxBlock = pxBlock->pxNextFreeBlock;
 215               	.LM16:
 216 007a F901      		movw r30,r18
 217               	.L7:
 184:../freeRTOS750/MemMang/heap_2.c **** 			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 219               	.LM17:
 220 007c 8281      		ldd r24,Z+2
 221 007e 9381      		ldd r25,Z+3
 222 0080 8C17      		cp r24,r28
 223 0082 9D07      		cpc r25,r29
 224 0084 00F0      		brlo .L5
 225               	.L8:
 191:../freeRTOS750/MemMang/heap_2.c **** 			if( pxBlock != &xEnd )
 227               	.LM18:
 228 0086 20E0      		ldi r18,hi8(xEnd)
 229 0088 E030      		cpi r30,lo8(xEnd)
 230 008a F207      		cpc r31,r18
 231 008c 01F4      		brne .L6
 232 008e 00C0      		rjmp .L11
 233               	.L5:
 184:../freeRTOS750/MemMang/heap_2.c **** 			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 235               	.LM19:
 236 0090 2081      		ld r18,Z
 237 0092 3181      		ldd r19,Z+1
 238 0094 2115      		cp r18,__zero_reg__
 239 0096 3105      		cpc r19,__zero_reg__
 240 0098 01F4      		brne .L12
 241 009a 00C0      		rjmp .L8
 242               	.L6:
 195:../freeRTOS750/MemMang/heap_2.c **** 				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_S
 244               	.LM20:
 245 009c 0D91      		ld r16,X+
 246 009e 1C91      		ld r17,X
 247 00a0 1197      		sbiw r26,1
 248 00a2 0C5F      		subi r16,-4
 249 00a4 1F4F      		sbci r17,-1
 199:../freeRTOS750/MemMang/heap_2.c **** 				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 251               	.LM21:
 252 00a6 2081      		ld r18,Z
 253 00a8 3181      		ldd r19,Z+1
 254 00aa 2D93      		st X+,r18
 255 00ac 3C93      		st X,r19
 202:../freeRTOS750/MemMang/heap_2.c **** 				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 257               	.LM22:
 258 00ae 8C1B      		sub r24,r28
 259 00b0 9D0B      		sbc r25,r29
 260 00b2 8930      		cpi r24,9
 261 00b4 9105      		cpc r25,__zero_reg__
 262 00b6 00F0      		brlo .L9
 207:../freeRTOS750/MemMang/heap_2.c **** 					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
 264               	.LM23:
 265 00b8 DF01      		movw r26,r30
 266 00ba AC0F      		add r26,r28
 267 00bc BD1F      		adc r27,r29
 211:../freeRTOS750/MemMang/heap_2.c **** 					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 269               	.LM24:
 270 00be 1396      		adiw r26,2+1
 271 00c0 9C93      		st X,r25
 272 00c2 8E93      		st -X,r24
 273 00c4 1297      		sbiw r26,2
 212:../freeRTOS750/MemMang/heap_2.c **** 					pxBlock->xBlockSize = xWantedSize;
 275               	.LM25:
 276 00c6 D383      		std Z+3,r29
 277 00c8 C283      		std Z+2,r28
 278               	.LBB7:
 215:../freeRTOS750/MemMang/heap_2.c **** 					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 280               	.LM26:
 281 00ca 1296      		adiw r26,2
 282 00cc 2D91      		ld r18,X+
 283 00ce 3C91      		ld r19,X
 284 00d0 1397      		sbiw r26,2+1
 285 00d2 60E0      		ldi r22,lo8(xStart)
 286 00d4 70E0      		ldi r23,hi8(xStart)
 287 00d6 00C0      		rjmp .L10
 288               	.L13:
 289 00d8 BC01      		movw r22,r24
 290               	.L10:
 215:../freeRTOS750/MemMang/heap_2.c **** 					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 292               	.LM27:
 293 00da EB01      		movw r28,r22
 294 00dc 8881      		ld r24,Y
 295 00de 9981      		ldd r25,Y+1
 296 00e0 EC01      		movw r28,r24
 297 00e2 4A81      		ldd r20,Y+2
 298 00e4 5B81      		ldd r21,Y+3
 299 00e6 4217      		cp r20,r18
 300 00e8 5307      		cpc r21,r19
 301 00ea 00F0      		brlo .L13
 215:../freeRTOS750/MemMang/heap_2.c **** 					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 303               	.LM28:
 304 00ec 1196      		adiw r26,1
 305 00ee 9C93      		st X,r25
 306 00f0 8E93      		st -X,r24
 307 00f2 EB01      		movw r28,r22
 308 00f4 B983      		std Y+1,r27
 309 00f6 A883      		st Y,r26
 310               	.L9:
 311               	.LBE7:
 218:../freeRTOS750/MemMang/heap_2.c **** 				xFreeBytesRemaining -= pxBlock->xBlockSize;
 313               	.LM29:
 314 00f8 8091 0000 		lds r24,xFreeBytesRemaining
 315 00fc 9091 0000 		lds r25,xFreeBytesRemaining+1
 316 0100 2281      		ldd r18,Z+2
 317 0102 3381      		ldd r19,Z+3
 318 0104 821B      		sub r24,r18
 319 0106 930B      		sbc r25,r19
 320 0108 9093 0000 		sts xFreeBytesRemaining+1,r25
 321 010c 8093 0000 		sts xFreeBytesRemaining,r24
 322 0110 00C0      		rjmp .L4
 323               	.L11:
 152:../freeRTOS750/MemMang/heap_2.c **** void *pvReturn = NULL;
 325               	.LM30:
 326 0112 00E0      		ldi r16,0
 327 0114 10E0      		ldi r17,0
 328               	.L4:
 222:../freeRTOS750/MemMang/heap_2.c **** 	xTaskResumeAll();
 330               	.LM31:
 331 0116 0E94 0000 		call xTaskResumeAll
 235:../freeRTOS750/MemMang/heap_2.c **** }
 333               	.LM32:
 334 011a C801      		movw r24,r16
 335               	/* epilogue start */
 336 011c DF91      		pop r29
 337 011e CF91      		pop r28
 338 0120 1F91      		pop r17
 339 0122 0F91      		pop r16
 340 0124 0895      		ret
 350               	.Lscope1:
 352               		.stabd	78,0,0
 355               	.global	vPortFree
 357               	vPortFree:
 358               		.stabd	46,0,0
 239:../freeRTOS750/MemMang/heap_2.c **** {
 360               	.LM33:
 361               	.LFBB2:
 362 0126 0F93      		push r16
 363 0128 1F93      		push r17
 364 012a CF93      		push r28
 365 012c DF93      		push r29
 366               	/* prologue: function */
 367               	/* frame size = 0 */
 368               	/* stack size = 4 */
 369               	.L__stack_usage = 4
 370 012e EC01      		movw r28,r24
 243:../freeRTOS750/MemMang/heap_2.c **** 	if( pv != NULL )
 372               	.LM34:
 373 0130 0097      		sbiw r24,0
 374 0132 01F0      		breq .L17
 251:../freeRTOS750/MemMang/heap_2.c **** 		pxLink = ( void * ) puc;
 376               	.LM35:
 377 0134 8C01      		movw r16,r24
 378 0136 0450      		subi r16,4
 379 0138 1109      		sbc r17,__zero_reg__
 253:../freeRTOS750/MemMang/heap_2.c **** 		vTaskSuspendAll();
 381               	.LM36:
 382 013a 0E94 0000 		call vTaskSuspendAll
 383               	.LBB8:
 256:../freeRTOS750/MemMang/heap_2.c **** 			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 385               	.LM37:
 386 013e F801      		movw r30,r16
 387 0140 2281      		ldd r18,Z+2
 388 0142 3381      		ldd r19,Z+3
 389 0144 E0E0      		ldi r30,lo8(xStart)
 390 0146 F0E0      		ldi r31,hi8(xStart)
 391 0148 00C0      		rjmp .L19
 392               	.L20:
 393 014a FD01      		movw r30,r26
 394               	.L19:
 256:../freeRTOS750/MemMang/heap_2.c **** 			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 396               	.LM38:
 397 014c A081      		ld r26,Z
 398 014e B181      		ldd r27,Z+1
 399 0150 1296      		adiw r26,2
 400 0152 8D91      		ld r24,X+
 401 0154 9C91      		ld r25,X
 402 0156 1397      		sbiw r26,2+1
 403 0158 8217      		cp r24,r18
 404 015a 9307      		cpc r25,r19
 405 015c 00F0      		brlo .L20
 256:../freeRTOS750/MemMang/heap_2.c **** 			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 407               	.LM39:
 408 015e 2497      		sbiw r28,4
 409 0160 B983      		std Y+1,r27
 410 0162 A883      		st Y,r26
 411 0164 1183      		std Z+1,r17
 412 0166 0083      		st Z,r16
 413               	.LBE8:
 257:../freeRTOS750/MemMang/heap_2.c **** 			xFreeBytesRemaining += pxLink->xBlockSize;
 415               	.LM40:
 416 0168 8091 0000 		lds r24,xFreeBytesRemaining
 417 016c 9091 0000 		lds r25,xFreeBytesRemaining+1
 418 0170 820F      		add r24,r18
 419 0172 931F      		adc r25,r19
 420 0174 9093 0000 		sts xFreeBytesRemaining+1,r25
 421 0178 8093 0000 		sts xFreeBytesRemaining,r24
 422               	/* epilogue start */
 261:../freeRTOS750/MemMang/heap_2.c **** }
 424               	.LM41:
 425 017c DF91      		pop r29
 426 017e CF91      		pop r28
 427 0180 1F91      		pop r17
 428 0182 0F91      		pop r16
 259:../freeRTOS750/MemMang/heap_2.c **** 		xTaskResumeAll();
 430               	.LM42:
 431 0184 0C94 0000 		jmp xTaskResumeAll
 432               	.L17:
 433               	/* epilogue start */
 261:../freeRTOS750/MemMang/heap_2.c **** }
 435               	.LM43:
 436 0188 DF91      		pop r29
 437 018a CF91      		pop r28
 438 018c 1F91      		pop r17
 439 018e 0F91      		pop r16
 440 0190 0895      		ret
 448               	.Lscope2:
 450               		.stabd	78,0,0
 452               	.global	xPortGetFreeHeapSize
 454               	xPortGetFreeHeapSize:
 455               		.stabd	46,0,0
 265:../freeRTOS750/MemMang/heap_2.c **** {
 457               	.LM44:
 458               	.LFBB3:
 459               	/* prologue: function */
 460               	/* frame size = 0 */
 461               	/* stack size = 0 */
 462               	.L__stack_usage = 0
 267:../freeRTOS750/MemMang/heap_2.c **** }
 464               	.LM45:
 465 0192 8091 0000 		lds r24,xFreeBytesRemaining
 466 0196 9091 0000 		lds r25,xFreeBytesRemaining+1
 467 019a 0895      		ret
 469               	.Lscope3:
 471               		.stabd	78,0,0
 473               	.global	vPortInitialiseBlocks
 475               	vPortInitialiseBlocks:
 476               		.stabd	46,0,0
 271:../freeRTOS750/MemMang/heap_2.c **** {
 478               	.LM46:
 479               	.LFBB4:
 480               	/* prologue: function */
 481               	/* frame size = 0 */
 482               	/* stack size = 0 */
 483               	.L__stack_usage = 0
 484 019c 0895      		ret
 486               	.Lscope4:
 488               		.stabd	78,0,0
 489               		.local	xHeapHasBeenInitialised.1673
 490               		.comm	xHeapHasBeenInitialised.1673,1,1
 491               		.local	xStart
 492               		.comm	xStart,4,1
 493               		.local	xEnd
 494               		.comm	xEnd,4,1
 495               		.data
 498               	xFreeBytesRemaining:
 499 0000 DB05      		.word	1499
 500               		.local	ucHeap
 501               		.comm	ucHeap,1500,1
 507               		.text
 509               	.Letext0:
 510               		.ident	"GCC: (GNU) 4.7.2"
 511               	.global __do_copy_data
 512               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 heap_2.c
     /tmp/cctFQ34O.s:2      *ABS*:0000003e __SP_H__
     /tmp/cctFQ34O.s:3      *ABS*:0000003d __SP_L__
     /tmp/cctFQ34O.s:4      *ABS*:0000003f __SREG__
     /tmp/cctFQ34O.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cctFQ34O.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cctFQ34O.s:124    .text:00000000 pvPortMalloc
                             .bss:00000000 xHeapHasBeenInitialised.1673
     /tmp/cctFQ34O.s:494    .bss:00000009 ucHeap
     /tmp/cctFQ34O.s:490    .bss:00000001 xStart
     /tmp/cctFQ34O.s:492    .bss:00000005 xEnd
     /tmp/cctFQ34O.s:498    .data:00000000 xFreeBytesRemaining
     /tmp/cctFQ34O.s:357    .text:00000126 vPortFree
     /tmp/cctFQ34O.s:454    .text:00000192 xPortGetFreeHeapSize
     /tmp/cctFQ34O.s:475    .text:0000019c vPortInitialiseBlocks

UNDEFINED SYMBOLS
vTaskSuspendAll
xTaskResumeAll
__do_copy_data
__do_clear_bss
