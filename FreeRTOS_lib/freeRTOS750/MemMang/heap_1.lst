   1               		.file	"heap_1.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 120               	.global	pvPortMalloc
 122               	pvPortMalloc:
 123               		.stabd	46,0,0
   1:../freeRTOS750/MemMang/heap_1.c **** /*
   2:../freeRTOS750/MemMang/heap_1.c ****     FreeRTOS V7.5.0 - Copyright (C) 2013 Real Time Engineers Ltd.
   3:../freeRTOS750/MemMang/heap_1.c **** 
   4:../freeRTOS750/MemMang/heap_1.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   5:../freeRTOS750/MemMang/heap_1.c **** 
   6:../freeRTOS750/MemMang/heap_1.c ****     ***************************************************************************
   7:../freeRTOS750/MemMang/heap_1.c ****      *                                                                       *
   8:../freeRTOS750/MemMang/heap_1.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
   9:../freeRTOS750/MemMang/heap_1.c ****      *    robust, strictly quality controlled, supported, and cross          *
  10:../freeRTOS750/MemMang/heap_1.c ****      *    platform software that has become a de facto standard.             *
  11:../freeRTOS750/MemMang/heap_1.c ****      *                                                                       *
  12:../freeRTOS750/MemMang/heap_1.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  13:../freeRTOS750/MemMang/heap_1.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  14:../freeRTOS750/MemMang/heap_1.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  15:../freeRTOS750/MemMang/heap_1.c ****      *                                                                       *
  16:../freeRTOS750/MemMang/heap_1.c ****      *    Thank you!                                                         *
  17:../freeRTOS750/MemMang/heap_1.c ****      *                                                                       *
  18:../freeRTOS750/MemMang/heap_1.c ****     ***************************************************************************
  19:../freeRTOS750/MemMang/heap_1.c **** 
  20:../freeRTOS750/MemMang/heap_1.c ****     This file is part of the FreeRTOS distribution.
  21:../freeRTOS750/MemMang/heap_1.c **** 
  22:../freeRTOS750/MemMang/heap_1.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  23:../freeRTOS750/MemMang/heap_1.c ****     the terms of the GNU General Public License (version 2) as published by the
  24:../freeRTOS750/MemMang/heap_1.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  25:../freeRTOS750/MemMang/heap_1.c **** 
  26:../freeRTOS750/MemMang/heap_1.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  27:../freeRTOS750/MemMang/heap_1.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  28:../freeRTOS750/MemMang/heap_1.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  29:../freeRTOS750/MemMang/heap_1.c ****     >>! kernel.
  30:../freeRTOS750/MemMang/heap_1.c **** 
  31:../freeRTOS750/MemMang/heap_1.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  32:../freeRTOS750/MemMang/heap_1.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  33:../freeRTOS750/MemMang/heap_1.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  34:../freeRTOS750/MemMang/heap_1.c ****     link: http://www.freertos.org/a00114.html
  35:../freeRTOS750/MemMang/heap_1.c **** 
  36:../freeRTOS750/MemMang/heap_1.c ****     1 tab == 4 spaces!
  37:../freeRTOS750/MemMang/heap_1.c **** 
  38:../freeRTOS750/MemMang/heap_1.c ****     ***************************************************************************
  39:../freeRTOS750/MemMang/heap_1.c ****      *                                                                       *
  40:../freeRTOS750/MemMang/heap_1.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  41:../freeRTOS750/MemMang/heap_1.c ****      *    not run, what could be wrong?"                                     *
  42:../freeRTOS750/MemMang/heap_1.c ****      *                                                                       *
  43:../freeRTOS750/MemMang/heap_1.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  44:../freeRTOS750/MemMang/heap_1.c ****      *                                                                       *
  45:../freeRTOS750/MemMang/heap_1.c ****     ***************************************************************************
  46:../freeRTOS750/MemMang/heap_1.c **** 
  47:../freeRTOS750/MemMang/heap_1.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  48:../freeRTOS750/MemMang/heap_1.c ****     license and Real Time Engineers Ltd. contact details.
  49:../freeRTOS750/MemMang/heap_1.c **** 
  50:../freeRTOS750/MemMang/heap_1.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  51:../freeRTOS750/MemMang/heap_1.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  52:../freeRTOS750/MemMang/heap_1.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  53:../freeRTOS750/MemMang/heap_1.c **** 
  54:../freeRTOS750/MemMang/heap_1.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  55:../freeRTOS750/MemMang/heap_1.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  56:../freeRTOS750/MemMang/heap_1.c ****     licenses offer ticketed support, indemnification and middleware.
  57:../freeRTOS750/MemMang/heap_1.c **** 
  58:../freeRTOS750/MemMang/heap_1.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  59:../freeRTOS750/MemMang/heap_1.c ****     engineered and independently SIL3 certified version for use in safety and
  60:../freeRTOS750/MemMang/heap_1.c ****     mission critical applications that require provable dependability.
  61:../freeRTOS750/MemMang/heap_1.c **** 
  62:../freeRTOS750/MemMang/heap_1.c ****     1 tab == 4 spaces!
  63:../freeRTOS750/MemMang/heap_1.c **** */
  64:../freeRTOS750/MemMang/heap_1.c **** 
  65:../freeRTOS750/MemMang/heap_1.c **** 
  66:../freeRTOS750/MemMang/heap_1.c **** /*
  67:../freeRTOS750/MemMang/heap_1.c ****  * The simplest possible implementation of pvPortMalloc().  Note that this
  68:../freeRTOS750/MemMang/heap_1.c ****  * implementation does NOT allow allocated memory to be freed again.
  69:../freeRTOS750/MemMang/heap_1.c ****  *
  70:../freeRTOS750/MemMang/heap_1.c ****  * See heap_2.c, heap_3.c and heap_4.c for alternative implementations, and the
  71:../freeRTOS750/MemMang/heap_1.c ****  * memory management pages of http://www.FreeRTOS.org for more information.
  72:../freeRTOS750/MemMang/heap_1.c ****  */
  73:../freeRTOS750/MemMang/heap_1.c **** #include <stdlib.h>
  74:../freeRTOS750/MemMang/heap_1.c **** 
  75:../freeRTOS750/MemMang/heap_1.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  76:../freeRTOS750/MemMang/heap_1.c **** all the API functions to use the MPU wrappers.  That should only be done when
  77:../freeRTOS750/MemMang/heap_1.c **** task.h is included from an application file. */
  78:../freeRTOS750/MemMang/heap_1.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  79:../freeRTOS750/MemMang/heap_1.c **** 
  80:../freeRTOS750/MemMang/heap_1.c **** #include "FreeRTOS.h"
  81:../freeRTOS750/MemMang/heap_1.c **** #include "task.h"
  82:../freeRTOS750/MemMang/heap_1.c **** 
  83:../freeRTOS750/MemMang/heap_1.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  84:../freeRTOS750/MemMang/heap_1.c **** 
  85:../freeRTOS750/MemMang/heap_1.c **** /* A few bytes might be lost to byte aligning the heap start address. */
  86:../freeRTOS750/MemMang/heap_1.c **** #define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
  87:../freeRTOS750/MemMang/heap_1.c **** 
  88:../freeRTOS750/MemMang/heap_1.c **** /* Allocate the memory for the heap. */
  89:../freeRTOS750/MemMang/heap_1.c **** 
  90:../freeRTOS750/MemMang/heap_1.c **** #if ( defined(portEXT_RAM) && !defined(portEXT_RAMFS) )
  91:../freeRTOS750/MemMang/heap_1.c **** static unsigned char ucHeap[ configTOTAL_HEAP_SIZE ]  __attribute__((section(".ext_ram_heap"))); //
  92:../freeRTOS750/MemMang/heap_1.c **** #else
  93:../freeRTOS750/MemMang/heap_1.c **** static unsigned char ucHeap[ configTOTAL_HEAP_SIZE ];
  94:../freeRTOS750/MemMang/heap_1.c **** #endif
  95:../freeRTOS750/MemMang/heap_1.c **** 
  96:../freeRTOS750/MemMang/heap_1.c **** static size_t xNextFreeByte = ( size_t ) 0;
  97:../freeRTOS750/MemMang/heap_1.c **** 
  98:../freeRTOS750/MemMang/heap_1.c **** /*-----------------------------------------------------------*/
  99:../freeRTOS750/MemMang/heap_1.c **** 
 100:../freeRTOS750/MemMang/heap_1.c **** void *pvPortMalloc( size_t xWantedSize )
 101:../freeRTOS750/MemMang/heap_1.c **** {
 125               	.LM0:
 126               	.LFBB1:
 127 0000 CF93      		push r28
 128 0002 DF93      		push r29
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 2 */
 132               	.L__stack_usage = 2
 133 0004 EC01      		movw r28,r24
 102:../freeRTOS750/MemMang/heap_1.c **** void *pvReturn = NULL;
 103:../freeRTOS750/MemMang/heap_1.c **** static unsigned char *pucAlignedHeap = NULL;
 104:../freeRTOS750/MemMang/heap_1.c **** 
 105:../freeRTOS750/MemMang/heap_1.c **** 	/* Ensure that blocks are always aligned to the required number of bytes. */
 106:../freeRTOS750/MemMang/heap_1.c **** 	#if portBYTE_ALIGNMENT != 1
 107:../freeRTOS750/MemMang/heap_1.c **** 		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 108:../freeRTOS750/MemMang/heap_1.c **** 		{
 109:../freeRTOS750/MemMang/heap_1.c **** 			/* Byte alignment required. */
 110:../freeRTOS750/MemMang/heap_1.c **** 			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 111:../freeRTOS750/MemMang/heap_1.c **** 		}
 112:../freeRTOS750/MemMang/heap_1.c **** 	#endif
 113:../freeRTOS750/MemMang/heap_1.c **** 
 114:../freeRTOS750/MemMang/heap_1.c **** 	vTaskSuspendAll();
 135               	.LM1:
 136 0006 0E94 0000 		call vTaskSuspendAll
 115:../freeRTOS750/MemMang/heap_1.c **** 	{
 116:../freeRTOS750/MemMang/heap_1.c **** 		if( pucAlignedHeap == NULL )
 138               	.LM2:
 139 000a 8091 0000 		lds r24,pucAlignedHeap.1662
 140 000e 9091 0000 		lds r25,pucAlignedHeap.1662+1
 141 0012 892B      		or r24,r25
 142 0014 01F4      		brne .L2
 117:../freeRTOS750/MemMang/heap_1.c **** 		{
 118:../freeRTOS750/MemMang/heap_1.c **** 			/* Ensure the heap starts on a correctly aligned boundary. */
 119:../freeRTOS750/MemMang/heap_1.c **** 			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ]
 144               	.LM3:
 145 0016 80E0      		ldi r24,lo8(ucHeap+1)
 146 0018 90E0      		ldi r25,hi8(ucHeap+1)
 147 001a 9093 0000 		sts pucAlignedHeap.1662+1,r25
 148 001e 8093 0000 		sts pucAlignedHeap.1662,r24
 149               	.L2:
 120:../freeRTOS750/MemMang/heap_1.c **** 		}
 121:../freeRTOS750/MemMang/heap_1.c **** 
 122:../freeRTOS750/MemMang/heap_1.c **** 		/* Check there is enough room left for the allocation. */
 123:../freeRTOS750/MemMang/heap_1.c **** 		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 151               	.LM4:
 152 0022 2091 0000 		lds r18,xNextFreeByte
 153 0026 3091 0000 		lds r19,xNextFreeByte+1
 154 002a CE01      		movw r24,r28
 155 002c 820F      		add r24,r18
 156 002e 931F      		adc r25,r19
 157 0030 8B3D      		cpi r24,-37
 158 0032 45E0      		ldi r20,5
 159 0034 9407      		cpc r25,r20
 160 0036 00F4      		brsh .L5
 162               	.LM5:
 163 0038 2817      		cp r18,r24
 164 003a 3907      		cpc r19,r25
 165 003c 00F4      		brsh .L5
 124:../freeRTOS750/MemMang/heap_1.c **** 			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
 125:../freeRTOS750/MemMang/heap_1.c **** 		{
 126:../freeRTOS750/MemMang/heap_1.c **** 			/* Return the next free byte then increment the index past this
 127:../freeRTOS750/MemMang/heap_1.c **** 			block. */
 128:../freeRTOS750/MemMang/heap_1.c **** 			pvReturn = pucAlignedHeap + xNextFreeByte;
 167               	.LM6:
 168 003e C091 0000 		lds r28,pucAlignedHeap.1662
 169 0042 D091 0000 		lds r29,pucAlignedHeap.1662+1
 170 0046 C20F      		add r28,r18
 171 0048 D31F      		adc r29,r19
 129:../freeRTOS750/MemMang/heap_1.c **** 			xNextFreeByte += xWantedSize;
 173               	.LM7:
 174 004a 9093 0000 		sts xNextFreeByte+1,r25
 175 004e 8093 0000 		sts xNextFreeByte,r24
 176 0052 00C0      		rjmp .L3
 177               	.L5:
 102:../freeRTOS750/MemMang/heap_1.c **** void *pvReturn = NULL;
 179               	.LM8:
 180 0054 C0E0      		ldi r28,0
 181 0056 D0E0      		ldi r29,0
 182               	.L3:
 130:../freeRTOS750/MemMang/heap_1.c **** 		}
 131:../freeRTOS750/MemMang/heap_1.c **** 	}
 132:../freeRTOS750/MemMang/heap_1.c **** 	xTaskResumeAll();
 184               	.LM9:
 185 0058 0E94 0000 		call xTaskResumeAll
 133:../freeRTOS750/MemMang/heap_1.c **** 
 134:../freeRTOS750/MemMang/heap_1.c **** 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
 135:../freeRTOS750/MemMang/heap_1.c **** 	{
 136:../freeRTOS750/MemMang/heap_1.c **** 		if( pvReturn == NULL )
 137:../freeRTOS750/MemMang/heap_1.c **** 		{
 138:../freeRTOS750/MemMang/heap_1.c **** 			extern void vApplicationMallocFailedHook( void );
 139:../freeRTOS750/MemMang/heap_1.c **** 			vApplicationMallocFailedHook();
 140:../freeRTOS750/MemMang/heap_1.c **** 		}
 141:../freeRTOS750/MemMang/heap_1.c **** 	}
 142:../freeRTOS750/MemMang/heap_1.c **** 	#endif
 143:../freeRTOS750/MemMang/heap_1.c **** 
 144:../freeRTOS750/MemMang/heap_1.c **** 	return pvReturn;
 145:../freeRTOS750/MemMang/heap_1.c **** }
 187               	.LM10:
 188 005c CE01      		movw r24,r28
 189               	/* epilogue start */
 190 005e DF91      		pop r29
 191 0060 CF91      		pop r28
 192 0062 0895      		ret
 198               	.Lscope1:
 200               		.stabd	78,0,0
 203               	.global	vPortFree
 205               	vPortFree:
 206               		.stabd	46,0,0
 146:../freeRTOS750/MemMang/heap_1.c **** /*-----------------------------------------------------------*/
 147:../freeRTOS750/MemMang/heap_1.c **** 
 148:../freeRTOS750/MemMang/heap_1.c **** void vPortFree( void *pv )
 149:../freeRTOS750/MemMang/heap_1.c **** {
 208               	.LM11:
 209               	.LFBB2:
 210               	/* prologue: function */
 211               	/* frame size = 0 */
 212               	/* stack size = 0 */
 213               	.L__stack_usage = 0
 214 0064 0895      		ret
 216               	.Lscope2:
 218               		.stabd	78,0,0
 220               	.global	vPortInitialiseBlocks
 222               	vPortInitialiseBlocks:
 223               		.stabd	46,0,0
 150:../freeRTOS750/MemMang/heap_1.c **** 	/* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and
 151:../freeRTOS750/MemMang/heap_1.c **** 	heap_4.c for alternative implementations, and the memory management pages of
 152:../freeRTOS750/MemMang/heap_1.c **** 	http://www.FreeRTOS.org for more information. */
 153:../freeRTOS750/MemMang/heap_1.c **** 	( void ) pv;
 154:../freeRTOS750/MemMang/heap_1.c **** 
 155:../freeRTOS750/MemMang/heap_1.c **** 	/* Force an assert as it is invalid to call this function. */
 156:../freeRTOS750/MemMang/heap_1.c **** 	configASSERT( pv == NULL );
 157:../freeRTOS750/MemMang/heap_1.c **** }
 158:../freeRTOS750/MemMang/heap_1.c **** /*-----------------------------------------------------------*/
 159:../freeRTOS750/MemMang/heap_1.c **** 
 160:../freeRTOS750/MemMang/heap_1.c **** void vPortInitialiseBlocks( void )
 161:../freeRTOS750/MemMang/heap_1.c **** {
 225               	.LM12:
 226               	.LFBB3:
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 0 */
 230               	.L__stack_usage = 0
 162:../freeRTOS750/MemMang/heap_1.c **** 	/* Only required when static memory is not cleared. */
 163:../freeRTOS750/MemMang/heap_1.c **** 	xNextFreeByte = ( size_t ) 0;
 232               	.LM13:
 233 0066 1092 0000 		sts xNextFreeByte+1,__zero_reg__
 234 006a 1092 0000 		sts xNextFreeByte,__zero_reg__
 235 006e 0895      		ret
 237               	.Lscope3:
 239               		.stabd	78,0,0
 241               	.global	xPortGetFreeHeapSize
 243               	xPortGetFreeHeapSize:
 244               		.stabd	46,0,0
 164:../freeRTOS750/MemMang/heap_1.c **** }
 165:../freeRTOS750/MemMang/heap_1.c **** /*-----------------------------------------------------------*/
 166:../freeRTOS750/MemMang/heap_1.c **** 
 167:../freeRTOS750/MemMang/heap_1.c **** size_t xPortGetFreeHeapSize( void )
 168:../freeRTOS750/MemMang/heap_1.c **** {
 246               	.LM14:
 247               	.LFBB4:
 248               	/* prologue: function */
 249               	/* frame size = 0 */
 250               	/* stack size = 0 */
 251               	.L__stack_usage = 0
 169:../freeRTOS750/MemMang/heap_1.c **** 	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 253               	.LM15:
 254 0070 2BED      		ldi r18,lo8(-37)
 255 0072 35E0      		ldi r19,lo8(5)
 256 0074 8091 0000 		lds r24,xNextFreeByte
 257 0078 9091 0000 		lds r25,xNextFreeByte+1
 258 007c 281B      		sub r18,r24
 259 007e 390B      		sbc r19,r25
 170:../freeRTOS750/MemMang/heap_1.c **** }
 261               	.LM16:
 262 0080 C901      		movw r24,r18
 263 0082 0895      		ret
 265               	.Lscope4:
 267               		.stabd	78,0,0
 268               		.local	pucAlignedHeap.1662
 269               		.comm	pucAlignedHeap.1662,2,1
 270               		.local	ucHeap
 271               		.comm	ucHeap,1500,1
 272               		.local	xNextFreeByte
 273               		.comm	xNextFreeByte,2,1
 277               	.Letext0:
 278               		.ident	"GCC: (GNU) 4.7.2"
 279               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 heap_1.c
     /tmp/cc78lFRL.s:2      *ABS*:0000003e __SP_H__
     /tmp/cc78lFRL.s:3      *ABS*:0000003d __SP_L__
     /tmp/cc78lFRL.s:4      *ABS*:0000003f __SREG__
     /tmp/cc78lFRL.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cc78lFRL.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cc78lFRL.s:122    .text:00000000 pvPortMalloc
                             .bss:00000000 pucAlignedHeap.1662
     /tmp/cc78lFRL.s:269    .bss:00000002 ucHeap
     /tmp/cc78lFRL.s:271    .bss:000005de xNextFreeByte
     /tmp/cc78lFRL.s:205    .text:00000064 vPortFree
     /tmp/cc78lFRL.s:222    .text:00000066 vPortInitialiseBlocks
     /tmp/cc78lFRL.s:243    .text:00000070 xPortGetFreeHeapSize

UNDEFINED SYMBOLS
vTaskSuspendAll
xTaskResumeAll
__do_clear_bss
