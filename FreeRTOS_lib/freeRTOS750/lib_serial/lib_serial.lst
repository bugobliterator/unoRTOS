   1               		.file	"lib_serial.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 135               	.global	xSerialFlush
 137               	xSerialFlush:
 138               		.stabd	46,0,0
   1:../freeRTOS750/lib_serial/lib_serial.c **** /*
   2:../freeRTOS750/lib_serial/lib_serial.c ****     FreeRTOS V7.0.1 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../freeRTOS750/lib_serial/lib_serial.c **** 
   4:../freeRTOS750/lib_serial/lib_serial.c **** 
   5:../freeRTOS750/lib_serial/lib_serial.c ****     ***************************************************************************
   6:../freeRTOS750/lib_serial/lib_serial.c ****      *                                                                       *
   7:../freeRTOS750/lib_serial/lib_serial.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../freeRTOS750/lib_serial/lib_serial.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../freeRTOS750/lib_serial/lib_serial.c ****      *    available.                                                         *
  10:../freeRTOS750/lib_serial/lib_serial.c ****      *                                                                       *
  11:../freeRTOS750/lib_serial/lib_serial.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../freeRTOS750/lib_serial/lib_serial.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../freeRTOS750/lib_serial/lib_serial.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../freeRTOS750/lib_serial/lib_serial.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../freeRTOS750/lib_serial/lib_serial.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../freeRTOS750/lib_serial/lib_serial.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../freeRTOS750/lib_serial/lib_serial.c ****      *                                                                       *
  18:../freeRTOS750/lib_serial/lib_serial.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../freeRTOS750/lib_serial/lib_serial.c ****      *                                                                       *
  20:../freeRTOS750/lib_serial/lib_serial.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../freeRTOS750/lib_serial/lib_serial.c ****      *                                                                       *
  22:../freeRTOS750/lib_serial/lib_serial.c ****     ***************************************************************************
  23:../freeRTOS750/lib_serial/lib_serial.c **** 
  24:../freeRTOS750/lib_serial/lib_serial.c **** 
  25:../freeRTOS750/lib_serial/lib_serial.c ****     This file is part of the FreeRTOS distribution.
  26:../freeRTOS750/lib_serial/lib_serial.c **** 
  27:../freeRTOS750/lib_serial/lib_serial.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../freeRTOS750/lib_serial/lib_serial.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../freeRTOS750/lib_serial/lib_serial.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../freeRTOS750/lib_serial/lib_serial.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../freeRTOS750/lib_serial/lib_serial.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../freeRTOS750/lib_serial/lib_serial.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../freeRTOS750/lib_serial/lib_serial.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../freeRTOS750/lib_serial/lib_serial.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../freeRTOS750/lib_serial/lib_serial.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../freeRTOS750/lib_serial/lib_serial.c ****     more details. You should have received a copy of the GNU General Public
  37:../freeRTOS750/lib_serial/lib_serial.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../freeRTOS750/lib_serial/lib_serial.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../freeRTOS750/lib_serial/lib_serial.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../freeRTOS750/lib_serial/lib_serial.c ****     FreeRTOS WEB site.
  41:../freeRTOS750/lib_serial/lib_serial.c **** 
  42:../freeRTOS750/lib_serial/lib_serial.c ****     1 tab == 4 spaces!
  43:../freeRTOS750/lib_serial/lib_serial.c **** 
  44:../freeRTOS750/lib_serial/lib_serial.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../freeRTOS750/lib_serial/lib_serial.c ****     contact details.
  46:../freeRTOS750/lib_serial/lib_serial.c **** 
  47:../freeRTOS750/lib_serial/lib_serial.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../freeRTOS750/lib_serial/lib_serial.c ****     critical systems.
  49:../freeRTOS750/lib_serial/lib_serial.c **** 
  50:../freeRTOS750/lib_serial/lib_serial.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../freeRTOS750/lib_serial/lib_serial.c ****     licensing and training services.
  52:../freeRTOS750/lib_serial/lib_serial.c **** */
  53:../freeRTOS750/lib_serial/lib_serial.c **** 
  54:../freeRTOS750/lib_serial/lib_serial.c **** /* BASIC INTERRUPT DRIVEN SERIAL PORT DRIVER. */
  55:../freeRTOS750/lib_serial/lib_serial.c **** /* Also with polling serial functions, for use before scheduler is enabled */
  56:../freeRTOS750/lib_serial/lib_serial.c **** 
  57:../freeRTOS750/lib_serial/lib_serial.c **** #include <stdio.h>
  58:../freeRTOS750/lib_serial/lib_serial.c **** #include <stdarg.h>
  59:../freeRTOS750/lib_serial/lib_serial.c **** #include <string.h>
  60:../freeRTOS750/lib_serial/lib_serial.c **** 
  61:../freeRTOS750/lib_serial/lib_serial.c **** #include <util/delay.h>
  62:../freeRTOS750/lib_serial/lib_serial.c **** 
  63:../freeRTOS750/lib_serial/lib_serial.c **** #include <avr/io.h>
  64:../freeRTOS750/lib_serial/lib_serial.c **** #include <avr/interrupt.h>
  65:../freeRTOS750/lib_serial/lib_serial.c **** #include <avr/pgmspace.h>
  66:../freeRTOS750/lib_serial/lib_serial.c **** 
  67:../freeRTOS750/lib_serial/lib_serial.c **** #include <FreeRTOS.h>
  68:../freeRTOS750/lib_serial/lib_serial.c **** #include <task.h>
  69:../freeRTOS750/lib_serial/lib_serial.c **** #include <queue.h>
  70:../freeRTOS750/lib_serial/lib_serial.c **** 
  71:../freeRTOS750/lib_serial/lib_serial.c **** #include <ringBuffer.h>
  72:../freeRTOS750/lib_serial/lib_serial.c **** 
  73:../freeRTOS750/lib_serial/lib_serial.c **** #include <lib_serial.h>
  74:../freeRTOS750/lib_serial/lib_serial.c **** 
  75:../freeRTOS750/lib_serial/lib_serial.c **** 
  76:../freeRTOS750/lib_serial/lib_serial.c **** /*-----------------------------------------------------------*/
  77:../freeRTOS750/lib_serial/lib_serial.c **** 
  78:../freeRTOS750/lib_serial/lib_serial.c **** #define vInterrupt0_On()									\
  79:../freeRTOS750/lib_serial/lib_serial.c **** {															\
  80:../freeRTOS750/lib_serial/lib_serial.c **** 	uint8_t ucByte;								    		\
  81:../freeRTOS750/lib_serial/lib_serial.c **** 															\
  82:../freeRTOS750/lib_serial/lib_serial.c **** 	ucByte  = UCSR0B;										\
  83:../freeRTOS750/lib_serial/lib_serial.c **** 	ucByte |= _BV(UDRIE0);									\
  84:../freeRTOS750/lib_serial/lib_serial.c **** 	UCSR0B  = ucByte;										\
  85:../freeRTOS750/lib_serial/lib_serial.c **** }
  86:../freeRTOS750/lib_serial/lib_serial.c **** 
  87:../freeRTOS750/lib_serial/lib_serial.c **** 
  88:../freeRTOS750/lib_serial/lib_serial.c **** #define vInterrupt0_Off()									\
  89:../freeRTOS750/lib_serial/lib_serial.c **** {															\
  90:../freeRTOS750/lib_serial/lib_serial.c **** 	uint8_t ucByte;								   			\
  91:../freeRTOS750/lib_serial/lib_serial.c **** 															\
  92:../freeRTOS750/lib_serial/lib_serial.c **** 	ucByte  = UCSR0B;										\
  93:../freeRTOS750/lib_serial/lib_serial.c **** 	ucByte &= ~_BV(UDRIE0);									\
  94:../freeRTOS750/lib_serial/lib_serial.c **** 	UCSR0B  = ucByte;										\
  95:../freeRTOS750/lib_serial/lib_serial.c **** }
  96:../freeRTOS750/lib_serial/lib_serial.c **** 
  97:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) || d
  98:../freeRTOS750/lib_serial/lib_serial.c **** 
  99:../freeRTOS750/lib_serial/lib_serial.c **** #define vInterrupt1_On()									\
 100:../freeRTOS750/lib_serial/lib_serial.c **** {															\
 101:../freeRTOS750/lib_serial/lib_serial.c **** 	uint8_t ucByte;								    		\
 102:../freeRTOS750/lib_serial/lib_serial.c **** 															\
 103:../freeRTOS750/lib_serial/lib_serial.c **** 	ucByte  = UCSR1B;										\
 104:../freeRTOS750/lib_serial/lib_serial.c **** 	ucByte |= _BV(UDRIE1);									\
 105:../freeRTOS750/lib_serial/lib_serial.c **** 	UCSR1B  = ucByte;										\
 106:../freeRTOS750/lib_serial/lib_serial.c **** }
 107:../freeRTOS750/lib_serial/lib_serial.c **** 
 108:../freeRTOS750/lib_serial/lib_serial.c **** 
 109:../freeRTOS750/lib_serial/lib_serial.c **** #define vInterrupt1_Off()									\
 110:../freeRTOS750/lib_serial/lib_serial.c **** {															\
 111:../freeRTOS750/lib_serial/lib_serial.c **** 	uint8_t ucByte;								   			\
 112:../freeRTOS750/lib_serial/lib_serial.c **** 															\
 113:../freeRTOS750/lib_serial/lib_serial.c **** 	ucByte  = UCSR1B;										\
 114:../freeRTOS750/lib_serial/lib_serial.c **** 	ucByte &= ~_BV(UDRIE1);									\
 115:../freeRTOS750/lib_serial/lib_serial.c **** 	UCSR1B  = ucByte;										\
 116:../freeRTOS750/lib_serial/lib_serial.c **** }
 117:../freeRTOS750/lib_serial/lib_serial.c **** 
 118:../freeRTOS750/lib_serial/lib_serial.c **** #else
 119:../freeRTOS750/lib_serial/lib_serial.c **** 
 120:../freeRTOS750/lib_serial/lib_serial.c **** #define vInterrupt1_On()
 121:../freeRTOS750/lib_serial/lib_serial.c **** #define vInterrupt1_Off()
 122:../freeRTOS750/lib_serial/lib_serial.c **** 
 123:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 124:../freeRTOS750/lib_serial/lib_serial.c **** 
 125:../freeRTOS750/lib_serial/lib_serial.c **** /*-----------------------------------------------------------*/
 126:../freeRTOS750/lib_serial/lib_serial.c **** 
 127:../freeRTOS750/lib_serial/lib_serial.c **** /* Create a handle for the serial port, USART0. */
 128:../freeRTOS750/lib_serial/lib_serial.c **** /* This variable is special, as it is used in the interrupt */
 129:../freeRTOS750/lib_serial/lib_serial.c **** xComPortHandle xSerialPort;
 130:../freeRTOS750/lib_serial/lib_serial.c **** 
 131:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) || d
 132:../freeRTOS750/lib_serial/lib_serial.c **** 
 133:../freeRTOS750/lib_serial/lib_serial.c **** /* Create a handle for the other serial port, USART1. */
 134:../freeRTOS750/lib_serial/lib_serial.c **** /* This variable is special, as it is used in the interrupt */
 135:../freeRTOS750/lib_serial/lib_serial.c **** xComPortHandle xSerial1Port;
 136:../freeRTOS750/lib_serial/lib_serial.c **** 
 137:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 138:../freeRTOS750/lib_serial/lib_serial.c **** 
 139:../freeRTOS750/lib_serial/lib_serial.c **** /*-----------------------------------------------------------------*/
 140:../freeRTOS750/lib_serial/lib_serial.c **** 
 141:../freeRTOS750/lib_serial/lib_serial.c **** // xSerialPrintf_P(PSTR("\r\nMessage %u %u %u"), var1, var2, var2);
 142:../freeRTOS750/lib_serial/lib_serial.c **** 
 143:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialPrintf( const char * format, ...)
 144:../freeRTOS750/lib_serial/lib_serial.c **** {
 145:../freeRTOS750/lib_serial/lib_serial.c **** 	va_list arg;
 146:../freeRTOS750/lib_serial/lib_serial.c **** 
 147:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 148:../freeRTOS750/lib_serial/lib_serial.c **** 
 149:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) taskYIELD();
 150:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = ENGAGED;
 151:../freeRTOS750/lib_serial/lib_serial.c **** 
 152:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf((char *)(xSerialPort.serialWorkBuffer), xSerialPort.serialWorkBufferSize, (const char *)
 153:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPrint((uint8_t *)(xSerialPort.serialWorkBuffer));
 154:../freeRTOS750/lib_serial/lib_serial.c **** 
 155:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = VACANT;
 156:../freeRTOS750/lib_serial/lib_serial.c **** 
 157:../freeRTOS750/lib_serial/lib_serial.c **** 	va_end(arg);
 158:../freeRTOS750/lib_serial/lib_serial.c **** }
 159:../freeRTOS750/lib_serial/lib_serial.c **** 
 160:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialPrintf_P(PGM_P format, ...)
 161:../freeRTOS750/lib_serial/lib_serial.c **** {
 162:../freeRTOS750/lib_serial/lib_serial.c **** 	va_list arg;
 163:../freeRTOS750/lib_serial/lib_serial.c **** 
 164:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 165:../freeRTOS750/lib_serial/lib_serial.c **** 
 166:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) taskYIELD();
 167:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = ENGAGED;
 168:../freeRTOS750/lib_serial/lib_serial.c **** 
 169:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf_P((char *)(xSerialPort.serialWorkBuffer), xSerialPort.serialWorkBufferSize, format, arg)
 170:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPrint((uint8_t *)(xSerialPort.serialWorkBuffer));
 171:../freeRTOS750/lib_serial/lib_serial.c **** 
 172:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = VACANT;
 173:../freeRTOS750/lib_serial/lib_serial.c **** 
 174:../freeRTOS750/lib_serial/lib_serial.c **** 	va_end(arg);
 175:../freeRTOS750/lib_serial/lib_serial.c **** }
 176:../freeRTOS750/lib_serial/lib_serial.c **** 
 177:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialPrint( uint8_t * str)
 178:../freeRTOS750/lib_serial/lib_serial.c **** {
 179:../freeRTOS750/lib_serial/lib_serial.c **** 	int16_t i = 0;
 180:../freeRTOS750/lib_serial/lib_serial.c **** 	size_t stringlength;
 181:../freeRTOS750/lib_serial/lib_serial.c **** 
 182:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen((char *)str);
 183:../freeRTOS750/lib_serial/lib_serial.c **** 
 184:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 185:../freeRTOS750/lib_serial/lib_serial.c **** 		xSerialPutChar( &xSerialPort, str[i++] );
 186:../freeRTOS750/lib_serial/lib_serial.c **** }
 187:../freeRTOS750/lib_serial/lib_serial.c **** 
 188:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialPrint_P(PGM_P str)
 189:../freeRTOS750/lib_serial/lib_serial.c **** {
 190:../freeRTOS750/lib_serial/lib_serial.c **** 	uint16_t i = 0;
 191:../freeRTOS750/lib_serial/lib_serial.c **** 	size_t stringlength;
 192:../freeRTOS750/lib_serial/lib_serial.c **** 
 193:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen_P(str);
 194:../freeRTOS750/lib_serial/lib_serial.c **** 
 195:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 196:../freeRTOS750/lib_serial/lib_serial.c **** 		xSerialPutChar( &xSerialPort, pgm_read_byte(&str[i++]) );
 197:../freeRTOS750/lib_serial/lib_serial.c **** }
 198:../freeRTOS750/lib_serial/lib_serial.c **** /*-----------------------------------------------------------*/
 199:../freeRTOS750/lib_serial/lib_serial.c **** 
 200:../freeRTOS750/lib_serial/lib_serial.c **** 
 201:../freeRTOS750/lib_serial/lib_serial.c **** // These can be set to use any USART (but only two implemented for now).
 202:../freeRTOS750/lib_serial/lib_serial.c **** 
 203:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialxPrintf( xComPortHandlePtr pxPort, const char * format, ...)
 204:../freeRTOS750/lib_serial/lib_serial.c **** {
 205:../freeRTOS750/lib_serial/lib_serial.c **** 	va_list arg;
 206:../freeRTOS750/lib_serial/lib_serial.c **** 
 207:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 208:../freeRTOS750/lib_serial/lib_serial.c **** 
 209:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) taskYIELD();
 210:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = ENGAGED;
 211:../freeRTOS750/lib_serial/lib_serial.c **** 
 212:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf((char *)(pxPort->serialWorkBuffer), pxPort->serialWorkBufferSize, (const char *)format, 
 213:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialxPrint(pxPort, (uint8_t *)(pxPort->serialWorkBuffer));
 214:../freeRTOS750/lib_serial/lib_serial.c **** 
 215:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = VACANT;
 216:../freeRTOS750/lib_serial/lib_serial.c **** 
 217:../freeRTOS750/lib_serial/lib_serial.c **** 	va_end(arg);
 218:../freeRTOS750/lib_serial/lib_serial.c **** }
 219:../freeRTOS750/lib_serial/lib_serial.c **** 
 220:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialxPrintf_P( xComPortHandlePtr pxPort, PGM_P format, ...)
 221:../freeRTOS750/lib_serial/lib_serial.c **** {
 222:../freeRTOS750/lib_serial/lib_serial.c **** 	va_list arg;
 223:../freeRTOS750/lib_serial/lib_serial.c **** 
 224:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 225:../freeRTOS750/lib_serial/lib_serial.c **** 
 226:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) taskYIELD();
 227:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = ENGAGED;
 228:../freeRTOS750/lib_serial/lib_serial.c **** 
 229:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf_P((char *)(pxPort->serialWorkBuffer), pxPort->serialWorkBufferSize, format, arg);
 230:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialxPrint(pxPort, (uint8_t *)(pxPort->serialWorkBuffer));
 231:../freeRTOS750/lib_serial/lib_serial.c **** 
 232:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = VACANT;
 233:../freeRTOS750/lib_serial/lib_serial.c **** 
 234:../freeRTOS750/lib_serial/lib_serial.c **** 	va_end(arg);
 235:../freeRTOS750/lib_serial/lib_serial.c **** }
 236:../freeRTOS750/lib_serial/lib_serial.c **** 
 237:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialxPrint( xComPortHandlePtr pxPort, uint8_t * str)
 238:../freeRTOS750/lib_serial/lib_serial.c **** {
 239:../freeRTOS750/lib_serial/lib_serial.c **** 	int16_t i = 0;
 240:../freeRTOS750/lib_serial/lib_serial.c **** 	size_t stringlength;
 241:../freeRTOS750/lib_serial/lib_serial.c **** 
 242:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen((char *)str);
 243:../freeRTOS750/lib_serial/lib_serial.c **** 
 244:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 245:../freeRTOS750/lib_serial/lib_serial.c **** 		xSerialPutChar( pxPort, str[i++]);
 246:../freeRTOS750/lib_serial/lib_serial.c **** }
 247:../freeRTOS750/lib_serial/lib_serial.c **** 
 248:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialxPrint_P( xComPortHandlePtr pxPort, PGM_P str)
 249:../freeRTOS750/lib_serial/lib_serial.c **** {
 250:../freeRTOS750/lib_serial/lib_serial.c **** 	uint16_t i = 0;
 251:../freeRTOS750/lib_serial/lib_serial.c **** 	size_t stringlength;
 252:../freeRTOS750/lib_serial/lib_serial.c **** 
 253:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen_P(str);
 254:../freeRTOS750/lib_serial/lib_serial.c **** 
 255:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 256:../freeRTOS750/lib_serial/lib_serial.c **** 		xSerialPutChar( pxPort, pgm_read_byte(&str[i++]) );
 257:../freeRTOS750/lib_serial/lib_serial.c **** }
 258:../freeRTOS750/lib_serial/lib_serial.c **** /*-----------------------------------------------------------*/
 259:../freeRTOS750/lib_serial/lib_serial.c **** 
 260:../freeRTOS750/lib_serial/lib_serial.c **** inline void xSerialFlush( xComPortHandlePtr pxPort )
 261:../freeRTOS750/lib_serial/lib_serial.c **** {
 140               	.LM0:
 141               	.LFBB1:
 142               	/* prologue: function */
 143               	/* frame size = 0 */
 144               	/* stack size = 0 */
 145               	.L__stack_usage = 0
 146 0000 FC01      		movw r30,r24
 262:../freeRTOS750/lib_serial/lib_serial.c **** 	/* Flush received characters from the serial port buffer.*/
 263:../freeRTOS750/lib_serial/lib_serial.c **** 
 264:../freeRTOS750/lib_serial/lib_serial.c **** 	uint8_t byte;
 265:../freeRTOS750/lib_serial/lib_serial.c **** 
 266:../freeRTOS750/lib_serial/lib_serial.c **** 	switch (pxPort->usart)
 148               	.LM1:
 149 0002 8081      		ld r24,Z
 150 0004 8823      		tst r24
 151 0006 01F0      		breq .L7
 152 0008 00C0      		rjmp .L2
 153               	.L4:
 267:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 268:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART0:
 269:../freeRTOS750/lib_serial/lib_serial.c **** 		while ( UCSR0A & (1<<RXC0) )
 270:../freeRTOS750/lib_serial/lib_serial.c **** 			byte = UDR0;
 155               	.LM2:
 156 000a 8091 C600 		lds r24,198
 157               	.L7:
 269:../freeRTOS750/lib_serial/lib_serial.c **** 		while ( UCSR0A & (1<<RXC0) )
 159               	.LM3:
 160 000e 8091 C000 		lds r24,192
 161 0012 87FD      		sbrc r24,7
 162 0014 00C0      		rjmp .L4
 163               	.L2:
 164               	.LBB107:
 165               	.LBB108:
 167               	.Ltext1:
   1:../freeRTOS750/include/ringBuffer.h **** /*
   2:../freeRTOS750/include/ringBuffer.h ****              LUFA Library
   3:../freeRTOS750/include/ringBuffer.h ****      Copyright (C) Dean Camera, 2013.
   4:../freeRTOS750/include/ringBuffer.h **** 
   5:../freeRTOS750/include/ringBuffer.h ****   dean [at] fourwalledcubicle [dot] com
   6:../freeRTOS750/include/ringBuffer.h ****            www.lufa-lib.org
   7:../freeRTOS750/include/ringBuffer.h **** */
   8:../freeRTOS750/include/ringBuffer.h **** 
   9:../freeRTOS750/include/ringBuffer.h **** /*
  10:../freeRTOS750/include/ringBuffer.h ****   Copyright 2013  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../freeRTOS750/include/ringBuffer.h **** 
  12:../freeRTOS750/include/ringBuffer.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../freeRTOS750/include/ringBuffer.h ****   software and its documentation for any purpose is hereby granted
  14:../freeRTOS750/include/ringBuffer.h ****   without fee, provided that the above copyright notice appear in
  15:../freeRTOS750/include/ringBuffer.h ****   all copies and that both that the copyright notice and this
  16:../freeRTOS750/include/ringBuffer.h ****   permission notice and warranty disclaimer appear in supporting
  17:../freeRTOS750/include/ringBuffer.h ****   documentation, and that the name of the author not be used in
  18:../freeRTOS750/include/ringBuffer.h ****   advertising or publicity pertaining to distribution of the
  19:../freeRTOS750/include/ringBuffer.h ****   software without specific, written prior permission.
  20:../freeRTOS750/include/ringBuffer.h **** 
  21:../freeRTOS750/include/ringBuffer.h ****   The author disclaims all warranties with regard to this
  22:../freeRTOS750/include/ringBuffer.h ****   software, including all implied warranties of merchantability
  23:../freeRTOS750/include/ringBuffer.h ****   and fitness.  In no event shall the author be liable for any
  24:../freeRTOS750/include/ringBuffer.h ****   special, indirect or consequential damages or any damages
  25:../freeRTOS750/include/ringBuffer.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../freeRTOS750/include/ringBuffer.h ****   in an action of contract, negligence or other tortious action,
  27:../freeRTOS750/include/ringBuffer.h ****   arising out of or in connection with the use or performance of
  28:../freeRTOS750/include/ringBuffer.h ****   this software.
  29:../freeRTOS750/include/ringBuffer.h **** */
  30:../freeRTOS750/include/ringBuffer.h **** 
  31:../freeRTOS750/include/ringBuffer.h **** /** \ingroup Group_MiscDrivers
  32:../freeRTOS750/include/ringBuffer.h ****  *  \defgroup Group_RingBuff Generic Byte Ring Buffer - LUFA/Drivers/Misc/RingBuffer.h
  33:../freeRTOS750/include/ringBuffer.h ****  *  \brief Lightweight ring buffer, for fast insertion/deletion of bytes.
  34:../freeRTOS750/include/ringBuffer.h ****  *
  35:../freeRTOS750/include/ringBuffer.h ****  *  \section Sec_RingBuff_Dependencies Module Source Dependencies
  36:../freeRTOS750/include/ringBuffer.h ****  *  The following files must be built with any user project that uses this module:
  37:../freeRTOS750/include/ringBuffer.h ****  *    - None
  38:../freeRTOS750/include/ringBuffer.h ****  *
  39:../freeRTOS750/include/ringBuffer.h ****  *  \section Sec_RingBuff_ModDescription Module Description
  40:../freeRTOS750/include/ringBuffer.h ****  *  Lightweight ring buffer, for fast insertion/deletion. Multiple buffers can be created of
  41:../freeRTOS750/include/ringBuffer.h ****  *  different sizes to suit different needs.
  42:../freeRTOS750/include/ringBuffer.h ****  *
  43:../freeRTOS750/include/ringBuffer.h ****  *  Note that for each buffer, insertion and removal operations may occur at the same time (via
  44:../freeRTOS750/include/ringBuffer.h ****  *  a multi-threaded ISR based system) however the same kind of operation (two or more insertions
  45:../freeRTOS750/include/ringBuffer.h ****  *  or deletions) must not overlap. If there is possibility of two or more of the same kind of
  46:../freeRTOS750/include/ringBuffer.h ****  *  operating occurring at the same point in time, atomic (mutex) locking should be used.
  47:../freeRTOS750/include/ringBuffer.h ****  *
  48:../freeRTOS750/include/ringBuffer.h ****  *  \section Sec_RingBuff_ExampleUsage Example Usage
  49:../freeRTOS750/include/ringBuffer.h ****  *  The following snippet is an example of how this module may be used within a typical
  50:../freeRTOS750/include/ringBuffer.h ****  *  application.
  51:../freeRTOS750/include/ringBuffer.h ****  *
  52:../freeRTOS750/include/ringBuffer.h ****  *  \code
  53:../freeRTOS750/include/ringBuffer.h ****  *      // Create the buffer structure and its underlying storage array
  54:../freeRTOS750/include/ringBuffer.h ****  *      ringBuffer_t buffer;
  55:../freeRTOS750/include/ringBuffer.h ****  *      uint8_t      bufferData[128];
  56:../freeRTOS750/include/ringBuffer.h ****  *
  57:../freeRTOS750/include/ringBuffer.h ****  *      // Initialize the buffer with the created storage array
  58:../freeRTOS750/include/ringBuffer.h ****  *      ringBuffer_InitBuffer(&buffer, bufferData, sizeof(bufferData));
  59:../freeRTOS750/include/ringBuffer.h ****  *
  60:../freeRTOS750/include/ringBuffer.h ****  *      // Insert some data into the buffer
  61:../freeRTOS750/include/ringBuffer.h ****  *      ringBuffer_Poke(&buffer, 'H');
  62:../freeRTOS750/include/ringBuffer.h ****  *      ringBuffer_Poke(&buffer, 'E');
  63:../freeRTOS750/include/ringBuffer.h ****  *      ringBuffer_Poke(&buffer, 'L');
  64:../freeRTOS750/include/ringBuffer.h ****  *      ringBuffer_Poke(&buffer, 'L');
  65:../freeRTOS750/include/ringBuffer.h ****  *      ringBuffer_Poke(&buffer, 'O');
  66:../freeRTOS750/include/ringBuffer.h ****  *
  67:../freeRTOS750/include/ringBuffer.h ****  *      // Cache the number of stored bytes in the buffer
  68:../freeRTOS750/include/ringBuffer.h ****  *      uint16_t BufferCount = ringBuffer_GetCount(&buffer);
  69:../freeRTOS750/include/ringBuffer.h ****  *
  70:../freeRTOS750/include/ringBuffer.h ****  *      // Printer stored data length
  71:../freeRTOS750/include/ringBuffer.h ****  *      printf("buffer Length: %d, Buffer Data: \r\n", BufferCount);
  72:../freeRTOS750/include/ringBuffer.h ****  *
  73:../freeRTOS750/include/ringBuffer.h ****  *      // Print contents of the buffer one character at a time
  74:../freeRTOS750/include/ringBuffer.h ****  *      while (BufferCount--)
  75:../freeRTOS750/include/ringBuffer.h ****  *        putc(ringBuffer_Pop(&buffer));
  76:../freeRTOS750/include/ringBuffer.h ****  *  \endcode
  77:../freeRTOS750/include/ringBuffer.h ****  *
  78:../freeRTOS750/include/ringBuffer.h ****  *  @{
  79:../freeRTOS750/include/ringBuffer.h ****  */
  80:../freeRTOS750/include/ringBuffer.h **** 
  81:../freeRTOS750/include/ringBuffer.h **** #ifndef __RING_BUFFER_H__
  82:../freeRTOS750/include/ringBuffer.h **** #define __RING_BUFFER_H__
  83:../freeRTOS750/include/ringBuffer.h **** 
  84:../freeRTOS750/include/ringBuffer.h **** 
  85:../freeRTOS750/include/ringBuffer.h **** /* Enable C linkage for C++ Compilers: */
  86:../freeRTOS750/include/ringBuffer.h **** #if defined(__cplusplus)
  87:../freeRTOS750/include/ringBuffer.h **** 	extern "C" {
  88:../freeRTOS750/include/ringBuffer.h **** #endif
  89:../freeRTOS750/include/ringBuffer.h **** 
  90:../freeRTOS750/include/ringBuffer.h **** #include <FreeRTOS.h>
  91:../freeRTOS750/include/ringBuffer.h **** 
  92:../freeRTOS750/include/ringBuffer.h **** /** Indicates that the function returns a value which should not be ignored by the user code. When
  93:../freeRTOS750/include/ringBuffer.h ****  *  applied, any ignored return value from calling the function will produce a compiler warning.
  94:../freeRTOS750/include/ringBuffer.h ****  */
  95:../freeRTOS750/include/ringBuffer.h **** #define ATTR_WARN_UNUSED_RESULT      __attribute__ ((warn_unused_result))
  96:../freeRTOS750/include/ringBuffer.h **** 
  97:../freeRTOS750/include/ringBuffer.h **** /** Indicates that the specified parameters of the function are pointers which should never be \c N
  98:../freeRTOS750/include/ringBuffer.h ****  *  When applied as a 1-based comma separated list the compiler will emit a warning if the specifie
  99:../freeRTOS750/include/ringBuffer.h ****  *  parameters are known at compiler time to be \c NULL at the point of calling the function.
 100:../freeRTOS750/include/ringBuffer.h ****  */
 101:../freeRTOS750/include/ringBuffer.h **** #define ATTR_NON_NULL_PTR_ARG(...)   __attribute__ ((nonnull (__VA_ARGS__)))
 102:../freeRTOS750/include/ringBuffer.h **** 
 103:../freeRTOS750/include/ringBuffer.h **** /** Forces the compiler to never inline the specified function. When applied, the given function wi
 104:../freeRTOS750/include/ringBuffer.h ****  *  always be called explicitly under all circumstances.
 105:../freeRTOS750/include/ringBuffer.h ****  */
 106:../freeRTOS750/include/ringBuffer.h **** #define ATTR_NEVER_INLINE            __attribute__ ((noinline))
 107:../freeRTOS750/include/ringBuffer.h **** 
 108:../freeRTOS750/include/ringBuffer.h **** /** Forces the compiler to inline the specified function. When applied, the given function will be
 109:../freeRTOS750/include/ringBuffer.h ****  *  in-lined under all circumstances.
 110:../freeRTOS750/include/ringBuffer.h ****  */
 111:../freeRTOS750/include/ringBuffer.h **** #define ATTR_ALWAYS_INLINE           __attribute__ ((always_inline))
 112:../freeRTOS750/include/ringBuffer.h **** 
 113:../freeRTOS750/include/ringBuffer.h **** #if defined(__GNUC__)
 114:../freeRTOS750/include/ringBuffer.h **** 	/** Forces GCC to use pointer indirection (via the device's pointer register pairs) when accessing
 115:../freeRTOS750/include/ringBuffer.h **** 	 *  struct pointer. In some cases GCC will emit non-optimal assembly code when accessing a structu
 116:../freeRTOS750/include/ringBuffer.h **** 	 *  a pointer, resulting in a larger binary. When this macro is used on a (non \c const) structure
 117:../freeRTOS750/include/ringBuffer.h **** 	 *  use, it will force GCC to use pointer indirection on the elements rather than direct store and
 118:../freeRTOS750/include/ringBuffer.h **** 	 *  instructions.
 119:../freeRTOS750/include/ringBuffer.h **** 	 *
 120:../freeRTOS750/include/ringBuffer.h **** 	 *  \param[in, out] StructPtr  Pointer to a structure which is to be forced into indirect access m
 121:../freeRTOS750/include/ringBuffer.h **** 	 */
 122:../freeRTOS750/include/ringBuffer.h **** 	#define GCC_FORCE_POINTER_ACCESS(StructPtr)   __asm__ __volatile__("" : "=b" (StructPtr) : "0" (St
 123:../freeRTOS750/include/ringBuffer.h **** 
 124:../freeRTOS750/include/ringBuffer.h **** 	/** Forces GCC to create a memory barrier, ensuring that memory accesses are not reordered past th
 125:../freeRTOS750/include/ringBuffer.h **** 	 *  This can be used before ordering-critical operations, to ensure that the compiler does not re-
 126:../freeRTOS750/include/ringBuffer.h **** 	 *  assembly output in an unexpected manner on sections of code that are ordering-specific.
 127:../freeRTOS750/include/ringBuffer.h **** 	 */
 128:../freeRTOS750/include/ringBuffer.h **** 	#define GCC_MEMORY_BARRIER()                  __asm__ __volatile__("" ::: "memory");
 129:../freeRTOS750/include/ringBuffer.h **** 
 130:../freeRTOS750/include/ringBuffer.h **** #else
 131:../freeRTOS750/include/ringBuffer.h **** 	#define GCC_FORCE_POINTER_ACCESS(StructPtr)
 132:../freeRTOS750/include/ringBuffer.h **** 	#define GCC_MEMORY_BARRIER()
 133:../freeRTOS750/include/ringBuffer.h **** 	#define GCC_IS_COMPILE_CONST(x)               0
 134:../freeRTOS750/include/ringBuffer.h **** #endif
 135:../freeRTOS750/include/ringBuffer.h **** 
 136:../freeRTOS750/include/ringBuffer.h **** /************************** Type Defines: ***************************/
 137:../freeRTOS750/include/ringBuffer.h **** /** \brief Ring Buffer Management Structure.
 138:../freeRTOS750/include/ringBuffer.h ****  *
 139:../freeRTOS750/include/ringBuffer.h ****  *  Type define for a new ring buffer object. Buffers should be initialized via a call to
 140:../freeRTOS750/include/ringBuffer.h ****  *  \ref ringBuffer_InitBuffer() before use.
 141:../freeRTOS750/include/ringBuffer.h ****  */
 142:../freeRTOS750/include/ringBuffer.h **** typedef struct
 143:../freeRTOS750/include/ringBuffer.h **** {
 144:../freeRTOS750/include/ringBuffer.h **** 	uint16_t volatile count;	/**< Number of bytes currently stored in the buffer. */
 145:../freeRTOS750/include/ringBuffer.h **** 	uint8_t volatile * in;		/**< Current storage location in the circular buffer. */
 146:../freeRTOS750/include/ringBuffer.h **** 	uint8_t volatile * out;		/**< Current retrieval location in the circular buffer. */
 147:../freeRTOS750/include/ringBuffer.h **** 	uint8_t* start;				/**< Pointer to the start of the buffer's underlying storage array. */
 148:../freeRTOS750/include/ringBuffer.h **** 	uint8_t* end;				/**< Pointer to the end of the buffer's underlying storage array. */
 149:../freeRTOS750/include/ringBuffer.h **** 	uint16_t size;				/**< Size of the buffer's underlying storage array. */
 150:../freeRTOS750/include/ringBuffer.h **** } ringBuffer_t, * ringBufferPtr_t;
 151:../freeRTOS750/include/ringBuffer.h **** 
 152:../freeRTOS750/include/ringBuffer.h **** /************************* Inline Functions: *************************/
 153:../freeRTOS750/include/ringBuffer.h **** 
 154:../freeRTOS750/include/ringBuffer.h **** /** Initializes a ring buffer ready for use. Buffers must be initialized via this function
 155:../freeRTOS750/include/ringBuffer.h ****  *  before any operations are called upon them. Already initialized buffers may be reset
 156:../freeRTOS750/include/ringBuffer.h ****  *  by re-initializing them using this function.
 157:../freeRTOS750/include/ringBuffer.h ****  *
 158:../freeRTOS750/include/ringBuffer.h ****  *  \param[out] buffer   Pointer to a ring buffer structure to initialize.
 159:../freeRTOS750/include/ringBuffer.h ****  *  \param[out] dataPtr  Pointer to a global array that will hold the data stored into the ring buf
 160:../freeRTOS750/include/ringBuffer.h ****  *  \param[out] size     Maximum number of bytes that can be stored in the underlying data array.
 161:../freeRTOS750/include/ringBuffer.h ****  */
 162:../freeRTOS750/include/ringBuffer.h **** inline void
 163:../freeRTOS750/include/ringBuffer.h **** ringBuffer_InitBuffer(	ringBuffer_t* buffer,
 164:../freeRTOS750/include/ringBuffer.h **** 						uint8_t* const dataPtr,
 165:../freeRTOS750/include/ringBuffer.h **** 						const uint16_t size) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2) ATTR_ALWAYS_INLINE;
 166:../freeRTOS750/include/ringBuffer.h **** 
 167:../freeRTOS750/include/ringBuffer.h **** 
 168:../freeRTOS750/include/ringBuffer.h **** /** Flushes the contents of a ring buffer.
 169:../freeRTOS750/include/ringBuffer.h ****  *
 170:../freeRTOS750/include/ringBuffer.h ****  *  \param[out] buffer   Pointer to a ring buffer structure to flush out.
 171:../freeRTOS750/include/ringBuffer.h ****  */
 172:../freeRTOS750/include/ringBuffer.h **** inline void
 173:../freeRTOS750/include/ringBuffer.h **** ringBuffer_Flush(ringBuffer_t* const buffer) ATTR_NON_NULL_PTR_ARG(1) ATTR_ALWAYS_INLINE;
 174:../freeRTOS750/include/ringBuffer.h **** 
 175:../freeRTOS750/include/ringBuffer.h **** /** Retrieves the current number of bytes stored in a particular buffer. This value is computed
 176:../freeRTOS750/include/ringBuffer.h ****  *  by entering an atomic lock on the buffer, so that the buffer cannot be modified while the
 177:../freeRTOS750/include/ringBuffer.h ****  *  computation takes place. This value should be cached when reading out the contents of the buffe
 178:../freeRTOS750/include/ringBuffer.h ****  *  so that as small a time as possible is spent in an atomic lock.
 179:../freeRTOS750/include/ringBuffer.h ****  *
 180:../freeRTOS750/include/ringBuffer.h ****  *  \note The value returned by this function is guaranteed to only be the minimum number of bytes
 181:../freeRTOS750/include/ringBuffer.h ****  *        stored in the given buffer; this value may change as other threads write new data, thus
 182:../freeRTOS750/include/ringBuffer.h ****  *        the returned number should be used only to determine how many successive reads may safely
 183:../freeRTOS750/include/ringBuffer.h ****  *        be performed on the buffer.
 184:../freeRTOS750/include/ringBuffer.h ****  *
 185:../freeRTOS750/include/ringBuffer.h ****  *  \param[in] buffer  Pointer to a ring buffer structure whose count is to be computed.
 186:../freeRTOS750/include/ringBuffer.h ****  *
 187:../freeRTOS750/include/ringBuffer.h ****  *  \return Number of bytes currently stored in the buffer.
 188:../freeRTOS750/include/ringBuffer.h ****  */
 189:../freeRTOS750/include/ringBuffer.h **** inline uint16_t
 190:../freeRTOS750/include/ringBuffer.h **** ringBuffer_GetCount(ringBuffer_t* const buffer) ATTR_WARN_UNUSED_RESULT ATTR_NON_NULL_PTR_ARG(1) AT
 191:../freeRTOS750/include/ringBuffer.h **** 
 192:../freeRTOS750/include/ringBuffer.h **** /** Retrieves the free space in a particular buffer. This value is computed by entering an atomic l
 193:../freeRTOS750/include/ringBuffer.h ****  *  on the buffer, so that the buffer cannot be modified while the computation takes place.
 194:../freeRTOS750/include/ringBuffer.h ****  *
 195:../freeRTOS750/include/ringBuffer.h ****  *  \note The value returned by this function is guaranteed to only be the maximum number of bytes
 196:../freeRTOS750/include/ringBuffer.h ****  *        free in the given buffer; this value may change as other threads write new data, thus
 197:../freeRTOS750/include/ringBuffer.h ****  *        the returned number should be used only to determine how many successive writes may safel
 198:../freeRTOS750/include/ringBuffer.h ****  *        be performed on the buffer when there is a single writer thread.
 199:../freeRTOS750/include/ringBuffer.h ****  *
 200:../freeRTOS750/include/ringBuffer.h ****  *  \param[in] buffer  Pointer to a ring buffer structure whose free count is to be computed.
 201:../freeRTOS750/include/ringBuffer.h ****  *
 202:../freeRTOS750/include/ringBuffer.h ****  *  \return Number of free bytes in the buffer.
 203:../freeRTOS750/include/ringBuffer.h ****  */
 204:../freeRTOS750/include/ringBuffer.h **** inline uint16_t
 205:../freeRTOS750/include/ringBuffer.h **** ringBuffer_GetFreeCount(ringBuffer_t* const buffer) ATTR_WARN_UNUSED_RESULT ATTR_NON_NULL_PTR_ARG(1
 206:../freeRTOS750/include/ringBuffer.h **** 
 207:../freeRTOS750/include/ringBuffer.h **** /** Atomically determines if the specified ring buffer contains any data. This should
 208:../freeRTOS750/include/ringBuffer.h ****  *  be tested before removing data from the buffer, to ensure that the buffer does not
 209:../freeRTOS750/include/ringBuffer.h ****  *  underflow.
 210:../freeRTOS750/include/ringBuffer.h ****  *
 211:../freeRTOS750/include/ringBuffer.h ****  *  If the data is to be removed in a loop, store the total number of bytes stored in the
 212:../freeRTOS750/include/ringBuffer.h ****  *  buffer (via a call to the \ref ringBuffer_GetCount() function) in a temporary variable
 213:../freeRTOS750/include/ringBuffer.h ****  *  to reduce the time spent in atomicity locks.
 214:../freeRTOS750/include/ringBuffer.h ****  *
 215:../freeRTOS750/include/ringBuffer.h ****  *  \param[in,out] buffer  Pointer to a ring buffer structure to insert into.
 216:../freeRTOS750/include/ringBuffer.h ****  *
 217:../freeRTOS750/include/ringBuffer.h ****  *  \return Boolean \c true if the buffer contains no free space, \c false otherwise.
 218:../freeRTOS750/include/ringBuffer.h ****  */
 219:../freeRTOS750/include/ringBuffer.h **** inline uint8_t
 220:../freeRTOS750/include/ringBuffer.h **** ringBuffer_IsEmpty(ringBuffer_t* const buffer) ATTR_WARN_UNUSED_RESULT ATTR_NON_NULL_PTR_ARG(1) ATT
 221:../freeRTOS750/include/ringBuffer.h **** 
 222:../freeRTOS750/include/ringBuffer.h **** /** Atomically determines if the specified ring buffer contains any free space. This should
 223:../freeRTOS750/include/ringBuffer.h ****  *  be tested before storing data to the buffer, to ensure that no data is lost due to a
 224:../freeRTOS750/include/ringBuffer.h ****  *  buffer overrun.
 225:../freeRTOS750/include/ringBuffer.h ****  *
 226:../freeRTOS750/include/ringBuffer.h ****  *  \param[in,out] buffer  Pointer to a ring buffer structure to insert into.
 227:../freeRTOS750/include/ringBuffer.h ****  *
 228:../freeRTOS750/include/ringBuffer.h ****  *  \return Boolean \c true if the buffer contains no free space, \c false otherwise.
 229:../freeRTOS750/include/ringBuffer.h ****  */
 230:../freeRTOS750/include/ringBuffer.h **** inline uint8_t
 231:../freeRTOS750/include/ringBuffer.h **** ringBuffer_IsFull(ringBuffer_t* const buffer) ATTR_WARN_UNUSED_RESULT ATTR_NON_NULL_PTR_ARG(1) ATTR
 232:../freeRTOS750/include/ringBuffer.h **** 
 233:../freeRTOS750/include/ringBuffer.h **** /** Inserts an element into the ring buffer.
 234:../freeRTOS750/include/ringBuffer.h ****  *
 235:../freeRTOS750/include/ringBuffer.h ****  *  \warning Only one execution thread (main program thread or an ISR) may insert into a single buf
 236:../freeRTOS750/include/ringBuffer.h ****  *           otherwise data corruption may occur. Insertion and removal may occur from different ex
 237:../freeRTOS750/include/ringBuffer.h ****  *           threads.
 238:../freeRTOS750/include/ringBuffer.h ****  *
 239:../freeRTOS750/include/ringBuffer.h ****  *  \param[in,out] buffer  Pointer to a ring buffer structure to insert into.
 240:../freeRTOS750/include/ringBuffer.h ****  *  \param[in]     data    Data element to insert into the buffer.
 241:../freeRTOS750/include/ringBuffer.h ****  */
 242:../freeRTOS750/include/ringBuffer.h **** inline void
 243:../freeRTOS750/include/ringBuffer.h **** ringBuffer_Poke(ringBuffer_t* buffer, const uint8_t data) ATTR_NON_NULL_PTR_ARG(1) ATTR_ALWAYS_INLI
 244:../freeRTOS750/include/ringBuffer.h **** 
 245:../freeRTOS750/include/ringBuffer.h **** /** Removes an element from the ring buffer.
 246:../freeRTOS750/include/ringBuffer.h ****  *
 247:../freeRTOS750/include/ringBuffer.h ****  *  \warning Only one execution thread (main program thread or an ISR) may remove from a single buf
 248:../freeRTOS750/include/ringBuffer.h ****  *           otherwise data corruption may occur. Insertion and removal may occur from different ex
 249:../freeRTOS750/include/ringBuffer.h ****  *           threads.
 250:../freeRTOS750/include/ringBuffer.h ****  *
 251:../freeRTOS750/include/ringBuffer.h ****  *  \param[in,out] buffer  Pointer to a ring buffer structure to retrieve from.
 252:../freeRTOS750/include/ringBuffer.h ****  *
 253:../freeRTOS750/include/ringBuffer.h ****  *  \return Next data element stored in the buffer.
 254:../freeRTOS750/include/ringBuffer.h ****  */
 255:../freeRTOS750/include/ringBuffer.h **** inline uint8_t
 256:../freeRTOS750/include/ringBuffer.h **** ringBuffer_Pop(ringBuffer_t* buffer) ATTR_NON_NULL_PTR_ARG(1) ATTR_ALWAYS_INLINE;
 257:../freeRTOS750/include/ringBuffer.h **** 
 258:../freeRTOS750/include/ringBuffer.h **** /** Returns the next element stored in the ring buffer, without removing it.
 259:../freeRTOS750/include/ringBuffer.h ****  *
 260:../freeRTOS750/include/ringBuffer.h ****  *  \param[in,out] buffer  Pointer to a ring buffer structure to retrieve from.
 261:../freeRTOS750/include/ringBuffer.h ****  *
 262:../freeRTOS750/include/ringBuffer.h ****  *  \return Next data element stored in the buffer.
 263:../freeRTOS750/include/ringBuffer.h ****  */
 264:../freeRTOS750/include/ringBuffer.h **** inline uint8_t
 265:../freeRTOS750/include/ringBuffer.h **** ringBuffer_Peek(ringBuffer_t* const buffer) ATTR_WARN_UNUSED_RESULT ATTR_NON_NULL_PTR_ARG(1) ATTR_A
 266:../freeRTOS750/include/ringBuffer.h **** 
 267:../freeRTOS750/include/ringBuffer.h **** 
 268:../freeRTOS750/include/ringBuffer.h **** 
 269:../freeRTOS750/include/ringBuffer.h **** 
 270:../freeRTOS750/include/ringBuffer.h **** inline void
 271:../freeRTOS750/include/ringBuffer.h **** ringBuffer_InitBuffer(	ringBuffer_t* buffer,
 272:../freeRTOS750/include/ringBuffer.h **** 						uint8_t* const dataPtr,
 273:../freeRTOS750/include/ringBuffer.h **** 						const uint16_t size)
 274:../freeRTOS750/include/ringBuffer.h **** {
 275:../freeRTOS750/include/ringBuffer.h **** 	GCC_FORCE_POINTER_ACCESS(buffer);
 276:../freeRTOS750/include/ringBuffer.h **** 
 277:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 278:../freeRTOS750/include/ringBuffer.h **** 
 279:../freeRTOS750/include/ringBuffer.h **** 	buffer->count  = 0;
 280:../freeRTOS750/include/ringBuffer.h **** 	buffer->in     = dataPtr;
 281:../freeRTOS750/include/ringBuffer.h **** 	buffer->out    = dataPtr;
 282:../freeRTOS750/include/ringBuffer.h **** 	buffer->start  = &dataPtr[0];
 283:../freeRTOS750/include/ringBuffer.h **** 	buffer->end    = &dataPtr[size];
 284:../freeRTOS750/include/ringBuffer.h **** 	buffer->size   = size;
 285:../freeRTOS750/include/ringBuffer.h **** 
 286:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 287:../freeRTOS750/include/ringBuffer.h **** }
 288:../freeRTOS750/include/ringBuffer.h **** 
 289:../freeRTOS750/include/ringBuffer.h **** inline void
 290:../freeRTOS750/include/ringBuffer.h **** ringBuffer_Flush(ringBuffer_t* const buffer)
 291:../freeRTOS750/include/ringBuffer.h **** {
 292:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 169               	.LM4:
 170               	/* #APP */
 171               	 ;  292 "../freeRTOS750/include/ringBuffer.h" 1
 172 0016 0FB6      		in		__tmp_reg__, __SREG__
 173               	 ;  0 "" 2
 174               	 ;  292 "../freeRTOS750/include/ringBuffer.h" 1
 175 0018 F894      		cli
 176               	 ;  0 "" 2
 177               	 ;  292 "../freeRTOS750/include/ringBuffer.h" 1
 178 001a 0F92      		push	__tmp_reg__
 179               	 ;  0 "" 2
 293:../freeRTOS750/include/ringBuffer.h **** 
 294:../freeRTOS750/include/ringBuffer.h **** 	buffer->count	= 0;
 181               	.LM5:
 182               	/* #NOAPP */
 183 001c 1282      		std Z+2,__zero_reg__
 184 001e 1182      		std Z+1,__zero_reg__
 295:../freeRTOS750/include/ringBuffer.h **** 	buffer->in		= buffer->start;
 186               	.LM6:
 187 0020 8781      		ldd r24,Z+7
 188 0022 9085      		ldd r25,Z+8
 189 0024 9483      		std Z+4,r25
 190 0026 8383      		std Z+3,r24
 296:../freeRTOS750/include/ringBuffer.h **** 	buffer->out		= buffer->start;
 192               	.LM7:
 193 0028 9683      		std Z+6,r25
 194 002a 8583      		std Z+5,r24
 297:../freeRTOS750/include/ringBuffer.h **** 
 298:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 196               	.LM8:
 197               	/* #APP */
 198               	 ;  298 "../freeRTOS750/include/ringBuffer.h" 1
 199 002c 0F90      		pop		__tmp_reg__
 200               	 ;  0 "" 2
 201               	 ;  298 "../freeRTOS750/include/ringBuffer.h" 1
 202 002e 0FBE      		out		__SREG__, __tmp_reg__
 203               	 ;  0 "" 2
 204               	/* #NOAPP */
 205 0030 0895      		ret
 206               	.LBE108:
 207               	.LBE107:
 212               	.Lscope1:
 214               		.stabd	78,0,0
 217               	.global	xSerialAvailableChar
 219               	xSerialAvailableChar:
 220               		.stabd	46,0,0
 222               	.Ltext2:
 271:../freeRTOS750/lib_serial/lib_serial.c **** 		break;
 272:../freeRTOS750/lib_serial/lib_serial.c **** 
 273:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART1:
 274:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) || d
 275:../freeRTOS750/lib_serial/lib_serial.c **** 		while ( UCSR1A & (1<<RXC1) )
 276:../freeRTOS750/lib_serial/lib_serial.c **** 			byte = UDR1;
 277:../freeRTOS750/lib_serial/lib_serial.c **** 		break;
 278:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 279:../freeRTOS750/lib_serial/lib_serial.c **** 
 280:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART2:
 281:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART3:
 282:../freeRTOS750/lib_serial/lib_serial.c **** 	default:
 283:../freeRTOS750/lib_serial/lib_serial.c **** 		break;
 284:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 285:../freeRTOS750/lib_serial/lib_serial.c **** 
 286:../freeRTOS750/lib_serial/lib_serial.c **** 	ringBuffer_Flush( &(pxPort->xRxedChars) );
 287:../freeRTOS750/lib_serial/lib_serial.c **** }
 288:../freeRTOS750/lib_serial/lib_serial.c **** 
 289:../freeRTOS750/lib_serial/lib_serial.c **** inline uint16_t xSerialAvailableChar( xComPortHandlePtr pxPort )
 290:../freeRTOS750/lib_serial/lib_serial.c **** {
 224               	.LM9:
 225               	.LFBB2:
 226               	/* prologue: function */
 227               	/* frame size = 0 */
 228               	/* stack size = 0 */
 229               	.L__stack_usage = 0
 230               	.LBB109:
 231               	.LBB110:
 233               	.Ltext3:
 299:../freeRTOS750/include/ringBuffer.h **** }
 300:../freeRTOS750/include/ringBuffer.h **** 
 301:../freeRTOS750/include/ringBuffer.h **** inline uint16_t
 302:../freeRTOS750/include/ringBuffer.h **** ringBuffer_GetCount(ringBuffer_t* const buffer)
 303:../freeRTOS750/include/ringBuffer.h **** {
 304:../freeRTOS750/include/ringBuffer.h **** 	uint16_t count;
 305:../freeRTOS750/include/ringBuffer.h **** 
 306:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 235               	.LM10:
 236               	/* #APP */
 237               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 238 0032 0FB6      		in		__tmp_reg__, __SREG__
 239               	 ;  0 "" 2
 240               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 241 0034 F894      		cli
 242               	 ;  0 "" 2
 243               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 244 0036 0F92      		push	__tmp_reg__
 245               	 ;  0 "" 2
 307:../freeRTOS750/include/ringBuffer.h **** 
 308:../freeRTOS750/include/ringBuffer.h **** 	count = buffer->count;
 247               	.LM11:
 248               	/* #NOAPP */
 249 0038 FC01      		movw r30,r24
 250 003a 2181      		ldd r18,Z+1
 251 003c 3281      		ldd r19,Z+2
 309:../freeRTOS750/include/ringBuffer.h **** 
 310:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 253               	.LM12:
 254               	/* #APP */
 255               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 256 003e 0F90      		pop		__tmp_reg__
 257               	 ;  0 "" 2
 258               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 259 0040 0FBE      		out		__SREG__, __tmp_reg__
 260               	 ;  0 "" 2
 261               	/* #NOAPP */
 262               	.LBE110:
 263               	.LBE109:
 265               	.Ltext4:
 291:../freeRTOS750/lib_serial/lib_serial.c **** 	/* Are characters available in the serial port buffer.*/
 292:../freeRTOS750/lib_serial/lib_serial.c **** 
 293:../freeRTOS750/lib_serial/lib_serial.c **** 	return ringBuffer_GetCount( &(pxPort->xRxedChars) );
 294:../freeRTOS750/lib_serial/lib_serial.c **** }
 267               	.LM13:
 268 0042 C901      		movw r24,r18
 269 0044 0895      		ret
 274               	.Lscope2:
 276               		.stabd	78,0,0
 280               	.global	xSerialGetChar
 282               	xSerialGetChar:
 283               		.stabd	46,0,0
 295:../freeRTOS750/lib_serial/lib_serial.c **** 
 296:../freeRTOS750/lib_serial/lib_serial.c **** inline portBASE_TYPE xSerialGetChar( xComPortHandlePtr pxPort, unsigned portBASE_TYPE *pcRxedChar )
 297:../freeRTOS750/lib_serial/lib_serial.c **** {
 285               	.LM14:
 286               	.LFBB3:
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 0 */
 290               	.L__stack_usage = 0
 291               	.LBB111:
 292               	.LBB112:
 293               	.LBB113:
 295               	.Ltext5:
 306:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 297               	.LM15:
 298               	/* #APP */
 299               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 300 0046 0FB6      		in		__tmp_reg__, __SREG__
 301               	 ;  0 "" 2
 302               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 303 0048 F894      		cli
 304               	 ;  0 "" 2
 305               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 306 004a 0F92      		push	__tmp_reg__
 307               	 ;  0 "" 2
 308:../freeRTOS750/include/ringBuffer.h **** 	count = buffer->count;
 309               	.LM16:
 310               	/* #NOAPP */
 311 004c FC01      		movw r30,r24
 312 004e 2181      		ldd r18,Z+1
 313 0050 3281      		ldd r19,Z+2
 315               	.LM17:
 316               	/* #APP */
 317               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 318 0052 0F90      		pop		__tmp_reg__
 319               	 ;  0 "" 2
 320               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 321 0054 0FBE      		out		__SREG__, __tmp_reg__
 322               	 ;  0 "" 2
 323               	/* #NOAPP */
 324               	.LBE113:
 325               	.LBE112:
 326               	.LBE111:
 328               	.Ltext6:
 298:../freeRTOS750/lib_serial/lib_serial.c **** 	/* Get the next character from the ring buffer.  Return false if no characters are available */
 299:../freeRTOS750/lib_serial/lib_serial.c **** 
 300:../freeRTOS750/lib_serial/lib_serial.c **** 	if( ringBuffer_IsEmpty( &(pxPort->xRxedChars) ) )
 330               	.LM18:
 331 0056 232B      		or r18,r19
 332 0058 01F0      		breq .L13
 301:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 302:../freeRTOS750/lib_serial/lib_serial.c **** 		return pdFALSE;
 303:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 304:../freeRTOS750/lib_serial/lib_serial.c **** 	else
 305:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 306:../freeRTOS750/lib_serial/lib_serial.c **** 		* pcRxedChar = ringBuffer_Pop( &(pxPort->xRxedChars) );
 334               	.LM19:
 335 005a FC01      		movw r30,r24
 336 005c 3196      		adiw r30,1
 337               	.LBB114:
 338               	.LBB115:
 340               	.Ltext7:
 311:../freeRTOS750/include/ringBuffer.h **** 	return count;
 312:../freeRTOS750/include/ringBuffer.h **** }
 313:../freeRTOS750/include/ringBuffer.h **** 
 314:../freeRTOS750/include/ringBuffer.h **** inline uint16_t
 315:../freeRTOS750/include/ringBuffer.h **** ringBuffer_GetFreeCount(ringBuffer_t* const buffer)
 316:../freeRTOS750/include/ringBuffer.h **** {
 317:../freeRTOS750/include/ringBuffer.h **** 	return (buffer->size - ringBuffer_GetCount(buffer));
 318:../freeRTOS750/include/ringBuffer.h **** }
 319:../freeRTOS750/include/ringBuffer.h **** 
 320:../freeRTOS750/include/ringBuffer.h **** inline uint8_t
 321:../freeRTOS750/include/ringBuffer.h **** ringBuffer_IsEmpty(ringBuffer_t* const buffer)
 322:../freeRTOS750/include/ringBuffer.h **** {
 323:../freeRTOS750/include/ringBuffer.h **** 	return (ringBuffer_GetCount(buffer) == 0);
 324:../freeRTOS750/include/ringBuffer.h **** }
 325:../freeRTOS750/include/ringBuffer.h **** 
 326:../freeRTOS750/include/ringBuffer.h **** inline uint8_t
 327:../freeRTOS750/include/ringBuffer.h **** ringBuffer_IsFull(ringBuffer_t* const buffer)
 328:../freeRTOS750/include/ringBuffer.h **** {
 329:../freeRTOS750/include/ringBuffer.h **** 	return (ringBuffer_GetCount(buffer) == buffer->size);
 330:../freeRTOS750/include/ringBuffer.h **** }
 331:../freeRTOS750/include/ringBuffer.h **** 
 332:../freeRTOS750/include/ringBuffer.h **** inline void
 333:../freeRTOS750/include/ringBuffer.h **** ringBuffer_Poke(ringBuffer_t* buffer, const uint8_t data)
 334:../freeRTOS750/include/ringBuffer.h **** {
 335:../freeRTOS750/include/ringBuffer.h **** 	GCC_FORCE_POINTER_ACCESS(buffer);
 336:../freeRTOS750/include/ringBuffer.h **** 
 337:../freeRTOS750/include/ringBuffer.h **** 	*buffer->in = data;
 338:../freeRTOS750/include/ringBuffer.h **** 
 339:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 340:../freeRTOS750/include/ringBuffer.h **** 
 341:../freeRTOS750/include/ringBuffer.h **** 	if (++buffer->in == buffer->end)
 342:../freeRTOS750/include/ringBuffer.h **** 	  buffer->in = buffer->start;
 343:../freeRTOS750/include/ringBuffer.h **** 
 344:../freeRTOS750/include/ringBuffer.h **** 	buffer->count++;
 345:../freeRTOS750/include/ringBuffer.h **** 
 346:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 347:../freeRTOS750/include/ringBuffer.h **** }
 348:../freeRTOS750/include/ringBuffer.h **** 
 349:../freeRTOS750/include/ringBuffer.h **** inline uint8_t
 350:../freeRTOS750/include/ringBuffer.h **** ringBuffer_Pop(ringBuffer_t* buffer)
 351:../freeRTOS750/include/ringBuffer.h **** {
 352:../freeRTOS750/include/ringBuffer.h **** 	GCC_FORCE_POINTER_ACCESS(buffer);
 342               	.LM20:
 353:../freeRTOS750/include/ringBuffer.h **** 
 354:../freeRTOS750/include/ringBuffer.h **** 	uint8_t data = *buffer->out;
 344               	.LM21:
 345 005e A481      		ldd r26,Z+4
 346 0060 B581      		ldd r27,Z+5
 347 0062 2D91      		ld r18,X+
 355:../freeRTOS750/include/ringBuffer.h **** 
 356:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 349               	.LM22:
 350               	/* #APP */
 351               	 ;  356 "../freeRTOS750/include/ringBuffer.h" 1
 352 0064 0FB6      		in		__tmp_reg__, __SREG__
 353               	 ;  0 "" 2
 354               	 ;  356 "../freeRTOS750/include/ringBuffer.h" 1
 355 0066 F894      		cli
 356               	 ;  0 "" 2
 357               	 ;  356 "../freeRTOS750/include/ringBuffer.h" 1
 358 0068 0F92      		push	__tmp_reg__
 359               	 ;  0 "" 2
 357:../freeRTOS750/include/ringBuffer.h **** 
 358:../freeRTOS750/include/ringBuffer.h **** 	if (++buffer->out == buffer->end)
 361               	.LM23:
 362               	/* #NOAPP */
 363 006a B583      		std Z+5,r27
 364 006c A483      		std Z+4,r26
 365 006e 8085      		ldd r24,Z+8
 366 0070 9185      		ldd r25,Z+9
 367 0072 A817      		cp r26,r24
 368 0074 B907      		cpc r27,r25
 369 0076 01F4      		brne .L12
 359:../freeRTOS750/include/ringBuffer.h **** 	  buffer->out = buffer->start;
 371               	.LM24:
 372 0078 8681      		ldd r24,Z+6
 373 007a 9781      		ldd r25,Z+7
 374 007c 9583      		std Z+5,r25
 375 007e 8483      		std Z+4,r24
 376               	.L12:
 360:../freeRTOS750/include/ringBuffer.h **** 
 361:../freeRTOS750/include/ringBuffer.h **** 	buffer->count--;
 378               	.LM25:
 379 0080 8081      		ld r24,Z
 380 0082 9181      		ldd r25,Z+1
 381 0084 0197      		sbiw r24,1
 382 0086 9183      		std Z+1,r25
 383 0088 8083      		st Z,r24
 362:../freeRTOS750/include/ringBuffer.h **** 
 363:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 385               	.LM26:
 386               	/* #APP */
 387               	 ;  363 "../freeRTOS750/include/ringBuffer.h" 1
 388 008a 0F90      		pop		__tmp_reg__
 389               	 ;  0 "" 2
 390               	 ;  363 "../freeRTOS750/include/ringBuffer.h" 1
 391 008c 0FBE      		out		__SREG__, __tmp_reg__
 392               	 ;  0 "" 2
 393               	/* #NOAPP */
 394               	.LBE115:
 395               	.LBE114:
 397               	.Ltext8:
 399               	.LM27:
 400 008e FB01      		movw r30,r22
 401 0090 2083      		st Z,r18
 307:../freeRTOS750/lib_serial/lib_serial.c **** 		return pdTRUE;
 403               	.LM28:
 404 0092 81E0      		ldi r24,lo8(1)
 405 0094 0895      		ret
 406               	.L13:
 302:../freeRTOS750/lib_serial/lib_serial.c **** 		return pdFALSE;
 408               	.LM29:
 409 0096 80E0      		ldi r24,0
 308:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 309:../freeRTOS750/lib_serial/lib_serial.c **** }
 411               	.LM30:
 412 0098 0895      		ret
 423               	.Lscope3:
 425               		.stabd	78,0,0
 429               	.global	xSerialPutChar
 431               	xSerialPutChar:
 432               		.stabd	46,0,0
 310:../freeRTOS750/lib_serial/lib_serial.c **** 
 311:../freeRTOS750/lib_serial/lib_serial.c **** inline portBASE_TYPE xSerialPutChar( xComPortHandlePtr pxPort, unsigned const portBASE_TYPE cOutCha
 312:../freeRTOS750/lib_serial/lib_serial.c **** {
 434               	.LM31:
 435               	.LFBB4:
 436 009a CF93      		push r28
 437 009c DF93      		push r29
 438               	/* prologue: function */
 439               	/* frame size = 0 */
 440               	/* stack size = 2 */
 441               	.L__stack_usage = 2
 442 009e DC01      		movw r26,r24
 443               	.LBB159:
 444               	.LBB160:
 445               	.LBB161:
 446               	.LBB162:
 448               	.Ltext9:
 306:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 450               	.LM32:
 451               	/* #APP */
 452               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 453 00a0 0FB6      		in		__tmp_reg__, __SREG__
 454               	 ;  0 "" 2
 455               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 456 00a2 F894      		cli
 457               	 ;  0 "" 2
 458               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 459 00a4 0F92      		push	__tmp_reg__
 460               	 ;  0 "" 2
 308:../freeRTOS750/include/ringBuffer.h **** 	count = buffer->count;
 462               	.LM33:
 463               	/* #NOAPP */
 464 00a6 1D96      		adiw r26,13
 465 00a8 2D91      		ld r18,X+
 466 00aa 3C91      		ld r19,X
 467 00ac 1E97      		sbiw r26,13+1
 310:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 469               	.LM34:
 470               	/* #APP */
 471               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 472 00ae 0F90      		pop		__tmp_reg__
 473               	 ;  0 "" 2
 474               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 475 00b0 0FBE      		out		__SREG__, __tmp_reg__
 476               	 ;  0 "" 2
 477               	/* #NOAPP */
 478               	.LBE162:
 479               	.LBE161:
 480               	.LBE160:
 481               	.LBE159:
 483               	.Ltext10:
 313:../freeRTOS750/lib_serial/lib_serial.c **** 	/* Return false if there remains no room on the Tx ring buffer */
 314:../freeRTOS750/lib_serial/lib_serial.c **** 
 315:../freeRTOS750/lib_serial/lib_serial.c **** 	if( ! ringBuffer_IsFull( &(pxPort->xCharsForTx) ) )
 485               	.LM35:
 486 00b2 5796      		adiw r26,23
 487 00b4 8D91      		ld r24,X+
 488 00b6 9C91      		ld r25,X
 489 00b8 5897      		sbiw r26,23+1
 490 00ba 2817      		cp r18,r24
 491 00bc 3907      		cpc r19,r25
 492 00be 01F0      		breq .L15
 493 00c0 00C0      		rjmp .L26
 494               	.L15:
 495               	.LBB163:
 496               	.LBB164:
 498               	.Ltext11:
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 166:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #else
 167:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	{
 172:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		{
 176:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		}
 180:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	}
 182:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else
 183:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 186:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** }
 187:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 188:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 189:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 191:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 193:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 196:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 198:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 202:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   
 207:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 211:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  
 214:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 222:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 223:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 224:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 226:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 235:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 238:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 241:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 246:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 500               	.LM36:
 501 00c2 88E0      		ldi r24,lo8(8)
 502 00c4 8A95      		1: dec r24
 503 00c6 01F4      		brne 1b
 504 00c8 0000      		nop
 505               	.LBE164:
 506               	.LBE163:
 507               	.LBB165:
 508               	.LBB166:
 509 00ca 88E0      		ldi r24,lo8(8)
 510 00cc 8A95      		1: dec r24
 511 00ce 01F4      		brne 1b
 512 00d0 0000      		nop
 513               	.LBE166:
 514               	.LBE165:
 515               	.LBB167:
 516               	.LBB168:
 517 00d2 88E0      		ldi r24,lo8(8)
 518 00d4 8A95      		1: dec r24
 519 00d6 01F4      		brne 1b
 520 00d8 0000      		nop
 521               	.LBE168:
 522               	.LBE167:
 523               	.LBB169:
 524               	.LBB170:
 525 00da 88E0      		ldi r24,lo8(8)
 526 00dc 8A95      		1: dec r24
 527 00de 01F4      		brne 1b
 528 00e0 0000      		nop
 529               	.LBE170:
 530               	.LBE169:
 531               	.LBB171:
 532               	.LBB172:
 533               	.LBB173:
 534               	.LBB174:
 536               	.Ltext12:
 306:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 538               	.LM37:
 539               	/* #APP */
 540               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 541 00e2 0FB6      		in		__tmp_reg__, __SREG__
 542               	 ;  0 "" 2
 543               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 544 00e4 F894      		cli
 545               	 ;  0 "" 2
 546               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 547 00e6 0F92      		push	__tmp_reg__
 548               	 ;  0 "" 2
 308:../freeRTOS750/include/ringBuffer.h **** 	count = buffer->count;
 550               	.LM38:
 551               	/* #NOAPP */
 552 00e8 1D96      		adiw r26,13
 553 00ea 2D91      		ld r18,X+
 554 00ec 3C91      		ld r19,X
 555 00ee 1E97      		sbiw r26,13+1
 310:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 557               	.LM39:
 558               	/* #APP */
 559               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 560 00f0 0F90      		pop		__tmp_reg__
 561               	 ;  0 "" 2
 562               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 563 00f2 0FBE      		out		__SREG__, __tmp_reg__
 564               	 ;  0 "" 2
 565               	/* #NOAPP */
 566               	.LBE174:
 567               	.LBE173:
 568               	.LBE172:
 569               	.LBE171:
 571               	.Ltext13:
 316:../freeRTOS750/lib_serial/lib_serial.c **** 		ringBuffer_Poke( &(pxPort->xCharsForTx), cOutChar ); // poke in a fast byte
 317:../freeRTOS750/lib_serial/lib_serial.c **** 	else
 318:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 319:../freeRTOS750/lib_serial/lib_serial.c **** 		 // go slower, per character rate for 115200 is 86us
 320:../freeRTOS750/lib_serial/lib_serial.c **** 		_delay_us(25); // delay for about one character (maximum _delay_loop_1() delay is 32 us at 22MHz)
 321:../freeRTOS750/lib_serial/lib_serial.c **** 		_delay_us(25);
 322:../freeRTOS750/lib_serial/lib_serial.c **** 		_delay_us(25);
 323:../freeRTOS750/lib_serial/lib_serial.c **** 		_delay_us(25);
 324:../freeRTOS750/lib_serial/lib_serial.c **** 
 325:../freeRTOS750/lib_serial/lib_serial.c **** 		if( ! ringBuffer_IsFull( &(pxPort->xCharsForTx) ) )
 573               	.LM40:
 574 00f4 5796      		adiw r26,23
 575 00f6 8D91      		ld r24,X+
 576 00f8 9C91      		ld r25,X
 577 00fa 5897      		sbiw r26,23+1
 578 00fc 2817      		cp r18,r24
 579 00fe 3907      		cpc r19,r25
 580 0100 01F0      		breq .L21
 581               	.L26:
 326:../freeRTOS750/lib_serial/lib_serial.c **** 			ringBuffer_Poke( &(pxPort->xCharsForTx), cOutChar ); // poke in a byte slowly
 583               	.LM41:
 584 0102 FD01      		movw r30,r26
 585 0104 3D96      		adiw r30,13
 586               	.LBB175:
 587               	.LBB176:
 589               	.Ltext14:
 335:../freeRTOS750/include/ringBuffer.h **** 	GCC_FORCE_POINTER_ACCESS(buffer);
 591               	.LM42:
 337:../freeRTOS750/include/ringBuffer.h **** 	*buffer->in = data;
 593               	.LM43:
 594 0106 C281      		ldd r28,Z+2
 595 0108 D381      		ldd r29,Z+3
 596 010a 6883      		st Y,r22
 339:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 598               	.LM44:
 599               	/* #APP */
 600               	 ;  339 "../freeRTOS750/include/ringBuffer.h" 1
 601 010c 0FB6      		in		__tmp_reg__, __SREG__
 602               	 ;  0 "" 2
 603               	 ;  339 "../freeRTOS750/include/ringBuffer.h" 1
 604 010e F894      		cli
 605               	 ;  0 "" 2
 606               	 ;  339 "../freeRTOS750/include/ringBuffer.h" 1
 607 0110 0F92      		push	__tmp_reg__
 608               	 ;  0 "" 2
 341:../freeRTOS750/include/ringBuffer.h **** 	if (++buffer->in == buffer->end)
 610               	.LM45:
 611               	/* #NOAPP */
 612 0112 8281      		ldd r24,Z+2
 613 0114 9381      		ldd r25,Z+3
 614 0116 0196      		adiw r24,1
 615 0118 9383      		std Z+3,r25
 616 011a 8283      		std Z+2,r24
 617 011c 2085      		ldd r18,Z+8
 618 011e 3185      		ldd r19,Z+9
 619 0120 8217      		cp r24,r18
 620 0122 9307      		cpc r25,r19
 621 0124 01F4      		brne .L19
 342:../freeRTOS750/include/ringBuffer.h **** 	  buffer->in = buffer->start;
 623               	.LM46:
 624 0126 8681      		ldd r24,Z+6
 625 0128 9781      		ldd r25,Z+7
 626 012a 9383      		std Z+3,r25
 627 012c 8283      		std Z+2,r24
 628               	.L19:
 344:../freeRTOS750/include/ringBuffer.h **** 	buffer->count++;
 630               	.LM47:
 631 012e 8081      		ld r24,Z
 632 0130 9181      		ldd r25,Z+1
 633 0132 0196      		adiw r24,1
 634 0134 9183      		std Z+1,r25
 635 0136 8083      		st Z,r24
 346:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 637               	.LM48:
 638               	/* #APP */
 639               	 ;  346 "../freeRTOS750/include/ringBuffer.h" 1
 640 0138 0F90      		pop		__tmp_reg__
 641               	 ;  0 "" 2
 642               	 ;  346 "../freeRTOS750/include/ringBuffer.h" 1
 643 013a 0FBE      		out		__SREG__, __tmp_reg__
 644               	 ;  0 "" 2
 645               	/* #NOAPP */
 646               	.LBE176:
 647               	.LBE175:
 649               	.Ltext15:
 327:../freeRTOS750/lib_serial/lib_serial.c **** 		else
 328:../freeRTOS750/lib_serial/lib_serial.c **** 			return pdFAIL; // if the Tx ring buffer remains full
 329:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 330:../freeRTOS750/lib_serial/lib_serial.c **** 
 331:../freeRTOS750/lib_serial/lib_serial.c **** 	switch (pxPort->usart)
 651               	.LM49:
 652 013c 8C91      		ld r24,X
 653 013e 8111      		cpse r24,__zero_reg__
 654 0140 00C0      		rjmp .L23
 655               	.LBB177:
 656               	.LBB178:
 657               	.LBB179:
 332:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 333:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART0:
 334:../freeRTOS750/lib_serial/lib_serial.c **** 		vInterrupt0_On();
 659               	.LM50:
 660 0142 8091 C100 		lds r24,193
 661 0146 8062      		ori r24,lo8(32)
 662 0148 8093 C100 		sts 193,r24
 663 014c 00C0      		rjmp .L23
 664               	.L21:
 665               	.LBE179:
 666               	.LBE178:
 667               	.LBE177:
 328:../freeRTOS750/lib_serial/lib_serial.c **** 			return pdFAIL; // if the Tx ring buffer remains full
 669               	.LM51:
 670 014e 80E0      		ldi r24,0
 671 0150 00C0      		rjmp .L18
 672               	.L23:
 335:../freeRTOS750/lib_serial/lib_serial.c **** 		break;
 336:../freeRTOS750/lib_serial/lib_serial.c **** 
 337:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART1:
 338:../freeRTOS750/lib_serial/lib_serial.c **** 		vInterrupt1_On();
 339:../freeRTOS750/lib_serial/lib_serial.c **** 		break;
 340:../freeRTOS750/lib_serial/lib_serial.c **** 
 341:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART2:
 342:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART3:
 343:../freeRTOS750/lib_serial/lib_serial.c **** 	default:
 344:../freeRTOS750/lib_serial/lib_serial.c **** 		break;
 345:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 346:../freeRTOS750/lib_serial/lib_serial.c **** 
 347:../freeRTOS750/lib_serial/lib_serial.c **** 	return pdPASS;
 674               	.LM52:
 675 0152 81E0      		ldi r24,lo8(1)
 676               	.L18:
 677               	/* epilogue start */
 348:../freeRTOS750/lib_serial/lib_serial.c **** }
 679               	.LM53:
 680 0154 DF91      		pop r29
 681 0156 CF91      		pop r28
 682 0158 0895      		ret
 693               	.Lscope4:
 695               		.stabd	78,0,0
 699               	.global	xSerialxPrint_P
 701               	xSerialxPrint_P:
 702               		.stabd	46,0,0
 249:../freeRTOS750/lib_serial/lib_serial.c **** {
 704               	.LM54:
 705               	.LFBB5:
 706 015a CF92      		push r12
 707 015c DF92      		push r13
 708 015e EF92      		push r14
 709 0160 FF92      		push r15
 710 0162 0F93      		push r16
 711 0164 1F93      		push r17
 712 0166 CF93      		push r28
 713 0168 DF93      		push r29
 714               	/* prologue: function */
 715               	/* frame size = 0 */
 716               	/* stack size = 8 */
 717               	.L__stack_usage = 8
 718 016a 7C01      		movw r14,r24
 719 016c 8B01      		movw r16,r22
 720               	.LBB180:
 721               	.LBB181:
 723               	.Ltext16:
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /* Copyright (c) 2002-2007  Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Copyright (c) 2006, Carlos Lamas
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Copyright (c) 2009-2010, Jan Waclawek
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      distribution.
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   POSSIBILITY OF SUCH DAMAGE. */
  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /* $Id: pgmspace.h 2270 2011-12-29 08:42:00Z joerg_wunsch $ */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /*
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    pgmspace.h
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Contributors:
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      Created by Marek Michalkiewicz <marekm@linux.org.pl>
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      Eric B. Weddington <eric@ecentral.com>
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      Wolfgang Haidinger <wh@vmars.tuwien.ac.at> (pgm_read_dword())
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      Ivanov Anton <anton@arc.com.ru> (pgm_read_float())
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****  */
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \file */
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \defgroup avr_pgmspace <avr/pgmspace.h>: Program Space Utilities
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \code
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     #include <avr/io.h>
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     #include <avr/pgmspace.h>
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \endcode
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The functions in this module provide interfaces for a program to access
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     data stored in program space (flash memory) of the device.  In order to
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     use these functions, the target device must support either the \c LPM or
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \c ELPM instructions.
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note These functions are an attempt to provide some compatibility with
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     header files that come with IAR C, to make porting applications between
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     different compilers easier.  This is not 100% compatibility though (GCC
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     does not have full support for multiple address spaces yet).
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note If you are working with strings which are completely based in ram,
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     use the standard string functions described in \ref avr_string.
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note If possible, put your constant tables in the lower 64 KB and use
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     pgm_read_byte_near() or pgm_read_word_near() instead of
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     pgm_read_byte_far() or pgm_read_word_far() since it is more efficient that
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     way, and you can still use the upper 64K for executable code.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     All functions that are suffixed with a \c _P \e require their
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     arguments to be in the lower 64 KB of the flash ROM, as they do
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     not use ELPM instructions.  This is normally not a big concern as
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     the linker setup arranges any program space constants declared
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     using the macros from this header file so they are placed right after
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     the interrupt vectors, and in front of any executable code.  However,
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     it can become a problem if there are too many of these constants, or
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     for bootloaders on devices with more than 64 KB of ROM.
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     <em>All these functions will not work in that situation.</em>
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note For <b>Xmega</b> devices, make sure the NVM controller
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     command register (\c NVM.CMD or \c NVM_CMD) is set to 0x00 (NOP)
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     before using any of these functions.
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifndef __PGMSPACE_H_
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __PGMSPACE_H_ 1
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __need_size_t
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #include <inttypes.h>
  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #include <stddef.h>
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #include <avr/io.h>
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifndef __ATTR_CONST__
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ATTR_CONST__ __attribute__((__const__))
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifndef __ATTR_PROGMEM__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ATTR_PROGMEM__ __attribute__((__progmem__))
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifndef __ATTR_PURE__
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ATTR_PURE__ __attribute__((__pure__))
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \def PROGMEM
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Attribute to use in order to declare an object being located in
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    flash ROM.
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****  */
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define PROGMEM __ATTR_PROGMEM__
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifdef __cplusplus
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern "C" {
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #if defined(__DOXYGEN__)
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /*
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****  * Doxygen doesn't grok the appended attribute syntax of
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****  * GCC, and confuses the typedefs with function decls, so
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****  * supply a doxygen-friendly view.
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****  */
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_void
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of a "void" object located in flash ROM.  Does not make much
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    sense by itself, but can be used to declare a "void *" object in
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    flash ROM.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef void PROGMEM prog_void;
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_char
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of a "char" object located in flash ROM.
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef char PROGMEM prog_char;
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_uchar
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 165:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 166:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 167:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 168:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 169:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 170:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 171:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 172:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 173:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 174:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of an "unsigned char" object located in flash ROM.
 175:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 176:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef unsigned char PROGMEM prog_uchar;
 177:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 178:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 179:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 180:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_int8_t
 181:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 182:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 183:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 184:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 185:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 186:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 187:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 188:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 189:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 190:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 191:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 192:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of an "int8_t" object located in flash ROM.
 193:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 194:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef int8_t PROGMEM prog_int8_t;
 195:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 196:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 197:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 198:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_uint8_t
 199:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 200:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 201:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 202:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 203:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 204:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 205:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 206:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 207:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 208:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 209:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 210:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of an "uint8_t" object located in flash ROM.
 211:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 212:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef uint8_t PROGMEM prog_uint8_t;
 213:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 214:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 215:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 216:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_int16_t
 217:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 218:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 219:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 220:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 221:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 222:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 223:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 224:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 225:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 226:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 227:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 228:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of an "int16_t" object located in flash ROM.
 229:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 230:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef int16_t PROGMEM prog_int16_t;
 231:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 232:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 233:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 234:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_uint16_t
 235:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 236:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 237:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 238:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 239:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 240:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 241:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 242:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 243:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 244:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 245:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 246:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of an "uint16_t" object located in flash ROM.
 247:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 248:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef uint16_t PROGMEM prog_uint16_t;
 249:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 250:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 251:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 252:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_int32_t
 253:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 254:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 255:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 256:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 257:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 258:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 259:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 260:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 261:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 262:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 263:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 264:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of an "int32_t" object located in flash ROM.
 265:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 266:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef int32_t PROGMEM prog_int32_t;
 267:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 268:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 269:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 270:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_uint32_t
 271:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 272:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 273:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 274:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 275:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 276:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 277:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 278:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 279:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 280:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 281:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 282:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of an "uint32_t" object located in flash ROM.
 283:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 284:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef uint32_t PROGMEM prog_uint32_t;
 285:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 286:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 287:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 288:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_int64_t
 289:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 290:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 291:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 292:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 293:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 294:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 295:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 296:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 297:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 298:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 299:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 300:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of an "int64_t" object located in flash ROM.
 301:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 302:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note This type is not available when the compiler
 303:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    option -mint8 is in effect.
 304:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 305:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef int64_t PROGMEM prog_int64_t;
 306:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 307:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /**
 308:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \ingroup avr_pgmspace
 309:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \typedef prog_uint64_t
 310:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note DEPRECATED
 311:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 312:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This typedef is now deprecated because the usage of the __progmem__ 
 313:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    attribute on a type is not supported in GCC. However, the use of the 
 314:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    __progmem__ attribute on a variable declaration is supported, and this is 
 315:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    now the recommended usage.
 316:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 317:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    The typedef is only visible if the macro __PROG_TYPES_COMPAT__
 318:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    has been defined before including <avr/pgmspace.h> (either by a
 319:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    #define directive, or by a -D compiler option.)
 320:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 321:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Type of an "uint64_t" object located in flash ROM.
 322:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 323:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    \note This type is not available when the compiler
 324:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    option -mint8 is in effect.
 325:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 326:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef uint64_t PROGMEM prog_uint64_t;
 327:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 328:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 329:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def PGM_P
 330:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 331:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Used to declare a variable that is a pointer to a string in program
 332:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     space. */
 333:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 334:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifndef PGM_P
 335:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define PGM_P const char *
 336:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
 337:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 338:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 339:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def PGM_VOID_P
 340:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 341:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Used to declare a generic pointer to an object in program space. */
 342:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 343:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifndef PGM_VOID_P
 344:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define PGM_VOID_P const void *
 345:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
 346:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 347:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #elif defined(__PROG_TYPES_COMPAT__)  /* !DOXYGEN */
 348:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 349:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef void prog_void __attribute__((__progmem__,deprecated("prog_void type is deprecated.")));
 350:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef char prog_char __attribute__((__progmem__,deprecated("prog_char type is deprecated.")));
 351:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef unsigned char prog_uchar __attribute__((__progmem__,deprecated("prog_uchar type is deprecat
 352:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef int8_t    prog_int8_t   __attribute__((__progmem__,deprecated("prog_int8_t type is deprecat
 353:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef uint8_t   prog_uint8_t  __attribute__((__progmem__,deprecated("prog_uint8_t type is depreca
 354:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef int16_t   prog_int16_t  __attribute__((__progmem__,deprecated("prog_int16_t type is depreca
 355:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef uint16_t  prog_uint16_t __attribute__((__progmem__,deprecated("prog_uint16_t type is deprec
 356:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef int32_t   prog_int32_t  __attribute__((__progmem__,deprecated("prog_int32_t type is depreca
 357:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef uint32_t  prog_uint32_t __attribute__((__progmem__,deprecated("prog_uint32_t type is deprec
 358:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #if !__USING_MINT8
 359:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef int64_t   prog_int64_t  __attribute__((__progmem__,deprecated("prog_int64_t type is depreca
 360:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** typedef uint64_t  prog_uint64_t __attribute__((__progmem__,deprecated("prog_uint64_t type is deprec
 361:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
 362:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 363:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifndef PGM_P
 364:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define PGM_P const prog_char *
 365:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
 366:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 367:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifndef PGM_VOID_P
 368:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define PGM_VOID_P const prog_void *
 369:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
 370:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 371:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #else /* !defined(__DOXYGEN__), !defined(__PROG_TYPES_COMPAT__) */
 372:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 373:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifndef PGM_P
 374:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define PGM_P const char *
 375:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
 376:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 377:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #ifndef PGM_VOID_P
 378:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define PGM_VOID_P const void *
 379:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
 380:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif /* defined(__DOXYGEN__), defined(__PROG_TYPES_COMPAT__) */
 381:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 382:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /* Although in C, we can get away with just using __c, it does not work in
 383:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    C++. We need to use &__c[0] to avoid the compiler puking. Dave Hylands
 384:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    explaned it thusly,
 385:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 386:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      Let's suppose that we use PSTR("Test"). In this case, the type returned
 387:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      by __c is a prog_char[5] and not a prog_char *. While these are
 388:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      compatible, they aren't the same thing (especially in C++). The type
 389:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      returned by &__c[0] is a prog_char *, which explains why it works
 390:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      fine. */
 391:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 392:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #if defined(__DOXYGEN__)
 393:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /*
 394:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****  * The #define below is just a dummy that serves documentation
 395:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****  * purposes only.
 396:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****  */
 397:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 398:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def PSTR(s)
 399:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 400:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Used to declare a static pointer to a string in program space. */
 401:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** # define PSTR(s) ((const PROGMEM char *)(s))
 402:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #else  /* !DOXYGEN */
 403:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /* The real thing. */
 404:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** # define PSTR(s) (__extension__({static const char __c[] PROGMEM = (s); &__c[0];}))
 405:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif /* DOXYGEN */
 406:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 407:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_classic__(addr)   \
 408:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                \
 409:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __addr16 = (uint16_t)(addr); \
 410:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint8_t __result;           \
 411:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                     \
 412:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                           \
 413:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm" "\n\t"            \
 414:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %0, r0" "\n\t"     \
 415:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)       \
 416:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "z" (__addr16)        \
 417:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r0"                  \
 418:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                          \
 419:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                   \
 420:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 421:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 422:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_enhanced__(addr)  \
 423:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                \
 424:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __addr16 = (uint16_t)(addr); \
 425:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint8_t __result;           \
 426:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                     \
 427:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                           \
 428:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %0, Z" "\n\t"      \
 429:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)       \
 430:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "z" (__addr16)        \
 431:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                          \
 432:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                   \
 433:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 434:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 435:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_word_classic__(addr)          \
 436:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                            \
 437:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __addr16 = (uint16_t)(addr);   \
 438:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __result;                      \
 439:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                                 \
 440:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                       \
 441:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm"           "\n\t"              \
 442:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %A0, r0"   "\n\t"              \
 443:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"   "\n\t"              \
 444:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm"           "\n\t"              \
 445:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %B0, r0"   "\n\t"              \
 446:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result), "=z" (__addr16)  \
 447:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "1" (__addr16)                    \
 448:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r0"                              \
 449:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                      \
 450:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                               \
 451:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 452:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 453:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_word_enhanced__(addr)         \
 454:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                            \
 455:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __addr16 = (uint16_t)(addr);   \
 456:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __result;                      \
 457:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                                 \
 458:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                       \
 459:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %A0, Z+"   "\n\t"              \
 460:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %B0, Z"    "\n\t"              \
 461:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result), "=z" (__addr16)  \
 462:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "1" (__addr16)                    \
 463:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                      \
 464:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                               \
 465:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 466:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 467:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_dword_classic__(addr)         \
 468:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                            \
 469:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __addr16 = (uint16_t)(addr);   \
 470:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __result;                      \
 471:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                                 \
 472:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                       \
 473:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm"           "\n\t"              \
 474:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %A0, r0"   "\n\t"              \
 475:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"   "\n\t"              \
 476:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm"           "\n\t"              \
 477:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %B0, r0"   "\n\t"              \
 478:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"   "\n\t"              \
 479:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm"           "\n\t"              \
 480:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %C0, r0"   "\n\t"              \
 481:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"   "\n\t"              \
 482:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm"           "\n\t"              \
 483:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %D0, r0"   "\n\t"              \
 484:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result), "=z" (__addr16)  \
 485:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "1" (__addr16)                    \
 486:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r0"                              \
 487:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                      \
 488:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                               \
 489:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 490:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 491:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_dword_enhanced__(addr)        \
 492:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                            \
 493:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __addr16 = (uint16_t)(addr);   \
 494:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __result;                      \
 495:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                                 \
 496:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                       \
 497:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %A0, Z+"   "\n\t"              \
 498:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %B0, Z+"   "\n\t"              \
 499:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %C0, Z+"   "\n\t"              \
 500:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %D0, Z"    "\n\t"              \
 501:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result), "=z" (__addr16)  \
 502:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "1" (__addr16)                    \
 503:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                      \
 504:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                               \
 505:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 506:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 507:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_float_classic__(addr)         \
 508:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                            \
 509:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __addr16 = (uint16_t)(addr);   \
 510:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     float __result;                         \
 511:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                                 \
 512:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                       \
 513:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm"           "\n\t"              \
 514:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %A0, r0"   "\n\t"              \
 515:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"   "\n\t"              \
 516:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm"           "\n\t"              \
 517:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %B0, r0"   "\n\t"              \
 518:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"   "\n\t"              \
 519:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm"           "\n\t"              \
 520:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %C0, r0"   "\n\t"              \
 521:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"   "\n\t"              \
 522:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm"           "\n\t"              \
 523:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %D0, r0"   "\n\t"              \
 524:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result), "=z" (__addr16)  \
 525:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "1" (__addr16)                    \
 526:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r0"                              \
 527:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                      \
 528:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                               \
 529:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 530:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 531:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_float_enhanced__(addr)        \
 532:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                            \
 533:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __addr16 = (uint16_t)(addr);   \
 534:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     float __result;                         \
 535:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                                 \
 536:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                       \
 537:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %A0, Z+"   "\n\t"              \
 538:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %B0, Z+"   "\n\t"              \
 539:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %C0, Z+"   "\n\t"              \
 540:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "lpm %D0, Z"    "\n\t"              \
 541:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result), "=z" (__addr16)  \
 542:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "1" (__addr16)                    \
 543:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                      \
 544:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                               \
 545:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 546:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 547:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #if defined (__AVR_HAVE_LPMX__)
 548:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM(addr)         __LPM_enhanced__(addr)
 549:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_word(addr)    __LPM_word_enhanced__(addr)
 550:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_dword(addr)   __LPM_dword_enhanced__(addr)
 551:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_float(addr)   __LPM_float_enhanced__(addr)
 552:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #else
 553:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM(addr)         __LPM_classic__(addr)
 554:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_word(addr)    __LPM_word_classic__(addr)
 555:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_dword(addr)   __LPM_dword_classic__(addr)
 556:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __LPM_float(addr)   __LPM_float_classic__(addr)
 557:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif
 558:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 559:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 560:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_byte_near(address_short)
 561:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a byte from the program space with a 16-bit (near) address. 
 562:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address.
 563:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 564:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 565:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_byte_near(address_short) __LPM((uint16_t)(address_short))
 566:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 567:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 568:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_word_near(address_short)
 569:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a word from the program space with a 16-bit (near) address. 
 570:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address. 
 571:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 572:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 573:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_word_near(address_short) __LPM_word((uint16_t)(address_short))
 574:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 575:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 576:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_dword_near(address_short)
 577:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a double word from the program space with a 16-bit (near) address. 
 578:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address. 
 579:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 580:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 581:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_dword_near(address_short) \
 582:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __LPM_dword((uint16_t)(address_short))
 583:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 584:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 585:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_float_near(address_short)
 586:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a float from the program space with a 16-bit (near) address. 
 587:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address. 
 588:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 589:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 590:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_float_near(address_short) \
 591:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __LPM_float((uint16_t)(address_short))
 592:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 593:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #if defined(RAMPZ) || defined(__DOXYGEN__)
 594:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 595:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /* Only for devices with more than 64K of program memory.
 596:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    RAMPZ must be defined (see iom103.h, iom128.h).
 597:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 598:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 599:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /* The classic functions are needed for ATmega103. */
 600:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 601:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_classic__(addr)      \
 602:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                    \
 603:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 604:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint8_t __result;               \
 605:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                         \
 606:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                               \
 607:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1" "\n\t"        \
 608:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov r31, %B1" "\n\t"       \
 609:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov r30, %A1" "\n\t"       \
 610:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm" "\n\t"               \
 611:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %0, r0" "\n\t"         \
 612:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)           \
 613:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),           \
 614:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ)) \
 615:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r0", "r30", "r31"        \
 616:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                              \
 617:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                       \
 618:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 619:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 620:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_enhanced__(addr)     \
 621:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                    \
 622:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 623:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint8_t __result;               \
 624:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                         \
 625:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                               \
 626:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1" "\n\t"        \
 627:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "movw r30, %1" "\n\t"       \
 628:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %0, Z+" "\n\t"        \
 629:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)           \
 630:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),           \
 631:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ)) \
 632:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r30", "r31"              \
 633:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                              \
 634:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                       \
 635:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 636:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 637:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_xmega__(addr)        \
 638:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                    \
 639:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 640:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint8_t __result;               \
 641:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                         \
 642:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                               \
 643:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in __tmp_reg__, %2" "\n\t" \
 644:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1" "\n\t"        \
 645:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "movw r30, %1" "\n\t"       \
 646:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %0, Z+" "\n\t"        \
 647:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, __tmp_reg__"       \
 648:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)           \
 649:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),           \
 650:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ)) \
 651:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r30", "r31"              \
 652:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                              \
 653:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                       \
 654:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 655:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 656:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_word_classic__(addr)     \
 657:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                        \
 658:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 659:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __result;                  \
 660:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                             \
 661:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                   \
 662:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1"   "\n\t"          \
 663:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov r31, %B1"  "\n\t"          \
 664:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov r30, %A1"  "\n\t"          \
 665:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm"          "\n\t"          \
 666:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %A0, r0"   "\n\t"          \
 667:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in r0, %2"     "\n\t"          \
 668:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"   "\n\t"          \
 669:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adc r0, __zero_reg__" "\n\t"   \
 670:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, r0"    "\n\t"          \
 671:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm"          "\n\t"          \
 672:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %B0, r0"   "\n\t"          \
 673:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)               \
 674:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),               \
 675:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ))     \
 676:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r0", "r30", "r31"            \
 677:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                  \
 678:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                           \
 679:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 680:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 681:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_word_enhanced__(addr)    \
 682:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                        \
 683:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 684:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __result;                  \
 685:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                             \
 686:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                   \
 687:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1"   "\n\t"          \
 688:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "movw r30, %1"  "\n\t"          \
 689:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %A0, Z+"  "\n\t"          \
 690:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %B0, Z"   "\n\t"          \
 691:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)               \
 692:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),               \
 693:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ))     \
 694:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r30", "r31"                  \
 695:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                  \
 696:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                           \
 697:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 698:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 699:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_word_xmega__(addr)       \
 700:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                        \
 701:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 702:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint16_t __result;                  \
 703:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                             \
 704:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                   \
 705:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in __tmp_reg__, %2" "\n\t"     \
 706:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1"   "\n\t"          \
 707:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "movw r30, %1"  "\n\t"          \
 708:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %A0, Z+"  "\n\t"          \
 709:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %B0, Z"   "\n\t"          \
 710:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, __tmp_reg__"           \
 711:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)               \
 712:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),               \
 713:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ))     \
 714:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r30", "r31"                  \
 715:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                  \
 716:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                           \
 717:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 718:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 719:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_dword_classic__(addr)      \
 720:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                          \
 721:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 722:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __result;                    \
 723:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                               \
 724:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                     \
 725:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1"          "\n\t"     \
 726:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov r31, %B1"         "\n\t"     \
 727:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov r30, %A1"         "\n\t"     \
 728:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm"                 "\n\t"     \
 729:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %A0, r0"          "\n\t"     \
 730:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in r0, %2"            "\n\t"     \
 731:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"          "\n\t"     \
 732:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adc r0, __zero_reg__" "\n\t"     \
 733:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, r0"           "\n\t"     \
 734:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm"                 "\n\t"     \
 735:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %B0, r0"          "\n\t"     \
 736:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in r0, %2"            "\n\t"     \
 737:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"          "\n\t"     \
 738:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adc r0, __zero_reg__" "\n\t"     \
 739:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, r0"           "\n\t"     \
 740:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm"                 "\n\t"     \
 741:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %C0, r0"          "\n\t"     \
 742:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in r0, %2"            "\n\t"     \
 743:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"          "\n\t"     \
 744:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adc r0, __zero_reg__" "\n\t"     \
 745:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, r0"           "\n\t"     \
 746:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm"                 "\n\t"     \
 747:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %D0, r0"          "\n\t"     \
 748:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)                 \
 749:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),                 \
 750:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ))       \
 751:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r0", "r30", "r31"              \
 752:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                    \
 753:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                             \
 754:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 755:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 756:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_dword_enhanced__(addr)     \
 757:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                          \
 758:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 759:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __result;                    \
 760:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                               \
 761:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                     \
 762:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1"   "\n\t"            \
 763:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "movw r30, %1"  "\n\t"            \
 764:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %A0, Z+"  "\n\t"            \
 765:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %B0, Z+"  "\n\t"            \
 766:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %C0, Z+"  "\n\t"            \
 767:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %D0, Z"   "\n\t"            \
 768:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)                 \
 769:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),                 \
 770:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ))       \
 771:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r30", "r31"                    \
 772:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                    \
 773:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                             \
 774:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 775:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 776:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_dword_xmega__(addr)        \
 777:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                          \
 778:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 779:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __result;                    \
 780:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                               \
 781:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                     \
 782:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in __tmp_reg__, %2" "\n\t"       \
 783:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1"   "\n\t"            \
 784:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "movw r30, %1"  "\n\t"            \
 785:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %A0, Z+"  "\n\t"            \
 786:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %B0, Z+"  "\n\t"            \
 787:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %C0, Z+"  "\n\t"            \
 788:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %D0, Z"   "\n\t"            \
 789:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, __tmp_reg__"             \
 790:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)                 \
 791:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),                 \
 792:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ))       \
 793:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r30", "r31"                    \
 794:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                    \
 795:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                             \
 796:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 797:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 798:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_float_classic__(addr)      \
 799:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                          \
 800:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 801:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     float __result;                       \
 802:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                               \
 803:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                     \
 804:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1"          "\n\t"     \
 805:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov r31, %B1"         "\n\t"     \
 806:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov r30, %A1"         "\n\t"     \
 807:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm"                 "\n\t"     \
 808:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %A0, r0"          "\n\t"     \
 809:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in r0, %2"            "\n\t"     \
 810:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"          "\n\t"     \
 811:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adc r0, __zero_reg__" "\n\t"     \
 812:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, r0"           "\n\t"     \
 813:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm"                 "\n\t"     \
 814:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %B0, r0"          "\n\t"     \
 815:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in r0, %2"            "\n\t"     \
 816:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"          "\n\t"     \
 817:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adc r0, __zero_reg__" "\n\t"     \
 818:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, r0"           "\n\t"     \
 819:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm"                 "\n\t"     \
 820:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %C0, r0"          "\n\t"     \
 821:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in r0, %2"            "\n\t"     \
 822:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adiw r30, 1"          "\n\t"     \
 823:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "adc r0, __zero_reg__" "\n\t"     \
 824:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, r0"           "\n\t"     \
 825:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm"                 "\n\t"     \
 826:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "mov %D0, r0"          "\n\t"     \
 827:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)                 \
 828:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),                 \
 829:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ))       \
 830:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r0", "r30", "r31"              \
 831:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                    \
 832:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                             \
 833:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 834:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 835:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_float_enhanced__(addr)     \
 836:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                          \
 837:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 838:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     float __result;                       \
 839:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                               \
 840:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                     \
 841:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1"   "\n\t"            \
 842:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "movw r30, %1"  "\n\t"            \
 843:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %A0, Z+"  "\n\t"            \
 844:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %B0, Z+"  "\n\t"            \
 845:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %C0, Z+"  "\n\t"            \
 846:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %D0, Z"   "\n\t"            \
 847:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)                 \
 848:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),                 \
 849:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ))       \
 850:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r30", "r31"                    \
 851:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                    \
 852:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                             \
 853:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 854:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 855:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_float_xmega__(addr)        \
 856:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** (__extension__({                          \
 857:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     uint32_t __addr32 = (uint32_t)(addr); \
 858:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     float __result;                       \
 859:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __asm__                               \
 860:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     (                                     \
 861:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "in __tmp_reg__, %2" "\n\t"       \
 862:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, %C1"   "\n\t"            \
 863:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "movw r30, %1"  "\n\t"            \
 864:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %A0, Z+"  "\n\t"            \
 865:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %B0, Z+"  "\n\t"            \
 866:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %C0, Z+"  "\n\t"            \
 867:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "elpm %D0, Z"   "\n\t"            \
 868:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         "out %2, __tmp_reg__"             \
 869:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "=r" (__result)                 \
 870:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r" (__addr32),                 \
 871:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****           "I" (_SFR_IO_ADDR(RAMPZ))       \
 872:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****         : "r30", "r31"                    \
 873:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     );                                    \
 874:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     __result;                             \
 875:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** }))
 876:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 877:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /* 
 878:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** Check for architectures that implement RAMPD (avrxmega3, avrxmega5, 
 879:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** avrxmega7) as they need to save/restore RAMPZ for ELPM macros so it does
 880:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** not interfere with data accesses. 
 881:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
 882:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #if defined (__AVR_HAVE_RAMPD__)
 883:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 884:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM(addr)        __ELPM_xmega__(addr)
 885:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_word(addr)   __ELPM_word_xmega__(addr)
 886:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_dword(addr)  __ELPM_dword_xmega__(addr)
 887:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_float(addr)  __ELPM_float_xmega__(addr)
 888:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 889:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #else
 890:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 891:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #if defined (__AVR_HAVE_LPMX__)
 892:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 893:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM(addr)        __ELPM_enhanced__(addr)
 894:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_word(addr)   __ELPM_word_enhanced__(addr)
 895:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_dword(addr)  __ELPM_dword_enhanced__(addr)
 896:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_float(addr)  __ELPM_float_enhanced__(addr)
 897:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 898:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #else
 899:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 900:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM(addr)        __ELPM_classic__(addr)
 901:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_word(addr)   __ELPM_word_classic__(addr)
 902:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_dword(addr)  __ELPM_dword_classic__(addr)
 903:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define __ELPM_float(addr)  __ELPM_float_classic__(addr)
 904:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 905:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif  /* __AVR_HAVE_LPMX__ */
 906:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 907:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif  /* __AVR_HAVE_RAMPD__ */
 908:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 909:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 910:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 911:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_byte_far(address_long)
 912:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a byte from the program space with a 32-bit (far) address. 
 913:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 914:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address. 
 915:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 916:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 917:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_byte_far(address_long)  __ELPM((uint32_t)(address_long))
 918:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 919:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 920:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_word_far(address_long)
 921:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a word from the program space with a 32-bit (far) address. 
 922:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 923:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address.
 924:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 925:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 926:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_word_far(address_long)  __ELPM_word((uint32_t)(address_long))
 927:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 928:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 929:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_dword_far(address_long)
 930:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a double word from the program space with a 32-bit (far) address. 
 931:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 932:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address.
 933:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 934:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 935:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_dword_far(address_long) __ELPM_dword((uint32_t)(address_long))
 936:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 937:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 938:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_float_far(address_long)
 939:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a float from the program space with a 32-bit (far) address. 
 940:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 941:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address.
 942:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 943:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 944:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_float_far(address_long) __ELPM_float((uint32_t)(address_long))
 945:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 946:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #endif /* RAMPZ or __DOXYGEN__ */
 947:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 948:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 949:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_byte(address_short)
 950:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a byte from the program space with a 16-bit (near) address. 
 951:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 952:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address. 
 953:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 954:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 955:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_byte(address_short)    pgm_read_byte_near(address_short)
 956:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 957:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 958:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_word(address_short)
 959:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a word from the program space with a 16-bit (near) address. 
 960:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 961:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address. 
 962:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 963:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 964:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_word(address_short)    pgm_read_word_near(address_short)
 965:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 966:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 967:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_dword(address_short)
 968:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a double word from the program space with a 16-bit (near) address. 
 969:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 970:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address. 
 971:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 972:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 973:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_dword(address_short)   pgm_read_dword_near(address_short)
 974:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 975:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /** \ingroup avr_pgmspace
 976:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \def pgm_read_float(address_short)
 977:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     Read a float from the program space with a 16-bit (near) address. 
 978:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 979:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     \note The address is a byte address. 
 980:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****     The address is in the program space. */
 981:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 982:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_read_float(address_short)   pgm_read_float_near(address_short)
 983:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 984:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** /* pgm_get_far_address() macro
 985:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 986:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    This macro facilitates the obtention of a 32 bit "far" pointer (only 24 bits
 987:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    used) to data even passed the 64KB limit for the 16 bit ordinary pointer. It
 988:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    is similar to the '&' operator, with some limitations.
 989:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 990:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    Comments:
 991:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 992:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    - The overhead is minimal and it's mainly due to the 32 bit size operation.
 993:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 994:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    - 24 bit sizes guarantees the code compatibility for use in future devices.
 995:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
 996:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    - hh8() is an undocumented feature but seems to give the third significant byte
 997:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      of a 32 bit data and accepts symbols, complementing the functionality of hi8()
 998:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      and lo8(). There is not an equivalent assembler function to get the high
 999:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      significant byte.
1000:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
1001:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    - 'var' has to be resolved at linking time as an existing symbol, i.e, a simple
1002:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      type variable name, an array name (not an indexed element of the array, if the
1003:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      index is a constant the compiler does not complain but fails to get the address
1004:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      if optimization is enabled), a struct name or a struct field name, a function
1005:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      identifier, a linker defined identifier,...
1006:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
1007:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****    - The returned value is the identifier's VMA (virtual memory address) determined
1008:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      by the linker and falls in the corresponding memory region. The AVR Harvard
1009:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      architecture requires non overlapping VMA areas for the multiple address spaces
1010:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      in the processor: Flash ROM, RAM, and EEPROM. Typical offset for this are
1011:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      0x00000000, 0x00800xx0, and 0x00810000 respectively, derived from the linker
1012:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 	 script used and linker options. The value returned can be seen then as a
1013:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      universal pointer.
1014:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
1015:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** */
1016:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
1017:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** #define pgm_get_far_address(var)                          \
1018:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** ({                                                    \
1019:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 	uint_farptr_t tmp;                                \
1020:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****                                                       \
1021:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 	__asm__ __volatile__(                             \
1022:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****                                                       \
1023:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 			"ldi	%A0, lo8(%1)"           "\n\t"    \
1024:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 			"ldi	%B0, hi8(%1)"           "\n\t"    \
1025:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 			"ldi	%C0, hh8(%1)"           "\n\t"    \
1026:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 			"clr	%D0"                    "\n\t"    \
1027:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 		:                                             \
1028:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 			"=d" (tmp)                                \
1029:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 		:                                             \
1030:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 			"p"  (&(var))                             \
1031:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 	);                                                \
1032:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 	tmp;                                              \
1033:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** })
1034:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
1035:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
1036:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
1037:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern const void * memchr_P(const void *, int __val, size_t __len) __ATTR_CONST__;
1038:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern int memcmp_P(const void *, const void *, size_t) __ATTR_PURE__;
1039:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern void *memccpy_P(void *, const void *, int __val, size_t);
1040:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern void *memcpy_P(void *, const void *, size_t);
1041:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern void *memmem_P(const void *, size_t, const void *, size_t) __ATTR_PURE__;
1042:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern const void * memrchr_P(const void *, int __val, size_t __len) __ATTR_CONST__;
1043:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strcat_P(char *, const char *);
1044:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern const char * strchr_P(const char *, int __val) __ATTR_CONST__;
1045:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern const char * strchrnul_P(const char *, int __val) __ATTR_CONST__;
1046:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern int strcmp_P(const char *, const char *) __ATTR_PURE__;
1047:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strcpy_P(char *, const char *);
1048:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern int strcasecmp_P(const char *, const char *) __ATTR_PURE__;
1049:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strcasestr_P(const char *, const char *) __ATTR_PURE__;
1050:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern size_t strcspn_P(const char *__s, const char * __reject) __ATTR_PURE__;
1051:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern size_t strlcat_P (char *, const char *, size_t );
1052:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern size_t strlcpy_P (char *, const char *, size_t );
1053:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern size_t __strlen_P(const char *) __ATTR_CONST__;  /* program memory can't change */
1054:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern size_t strnlen_P(const char *, size_t) __ATTR_CONST__; /* program memory can't change */
1055:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern int strncmp_P(const char *, const char *, size_t) __ATTR_PURE__;
1056:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern int strncasecmp_P(const char *, const char *, size_t) __ATTR_PURE__;
1057:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strncat_P(char *, const char *, size_t);
1058:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strncpy_P(char *, const char *, size_t);
1059:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strpbrk_P(const char *__s, const char * __accept) __ATTR_PURE__;
1060:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern const char * strrchr_P(const char *, int __val) __ATTR_CONST__;
1061:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strsep_P(char **__sp, const char * __delim);
1062:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern size_t strspn_P(const char *__s, const char * __accept) __ATTR_PURE__;
1063:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strstr_P(const char *, const char *) __ATTR_PURE__;
1064:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strtok_P(char *__s, const char * __delim);
1065:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strtok_rP(char *__s, const char * __delim, char **__last);
1066:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
1067:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern size_t strlen_PF (uint_farptr_t src) __ATTR_CONST__; /* program memory can't change */
1068:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern size_t strnlen_PF (uint_farptr_t src, size_t len) __ATTR_CONST__; /* program memory can't ch
1069:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern void *memcpy_PF (void *dest, uint_farptr_t src, size_t len);
1070:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strcpy_PF (char *dest, uint_farptr_t src);
1071:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strncpy_PF (char *dest, uint_farptr_t src, size_t len);
1072:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strcat_PF (char *dest, uint_farptr_t src);
1073:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern size_t strlcat_PF (char *dst, uint_farptr_t src, size_t siz);
1074:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strncat_PF (char *dest, uint_farptr_t src, size_t len);
1075:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern int strcmp_PF (const char *s1, uint_farptr_t s2) __ATTR_PURE__;
1076:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern int strncmp_PF (const char *s1, uint_farptr_t s2, size_t n) __ATTR_PURE__;
1077:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern int strcasecmp_PF (const char *s1, uint_farptr_t s2) __ATTR_PURE__;
1078:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern int strncasecmp_PF (const char *s1, uint_farptr_t s2, size_t n) __ATTR_PURE__;
1079:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern char *strstr_PF (const char *s1, uint_farptr_t s2);
1080:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern size_t strlcpy_PF (char *dst, uint_farptr_t src, size_t siz);
1081:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** extern int memcmp_PF(const void *, uint_farptr_t, size_t) __ATTR_PURE__;
1082:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
1083:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** 
1084:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** __attribute__((__always_inline__)) static inline size_t strlen_P(const char * s);
1085:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h **** static inline size_t strlen_P(const char *s) {
1086:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****   return __builtin_constant_p(__builtin_strlen(s))
1087:/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/pgmspace.h ****      ? __builtin_strlen(s) : __strlen_P(s);
 725               	.LM55:
 726 016e CB01      		movw r24,r22
 727 0170 0E94 0000 		call __strlen_P
 728 0174 6C01      		movw r12,r24
 729               	.LBE181:
 730               	.LBE180:
 732               	.Ltext17:
 250:../freeRTOS750/lib_serial/lib_serial.c **** 	uint16_t i = 0;
 734               	.LM56:
 735 0176 C0E0      		ldi r28,0
 736 0178 D0E0      		ldi r29,0
 255:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 738               	.LM57:
 739 017a 00C0      		rjmp .L28
 740               	.L29:
 248:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialxPrint_P( xComPortHandlePtr pxPort, PGM_P str)
 742               	.LM58:
 743 017c F801      		movw r30,r16
 744 017e EC0F      		add r30,r28
 745 0180 FD1F      		adc r31,r29
 746               	.LBB182:
 256:../freeRTOS750/lib_serial/lib_serial.c **** 		xSerialPutChar( pxPort, pgm_read_byte(&str[i++]) );
 748               	.LM59:
 749 0182 2196      		adiw r28,1
 750               	/* #APP */
 751               	 ;  256 "../freeRTOS750/lib_serial/lib_serial.c" 1
 752 0184 6491      		lpm r22, Z
 753               		
 754               	 ;  0 "" 2
 755               	/* #NOAPP */
 756               	.LBE182:
 757 0186 C701      		movw r24,r14
 758 0188 0E94 0000 		call xSerialPutChar
 759               	.L28:
 255:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 761               	.LM60:
 762 018c CC15      		cp r28,r12
 763 018e DD05      		cpc r29,r13
 764 0190 01F4      		brne .L29
 765               	/* epilogue start */
 257:../freeRTOS750/lib_serial/lib_serial.c **** }
 767               	.LM61:
 768 0192 DF91      		pop r29
 769 0194 CF91      		pop r28
 770 0196 1F91      		pop r17
 771 0198 0F91      		pop r16
 772 019a FF90      		pop r15
 773 019c EF90      		pop r14
 774 019e DF90      		pop r13
 775 01a0 CF90      		pop r12
 776 01a2 0895      		ret
 782               	.Lscope5:
 784               		.stabd	78,0,0
 787               	.global	xSerialxPrint
 789               	xSerialxPrint:
 790               		.stabd	46,0,0
 238:../freeRTOS750/lib_serial/lib_serial.c **** {
 792               	.LM62:
 793               	.LFBB6:
 794 01a4 EF92      		push r14
 795 01a6 FF92      		push r15
 796 01a8 0F93      		push r16
 797 01aa 1F93      		push r17
 798 01ac CF93      		push r28
 799 01ae DF93      		push r29
 800               	/* prologue: function */
 801               	/* frame size = 0 */
 802               	/* stack size = 6 */
 803               	.L__stack_usage = 6
 804 01b0 7C01      		movw r14,r24
 242:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen((char *)str);
 806               	.LM63:
 807 01b2 EB01      		movw r28,r22
 808               		0:
 809 01b4 0990      		ld __tmp_reg__,Y+
 810 01b6 0020      		tst __tmp_reg__
 811 01b8 01F4      		brne 0b
 812 01ba 2197      		sbiw r28,1
 813 01bc C61B      		sub r28,r22
 814 01be D70B      		sbc r29,r23
 815 01c0 8B01      		movw r16,r22
 237:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialxPrint( xComPortHandlePtr pxPort, uint8_t * str)
 817               	.LM64:
 818 01c2 C60F      		add r28,r22
 819 01c4 D71F      		adc r29,r23
 244:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 821               	.LM65:
 822 01c6 00C0      		rjmp .L31
 823               	.L32:
 245:../freeRTOS750/lib_serial/lib_serial.c **** 		xSerialPutChar( pxPort, str[i++]);
 825               	.LM66:
 826 01c8 F801      		movw r30,r16
 827 01ca 6191      		ld r22,Z+
 828 01cc 8F01      		movw r16,r30
 829 01ce C701      		movw r24,r14
 830 01d0 0E94 0000 		call xSerialPutChar
 831               	.L31:
 244:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 833               	.LM67:
 834 01d4 0C17      		cp r16,r28
 835 01d6 1D07      		cpc r17,r29
 836 01d8 01F4      		brne .L32
 837               	/* epilogue start */
 246:../freeRTOS750/lib_serial/lib_serial.c **** }
 839               	.LM68:
 840 01da DF91      		pop r29
 841 01dc CF91      		pop r28
 842 01de 1F91      		pop r17
 843 01e0 0F91      		pop r16
 844 01e2 FF90      		pop r15
 845 01e4 EF90      		pop r14
 846 01e6 0895      		ret
 848               	.Lscope6:
 850               		.stabd	78,0,0
 854               	.global	xSerialxPrintf_P
 856               	xSerialxPrintf_P:
 857               		.stabd	46,0,0
 221:../freeRTOS750/lib_serial/lib_serial.c **** {
 859               	.LM69:
 860               	.LFBB7:
 861 01e8 0F93      		push r16
 862 01ea 1F93      		push r17
 863 01ec CF93      		push r28
 864 01ee DF93      		push r29
 865 01f0 00D0      		rcall .
 866 01f2 CDB7      		in r28,__SP_L__
 867 01f4 DEB7      		in r29,__SP_H__
 868               	/* prologue: function */
 869               	/* frame size = 2 */
 870               	/* stack size = 6 */
 871               	.L__stack_usage = 6
 872 01f6 0985      		ldd r16,Y+9
 873 01f8 1A85      		ldd r17,Y+10
 224:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 875               	.LM70:
 876 01fa CE01      		movw r24,r28
 877 01fc 0D96      		adiw r24,13
 878 01fe 9C01      		movw r18,r24
 226:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) taskYIELD();
 880               	.LM71:
 881 0200 00C0      		rjmp .L34
 882               	.L35:
 226:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) taskYIELD();
 884               	.LM72:
 885 0202 2983      		std Y+1,r18
 886 0204 3A83      		std Y+2,r19
 887 0206 0E94 0000 		call vPortYield
 888 020a 3A81      		ldd r19,Y+2
 889 020c 2981      		ldd r18,Y+1
 890               	.L34:
 226:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) taskYIELD();
 892               	.LM73:
 893 020e F801      		movw r30,r16
 894 0210 858D      		ldd r24,Z+29
 895 0212 8130      		cpi r24,lo8(1)
 896 0214 01F0      		breq .L35
 227:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = ENGAGED;
 898               	.LM74:
 899 0216 81E0      		ldi r24,lo8(1)
 900 0218 858F      		std Z+29,r24
 229:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf_P((char *)(pxPort->serialWorkBuffer), pxPort->serialWorkBufferSize, format, arg);
 902               	.LM75:
 903 021a 638D      		ldd r22,Z+27
 904 021c 748D      		ldd r23,Z+28
 905 021e 4B85      		ldd r20,Y+11
 906 0220 5C85      		ldd r21,Y+12
 907 0222 818D      		ldd r24,Z+25
 908 0224 928D      		ldd r25,Z+26
 909 0226 0E94 0000 		call vsnprintf_P
 230:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialxPrint(pxPort, (uint8_t *)(pxPort->serialWorkBuffer));
 911               	.LM76:
 912 022a F801      		movw r30,r16
 913 022c 618D      		ldd r22,Z+25
 914 022e 728D      		ldd r23,Z+26
 915 0230 C801      		movw r24,r16
 916 0232 0E94 0000 		call xSerialxPrint
 232:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = VACANT;
 918               	.LM77:
 919 0236 F801      		movw r30,r16
 920 0238 158E      		std Z+29,__zero_reg__
 921               	/* epilogue start */
 235:../freeRTOS750/lib_serial/lib_serial.c **** }
 923               	.LM78:
 924 023a 0F90      		pop __tmp_reg__
 925 023c 0F90      		pop __tmp_reg__
 926 023e DF91      		pop r29
 927 0240 CF91      		pop r28
 928 0242 1F91      		pop r17
 929 0244 0F91      		pop r16
 930 0246 0895      		ret
 933               	.Lscope7:
 935               		.stabd	78,0,0
 939               	.global	xSerialxPrintf
 941               	xSerialxPrintf:
 942               		.stabd	46,0,0
 204:../freeRTOS750/lib_serial/lib_serial.c **** {
 944               	.LM79:
 945               	.LFBB8:
 946 0248 0F93      		push r16
 947 024a 1F93      		push r17
 948 024c CF93      		push r28
 949 024e DF93      		push r29
 950 0250 00D0      		rcall .
 951 0252 CDB7      		in r28,__SP_L__
 952 0254 DEB7      		in r29,__SP_H__
 953               	/* prologue: function */
 954               	/* frame size = 2 */
 955               	/* stack size = 6 */
 956               	.L__stack_usage = 6
 957 0256 0985      		ldd r16,Y+9
 958 0258 1A85      		ldd r17,Y+10
 207:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 960               	.LM80:
 961 025a CE01      		movw r24,r28
 962 025c 0D96      		adiw r24,13
 963 025e 9C01      		movw r18,r24
 209:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) taskYIELD();
 965               	.LM81:
 966 0260 00C0      		rjmp .L37
 967               	.L38:
 209:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) taskYIELD();
 969               	.LM82:
 970 0262 2983      		std Y+1,r18
 971 0264 3A83      		std Y+2,r19
 972 0266 0E94 0000 		call vPortYield
 973 026a 3A81      		ldd r19,Y+2
 974 026c 2981      		ldd r18,Y+1
 975               	.L37:
 209:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) taskYIELD();
 977               	.LM83:
 978 026e F801      		movw r30,r16
 979 0270 858D      		ldd r24,Z+29
 980 0272 8130      		cpi r24,lo8(1)
 981 0274 01F0      		breq .L38
 210:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = ENGAGED;
 983               	.LM84:
 984 0276 81E0      		ldi r24,lo8(1)
 985 0278 858F      		std Z+29,r24
 212:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf((char *)(pxPort->serialWorkBuffer), pxPort->serialWorkBufferSize, (const char *)format, 
 987               	.LM85:
 988 027a 638D      		ldd r22,Z+27
 989 027c 748D      		ldd r23,Z+28
 990 027e 4B85      		ldd r20,Y+11
 991 0280 5C85      		ldd r21,Y+12
 992 0282 818D      		ldd r24,Z+25
 993 0284 928D      		ldd r25,Z+26
 994 0286 0E94 0000 		call vsnprintf
 213:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialxPrint(pxPort, (uint8_t *)(pxPort->serialWorkBuffer));
 996               	.LM86:
 997 028a F801      		movw r30,r16
 998 028c 618D      		ldd r22,Z+25
 999 028e 728D      		ldd r23,Z+26
 1000 0290 C801      		movw r24,r16
 1001 0292 0E94 0000 		call xSerialxPrint
 215:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = VACANT;
 1003               	.LM87:
 1004 0296 F801      		movw r30,r16
 1005 0298 158E      		std Z+29,__zero_reg__
 1006               	/* epilogue start */
 218:../freeRTOS750/lib_serial/lib_serial.c **** }
 1008               	.LM88:
 1009 029a 0F90      		pop __tmp_reg__
 1010 029c 0F90      		pop __tmp_reg__
 1011 029e DF91      		pop r29
 1012 02a0 CF91      		pop r28
 1013 02a2 1F91      		pop r17
 1014 02a4 0F91      		pop r16
 1015 02a6 0895      		ret
 1018               	.Lscope8:
 1020               		.stabd	78,0,0
 1023               	.global	xSerialPrint_P
 1025               	xSerialPrint_P:
 1026               		.stabd	46,0,0
 189:../freeRTOS750/lib_serial/lib_serial.c **** {
 1028               	.LM89:
 1029               	.LFBB9:
 1030 02a8 EF92      		push r14
 1031 02aa FF92      		push r15
 1032 02ac 0F93      		push r16
 1033 02ae 1F93      		push r17
 1034 02b0 CF93      		push r28
 1035 02b2 DF93      		push r29
 1036               	/* prologue: function */
 1037               	/* frame size = 0 */
 1038               	/* stack size = 6 */
 1039               	.L__stack_usage = 6
 1040 02b4 8C01      		movw r16,r24
 1041               	.LBB183:
 1042               	.LBB184:
 1044               	.Ltext18:
 1046               	.LM90:
 1047 02b6 0E94 0000 		call __strlen_P
 1048 02ba 7C01      		movw r14,r24
 1049               	.LBE184:
 1050               	.LBE183:
 1052               	.Ltext19:
 190:../freeRTOS750/lib_serial/lib_serial.c **** 	uint16_t i = 0;
 1054               	.LM91:
 1055 02bc C0E0      		ldi r28,0
 1056 02be D0E0      		ldi r29,0
 195:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 1058               	.LM92:
 1059 02c0 00C0      		rjmp .L40
 1060               	.L41:
 188:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialPrint_P(PGM_P str)
 1062               	.LM93:
 1063 02c2 F801      		movw r30,r16
 1064 02c4 EC0F      		add r30,r28
 1065 02c6 FD1F      		adc r31,r29
 1066               	.LBB185:
 196:../freeRTOS750/lib_serial/lib_serial.c **** 		xSerialPutChar( &xSerialPort, pgm_read_byte(&str[i++]) );
 1068               	.LM94:
 1069 02c8 2196      		adiw r28,1
 1070               	/* #APP */
 1071               	 ;  196 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1072 02ca 6491      		lpm r22, Z
 1073               		
 1074               	 ;  0 "" 2
 1075               	/* #NOAPP */
 1076               	.LBE185:
 1077 02cc 80E0      		ldi r24,lo8(xSerialPort)
 1078 02ce 90E0      		ldi r25,hi8(xSerialPort)
 1079 02d0 0E94 0000 		call xSerialPutChar
 1080               	.L40:
 195:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 1082               	.LM95:
 1083 02d4 CE15      		cp r28,r14
 1084 02d6 DF05      		cpc r29,r15
 1085 02d8 01F4      		brne .L41
 1086               	/* epilogue start */
 197:../freeRTOS750/lib_serial/lib_serial.c **** }
 1088               	.LM96:
 1089 02da DF91      		pop r29
 1090 02dc CF91      		pop r28
 1091 02de 1F91      		pop r17
 1092 02e0 0F91      		pop r16
 1093 02e2 FF90      		pop r15
 1094 02e4 EF90      		pop r14
 1095 02e6 0895      		ret
 1101               	.Lscope9:
 1103               		.stabd	78,0,0
 1105               	.global	xSerialPrint
 1107               	xSerialPrint:
 1108               		.stabd	46,0,0
 178:../freeRTOS750/lib_serial/lib_serial.c **** {
 1110               	.LM97:
 1111               	.LFBB10:
 1112 02e8 0F93      		push r16
 1113 02ea 1F93      		push r17
 1114 02ec CF93      		push r28
 1115 02ee DF93      		push r29
 1116               	/* prologue: function */
 1117               	/* frame size = 0 */
 1118               	/* stack size = 4 */
 1119               	.L__stack_usage = 4
 182:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen((char *)str);
 1121               	.LM98:
 1122 02f0 EC01      		movw r28,r24
 1123               		0:
 1124 02f2 0990      		ld __tmp_reg__,Y+
 1125 02f4 0020      		tst __tmp_reg__
 1126 02f6 01F4      		brne 0b
 1127 02f8 2197      		sbiw r28,1
 1128 02fa C81B      		sub r28,r24
 1129 02fc D90B      		sbc r29,r25
 1130 02fe 8C01      		movw r16,r24
 177:../freeRTOS750/lib_serial/lib_serial.c **** void xSerialPrint( uint8_t * str)
 1132               	.LM99:
 1133 0300 C80F      		add r28,r24
 1134 0302 D91F      		adc r29,r25
 184:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 1136               	.LM100:
 1137 0304 00C0      		rjmp .L43
 1138               	.L44:
 185:../freeRTOS750/lib_serial/lib_serial.c **** 		xSerialPutChar( &xSerialPort, str[i++] );
 1140               	.LM101:
 1141 0306 F801      		movw r30,r16
 1142 0308 6191      		ld r22,Z+
 1143 030a 8F01      		movw r16,r30
 1144 030c 80E0      		ldi r24,lo8(xSerialPort)
 1145 030e 90E0      		ldi r25,hi8(xSerialPort)
 1146 0310 0E94 0000 		call xSerialPutChar
 1147               	.L43:
 184:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 1149               	.LM102:
 1150 0314 0C17      		cp r16,r28
 1151 0316 1D07      		cpc r17,r29
 1152 0318 01F4      		brne .L44
 1153               	/* epilogue start */
 186:../freeRTOS750/lib_serial/lib_serial.c **** }
 1155               	.LM103:
 1156 031a DF91      		pop r29
 1157 031c CF91      		pop r28
 1158 031e 1F91      		pop r17
 1159 0320 0F91      		pop r16
 1160 0322 0895      		ret
 1162               	.Lscope10:
 1164               		.stabd	78,0,0
 1167               	.global	xSerialPrintf_P
 1169               	xSerialPrintf_P:
 1170               		.stabd	46,0,0
 161:../freeRTOS750/lib_serial/lib_serial.c **** {
 1172               	.LM104:
 1173               	.LFBB11:
 1174 0324 CF93      		push r28
 1175 0326 DF93      		push r29
 1176 0328 00D0      		rcall .
 1177 032a CDB7      		in r28,__SP_L__
 1178 032c DEB7      		in r29,__SP_H__
 1179               	/* prologue: function */
 1180               	/* frame size = 2 */
 1181               	/* stack size = 4 */
 1182               	.L__stack_usage = 4
 1183 032e FE01      		movw r30,r28
 1184 0330 3796      		adiw r30,7
 1185 0332 8191      		ld r24,Z+
 1186 0334 9191      		ld r25,Z+
 164:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 1188               	.LM105:
 1189 0336 9F01      		movw r18,r30
 166:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) taskYIELD();
 1191               	.LM106:
 1192 0338 00C0      		rjmp .L46
 1193               	.L47:
 166:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) taskYIELD();
 1195               	.LM107:
 1196 033a 2983      		std Y+1,r18
 1197 033c 3A83      		std Y+2,r19
 1198 033e 0E94 0000 		call vPortYield
 1199 0342 3A81      		ldd r19,Y+2
 1200 0344 2981      		ldd r18,Y+1
 1201               	.L46:
 166:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) taskYIELD();
 1203               	.LM108:
 1204 0346 8091 0000 		lds r24,xSerialPort+29
 1205 034a 8130      		cpi r24,lo8(1)
 1206 034c 01F0      		breq .L47
 167:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = ENGAGED;
 1208               	.LM109:
 1209 034e 81E0      		ldi r24,lo8(1)
 1210 0350 8093 0000 		sts xSerialPort+29,r24
 169:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf_P((char *)(xSerialPort.serialWorkBuffer), xSerialPort.serialWorkBufferSize, format, arg)
 1212               	.LM110:
 1213 0354 6091 0000 		lds r22,xSerialPort+27
 1214 0358 7091 0000 		lds r23,xSerialPort+27+1
 1215 035c 4F81      		ldd r20,Y+7
 1216 035e 5885      		ldd r21,Y+8
 1217 0360 8091 0000 		lds r24,xSerialPort+25
 1218 0364 9091 0000 		lds r25,xSerialPort+25+1
 1219 0368 0E94 0000 		call vsnprintf_P
 170:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPrint((uint8_t *)(xSerialPort.serialWorkBuffer));
 1221               	.LM111:
 1222 036c 8091 0000 		lds r24,xSerialPort+25
 1223 0370 9091 0000 		lds r25,xSerialPort+25+1
 1224 0374 0E94 0000 		call xSerialPrint
 172:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = VACANT;
 1226               	.LM112:
 1227 0378 1092 0000 		sts xSerialPort+29,__zero_reg__
 1228               	/* epilogue start */
 175:../freeRTOS750/lib_serial/lib_serial.c **** }
 1230               	.LM113:
 1231 037c 0F90      		pop __tmp_reg__
 1232 037e 0F90      		pop __tmp_reg__
 1233 0380 DF91      		pop r29
 1234 0382 CF91      		pop r28
 1235 0384 0895      		ret
 1237               	.Lscope11:
 1239               		.stabd	78,0,0
 1242               	.global	xSerialPrintf
 1244               	xSerialPrintf:
 1245               		.stabd	46,0,0
 144:../freeRTOS750/lib_serial/lib_serial.c **** {
 1247               	.LM114:
 1248               	.LFBB12:
 1249 0386 CF93      		push r28
 1250 0388 DF93      		push r29
 1251 038a 00D0      		rcall .
 1252 038c CDB7      		in r28,__SP_L__
 1253 038e DEB7      		in r29,__SP_H__
 1254               	/* prologue: function */
 1255               	/* frame size = 2 */
 1256               	/* stack size = 4 */
 1257               	.L__stack_usage = 4
 1258 0390 FE01      		movw r30,r28
 1259 0392 3796      		adiw r30,7
 1260 0394 8191      		ld r24,Z+
 1261 0396 9191      		ld r25,Z+
 147:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 1263               	.LM115:
 1264 0398 9F01      		movw r18,r30
 149:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) taskYIELD();
 1266               	.LM116:
 1267 039a 00C0      		rjmp .L49
 1268               	.L50:
 149:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) taskYIELD();
 1270               	.LM117:
 1271 039c 2983      		std Y+1,r18
 1272 039e 3A83      		std Y+2,r19
 1273 03a0 0E94 0000 		call vPortYield
 1274 03a4 3A81      		ldd r19,Y+2
 1275 03a6 2981      		ldd r18,Y+1
 1276               	.L49:
 149:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) taskYIELD();
 1278               	.LM118:
 1279 03a8 8091 0000 		lds r24,xSerialPort+29
 1280 03ac 8130      		cpi r24,lo8(1)
 1281 03ae 01F0      		breq .L50
 150:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = ENGAGED;
 1283               	.LM119:
 1284 03b0 81E0      		ldi r24,lo8(1)
 1285 03b2 8093 0000 		sts xSerialPort+29,r24
 152:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf((char *)(xSerialPort.serialWorkBuffer), xSerialPort.serialWorkBufferSize, (const char *)
 1287               	.LM120:
 1288 03b6 6091 0000 		lds r22,xSerialPort+27
 1289 03ba 7091 0000 		lds r23,xSerialPort+27+1
 1290 03be 4F81      		ldd r20,Y+7
 1291 03c0 5885      		ldd r21,Y+8
 1292 03c2 8091 0000 		lds r24,xSerialPort+25
 1293 03c6 9091 0000 		lds r25,xSerialPort+25+1
 1294 03ca 0E94 0000 		call vsnprintf
 153:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPrint((uint8_t *)(xSerialPort.serialWorkBuffer));
 1296               	.LM121:
 1297 03ce 8091 0000 		lds r24,xSerialPort+25
 1298 03d2 9091 0000 		lds r25,xSerialPort+25+1
 1299 03d6 0E94 0000 		call xSerialPrint
 155:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = VACANT;
 1301               	.LM122:
 1302 03da 1092 0000 		sts xSerialPort+29,__zero_reg__
 1303               	/* epilogue start */
 158:../freeRTOS750/lib_serial/lib_serial.c **** }
 1305               	.LM123:
 1306 03de 0F90      		pop __tmp_reg__
 1307 03e0 0F90      		pop __tmp_reg__
 1308 03e2 DF91      		pop r29
 1309 03e4 CF91      		pop r28
 1310 03e6 0895      		ret
 1312               	.Lscope12:
 1314               		.stabd	78,0,0
 1320               	.global	xSerialPortInitMinimal
 1322               	xSerialPortInitMinimal:
 1323               		.stabd	46,0,0
 349:../freeRTOS750/lib_serial/lib_serial.c **** /*-----------------------------------------------------------*/
 350:../freeRTOS750/lib_serial/lib_serial.c **** 
 351:../freeRTOS750/lib_serial/lib_serial.c **** xComPortHandle xSerialPortInitMinimal( eCOMPort ePort, uint32_t ulWantedBaud, uint16_t uxTxQueueLen
 352:../freeRTOS750/lib_serial/lib_serial.c **** {
 1325               	.LM124:
 1326               	.LFBB13:
 1327 03e8 BF92      		push r11
 1328 03ea CF92      		push r12
 1329 03ec DF92      		push r13
 1330 03ee EF92      		push r14
 1331 03f0 FF92      		push r15
 1332 03f2 0F93      		push r16
 1333 03f4 1F93      		push r17
 1334 03f6 CF93      		push r28
 1335 03f8 DF93      		push r29
 1336 03fa CDB7      		in r28,__SP_L__
 1337 03fc DEB7      		in r29,__SP_H__
 1338 03fe A297      		sbiw r28,34
 1339 0400 0FB6      		in __tmp_reg__,__SREG__
 1340 0402 F894      		cli
 1341 0404 DEBF      		out __SP_H__,r29
 1342 0406 0FBE      		out __SREG__,__tmp_reg__
 1343 0408 CDBF      		out __SP_L__,r28
 1344               	/* prologue: function */
 1345               	/* frame size = 34 */
 1346               	/* stack size = 43 */
 1347               	.L__stack_usage = 43
 1348 040a 6C01      		movw r12,r24
 1349 040c B62E      		mov r11,r22
 353:../freeRTOS750/lib_serial/lib_serial.c **** 	uint8_t * dataPtr;
 354:../freeRTOS750/lib_serial/lib_serial.c **** 
 355:../freeRTOS750/lib_serial/lib_serial.c **** 	xComPortHandle newComPort;
 356:../freeRTOS750/lib_serial/lib_serial.c **** 
 357:../freeRTOS750/lib_serial/lib_serial.c **** 	/* Create the ring-buffers used by the serial communications task. */
 358:../freeRTOS750/lib_serial/lib_serial.c **** 	if( (dataPtr = (uint8_t *)pvPortMalloc( sizeof(uint8_t) * uxRxQueueLength )))
 1351               	.LM125:
 1352 040e C701      		movw r24,r14
 1353 0410 2F8F      		std Y+31,r18
 1354 0412 38A3      		std Y+32,r19
 1355 0414 49A3      		std Y+33,r20
 1356 0416 5AA3      		std Y+34,r21
 1357 0418 0E94 0000 		call pvPortMalloc
 1358 041c 2F8D      		ldd r18,Y+31
 1359 041e 38A1      		ldd r19,Y+32
 1360 0420 49A1      		ldd r20,Y+33
 1361 0422 5AA1      		ldd r21,Y+34
 1362 0424 0097      		sbiw r24,0
 1363 0426 01F0      		breq .L52
 1364               	.LBB186:
 1365               	.LBB187:
 1367               	.Ltext20:
 275:../freeRTOS750/include/ringBuffer.h **** 	GCC_FORCE_POINTER_ACCESS(buffer);
 1369               	.LM126:
 1370 0428 FE01      		movw r30,r28
 1371 042a 3296      		adiw r30,2
 277:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 1373               	.LM127:
 1374               	/* #APP */
 1375               	 ;  277 "../freeRTOS750/include/ringBuffer.h" 1
 1376 042c 0FB6      		in		__tmp_reg__, __SREG__
 1377               	 ;  0 "" 2
 1378               	 ;  277 "../freeRTOS750/include/ringBuffer.h" 1
 1379 042e F894      		cli
 1380               	 ;  0 "" 2
 1381               	 ;  277 "../freeRTOS750/include/ringBuffer.h" 1
 1382 0430 0F92      		push	__tmp_reg__
 1383               	 ;  0 "" 2
 279:../freeRTOS750/include/ringBuffer.h **** 	buffer->count  = 0;
 1385               	.LM128:
 1386               	/* #NOAPP */
 1387 0432 1182      		std Z+1,__zero_reg__
 1388 0434 1082      		st Z,__zero_reg__
 280:../freeRTOS750/include/ringBuffer.h **** 	buffer->in     = dataPtr;
 1390               	.LM129:
 1391 0436 9383      		std Z+3,r25
 1392 0438 8283      		std Z+2,r24
 281:../freeRTOS750/include/ringBuffer.h **** 	buffer->out    = dataPtr;
 1394               	.LM130:
 1395 043a 9583      		std Z+5,r25
 1396 043c 8483      		std Z+4,r24
 282:../freeRTOS750/include/ringBuffer.h **** 	buffer->start  = &dataPtr[0];
 1398               	.LM131:
 1399 043e 9783      		std Z+7,r25
 1400 0440 8683      		std Z+6,r24
 283:../freeRTOS750/include/ringBuffer.h **** 	buffer->end    = &dataPtr[size];
 1402               	.LM132:
 1403 0442 8E0D      		add r24,r14
 1404 0444 9F1D      		adc r25,r15
 1405 0446 9187      		std Z+9,r25
 1406 0448 8087      		std Z+8,r24
 284:../freeRTOS750/include/ringBuffer.h **** 	buffer->size   = size;
 1408               	.LM133:
 1409 044a F386      		std Z+11,r15
 1410 044c E286      		std Z+10,r14
 286:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 1412               	.LM134:
 1413               	/* #APP */
 1414               	 ;  286 "../freeRTOS750/include/ringBuffer.h" 1
 1415 044e 0F90      		pop		__tmp_reg__
 1416               	 ;  0 "" 2
 1417               	 ;  286 "../freeRTOS750/include/ringBuffer.h" 1
 1418 0450 0FBE      		out		__SREG__, __tmp_reg__
 1419               	 ;  0 "" 2
 1420               	/* #NOAPP */
 1421               	.L52:
 1422               	.LBE187:
 1423               	.LBE186:
 1425               	.Ltext21:
 359:../freeRTOS750/lib_serial/lib_serial.c **** 		ringBuffer_InitBuffer( &(newComPort.xRxedChars), dataPtr, uxRxQueueLength);
 360:../freeRTOS750/lib_serial/lib_serial.c **** 
 361:../freeRTOS750/lib_serial/lib_serial.c **** 	if( (dataPtr = (uint8_t *)pvPortMalloc( sizeof(uint8_t) * uxTxQueueLength )))
 1427               	.LM135:
 1428 0452 C801      		movw r24,r16
 1429 0454 2F8F      		std Y+31,r18
 1430 0456 38A3      		std Y+32,r19
 1431 0458 49A3      		std Y+33,r20
 1432 045a 5AA3      		std Y+34,r21
 1433 045c 0E94 0000 		call pvPortMalloc
 1434 0460 2F8D      		ldd r18,Y+31
 1435 0462 38A1      		ldd r19,Y+32
 1436 0464 49A1      		ldd r20,Y+33
 1437 0466 5AA1      		ldd r21,Y+34
 1438 0468 0097      		sbiw r24,0
 1439 046a 01F0      		breq .L53
 1440               	.LBB188:
 1441               	.LBB189:
 1443               	.Ltext22:
 275:../freeRTOS750/include/ringBuffer.h **** 	GCC_FORCE_POINTER_ACCESS(buffer);
 1445               	.LM136:
 1446 046c FE01      		movw r30,r28
 1447 046e 3E96      		adiw r30,14
 277:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 1449               	.LM137:
 1450               	/* #APP */
 1451               	 ;  277 "../freeRTOS750/include/ringBuffer.h" 1
 1452 0470 0FB6      		in		__tmp_reg__, __SREG__
 1453               	 ;  0 "" 2
 1454               	 ;  277 "../freeRTOS750/include/ringBuffer.h" 1
 1455 0472 F894      		cli
 1456               	 ;  0 "" 2
 1457               	 ;  277 "../freeRTOS750/include/ringBuffer.h" 1
 1458 0474 0F92      		push	__tmp_reg__
 1459               	 ;  0 "" 2
 279:../freeRTOS750/include/ringBuffer.h **** 	buffer->count  = 0;
 1461               	.LM138:
 1462               	/* #NOAPP */
 1463 0476 1182      		std Z+1,__zero_reg__
 1464 0478 1082      		st Z,__zero_reg__
 280:../freeRTOS750/include/ringBuffer.h **** 	buffer->in     = dataPtr;
 1466               	.LM139:
 1467 047a 9383      		std Z+3,r25
 1468 047c 8283      		std Z+2,r24
 281:../freeRTOS750/include/ringBuffer.h **** 	buffer->out    = dataPtr;
 1470               	.LM140:
 1471 047e 9583      		std Z+5,r25
 1472 0480 8483      		std Z+4,r24
 282:../freeRTOS750/include/ringBuffer.h **** 	buffer->start  = &dataPtr[0];
 1474               	.LM141:
 1475 0482 9783      		std Z+7,r25
 1476 0484 8683      		std Z+6,r24
 283:../freeRTOS750/include/ringBuffer.h **** 	buffer->end    = &dataPtr[size];
 1478               	.LM142:
 1479 0486 800F      		add r24,r16
 1480 0488 911F      		adc r25,r17
 1481 048a 9187      		std Z+9,r25
 1482 048c 8087      		std Z+8,r24
 284:../freeRTOS750/include/ringBuffer.h **** 	buffer->size   = size;
 1484               	.LM143:
 1485 048e 1387      		std Z+11,r17
 1486 0490 0287      		std Z+10,r16
 286:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 1488               	.LM144:
 1489               	/* #APP */
 1490               	 ;  286 "../freeRTOS750/include/ringBuffer.h" 1
 1491 0492 0F90      		pop		__tmp_reg__
 1492               	 ;  0 "" 2
 1493               	 ;  286 "../freeRTOS750/include/ringBuffer.h" 1
 1494 0494 0FBE      		out		__SREG__, __tmp_reg__
 1495               	 ;  0 "" 2
 1496               	/* #NOAPP */
 1497               	.L53:
 1498               	.LBE189:
 1499               	.LBE188:
 1501               	.Ltext23:
 362:../freeRTOS750/lib_serial/lib_serial.c **** 		ringBuffer_InitBuffer( &(newComPort.xCharsForTx), dataPtr, uxTxQueueLength);
 363:../freeRTOS750/lib_serial/lib_serial.c **** 
 364:../freeRTOS750/lib_serial/lib_serial.c **** 	// create a working buffer for vsnprintf on the heap (so we can use extended RAM, if available).
 365:../freeRTOS750/lib_serial/lib_serial.c **** 	// create the structures on the heap (so they can be moved later).
 366:../freeRTOS750/lib_serial/lib_serial.c **** 	if( !(newComPort.serialWorkBuffer = (uint8_t *)pvPortMalloc( sizeof(uint8_t) * uxTxQueueLength )))
 1503               	.LM145:
 1504 0496 C801      		movw r24,r16
 1505 0498 2F8F      		std Y+31,r18
 1506 049a 38A3      		std Y+32,r19
 1507 049c 49A3      		std Y+33,r20
 1508 049e 5AA3      		std Y+34,r21
 1509 04a0 0E94 0000 		call pvPortMalloc
 1510 04a4 9B8F      		std Y+27,r25
 1511 04a6 8A8F      		std Y+26,r24
 367:../freeRTOS750/lib_serial/lib_serial.c **** 		newComPort.serialWorkBuffer = NULL;
 368:../freeRTOS750/lib_serial/lib_serial.c **** 
 369:../freeRTOS750/lib_serial/lib_serial.c **** 	newComPort.usart = ePort; // containing eCOMPort
 1513               	.LM146:
 1514 04a8 B982      		std Y+1,r11
 370:../freeRTOS750/lib_serial/lib_serial.c **** 	newComPort.serialWorkBufferSize = uxTxQueueLength; // size of the working buffer for vsnprintf
 1516               	.LM147:
 1517 04aa 1D8F      		std Y+29,r17
 1518 04ac 0C8F      		std Y+28,r16
 371:../freeRTOS750/lib_serial/lib_serial.c **** 	newComPort.serialWorkBufferInUse = VACANT;  // clear the occupation flag.
 1520               	.LM148:
 1521 04ae 1E8E      		std Y+30,__zero_reg__
 372:../freeRTOS750/lib_serial/lib_serial.c **** 
 373:../freeRTOS750/lib_serial/lib_serial.c **** 	portENTER_CRITICAL();
 1523               	.LM149:
 1524               	/* #APP */
 1525               	 ;  373 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1526 04b0 0FB6      		in		__tmp_reg__, __SREG__
 1527               	 ;  0 "" 2
 1528               	 ;  373 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1529 04b2 F894      		cli
 1530               	 ;  0 "" 2
 1531               	 ;  373 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1532 04b4 0F92      		push	__tmp_reg__
 1533               	 ;  0 "" 2
 374:../freeRTOS750/lib_serial/lib_serial.c **** 
 375:../freeRTOS750/lib_serial/lib_serial.c **** 	switch (newComPort.usart)
 1535               	.LM150:
 1536               	/* #NOAPP */
 1537 04b6 2F8D      		ldd r18,Y+31
 1538 04b8 38A1      		ldd r19,Y+32
 1539 04ba 49A1      		ldd r20,Y+33
 1540 04bc 5AA1      		ldd r21,Y+34
 1541 04be B110      		cpse r11,__zero_reg__
 1542 04c0 00C0      		rjmp .L54
 376:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 377:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART0:
 378:../freeRTOS750/lib_serial/lib_serial.c **** 		/*
 379:../freeRTOS750/lib_serial/lib_serial.c **** 		 * Calculate the baud rate register value from the equation in the data sheet. */
 380:../freeRTOS750/lib_serial/lib_serial.c **** 
 381:../freeRTOS750/lib_serial/lib_serial.c **** 		/* As the 16MHz Arduino boards have bad karma for serial port, we're using the 2x clock U2X0 */
 382:../freeRTOS750/lib_serial/lib_serial.c **** 		// for Arduino at 16MHz; above data sheet calculation is wrong. Need below from <util/setbaud.h>
 383:../freeRTOS750/lib_serial/lib_serial.c **** 		// This provides correct rounding truncation to get closest to correct speed.
 384:../freeRTOS750/lib_serial/lib_serial.c **** 		// Normal mode gives 3.7% error, which is too much. Use 2x mode gives 2.1% error.
 385:../freeRTOS750/lib_serial/lib_serial.c **** 		// Or, use 22.1184 MHz over clock which gives 0.00% error, for all rates.
 386:../freeRTOS750/lib_serial/lib_serial.c **** 
 387:../freeRTOS750/lib_serial/lib_serial.c **** 		// ulBaudRateCounter = ((configCPU_CLOCK_HZ + ulWantedBaud * 8UL) / (ulWantedBaud * 16UL) - 1); /
 388:../freeRTOS750/lib_serial/lib_serial.c **** 		// ulBaudRateCounter = (uint16_t)((configCPU_CLOCK_HZ + ulWantedBaud * 4UL) / (ulWantedBaud * 8UL
 389:../freeRTOS750/lib_serial/lib_serial.c **** 		UBRR0 = (uint16_t)((configCPU_CLOCK_HZ + ulWantedBaud * 4UL) / (ulWantedBaud * 8UL) - 1);  // for
 1544               	.LM151:
 1545 04c2 CA01      		movw r24,r20
 1546 04c4 B901      		movw r22,r18
 1547 04c6 775F      		subi r23,-9
 1548 04c8 824C      		sbci r24,-62
 1549 04ca 9F4F      		sbci r25,-1
 1550 04cc E2E0      		ldi r30,2
 1551               		1:
 1552 04ce 660F      		lsl r22
 1553 04d0 771F      		rol r23
 1554 04d2 881F      		rol r24
 1555 04d4 991F      		rol r25
 1556 04d6 EA95      		dec r30
 1557 04d8 01F4      		brne 1b
 1558 04da F3E0      		ldi r31,3
 1559               		1:
 1560 04dc 220F      		lsl r18
 1561 04de 331F      		rol r19
 1562 04e0 441F      		rol r20
 1563 04e2 551F      		rol r21
 1564 04e4 FA95      		dec r31
 1565 04e6 01F4      		brne 1b
 1566 04e8 0E94 0000 		call __udivmodsi4
 1567 04ec 2150      		subi r18,1
 1568 04ee 3109      		sbc r19,__zero_reg__
 1569 04f0 3093 C500 		sts 196+1,r19
 1570 04f4 2093 C400 		sts 196,r18
 390:../freeRTOS750/lib_serial/lib_serial.c **** 
 391:../freeRTOS750/lib_serial/lib_serial.c **** 		/* Set the 2x speed mode bit */
 392:../freeRTOS750/lib_serial/lib_serial.c **** 		UCSR0A = _BV(U2X0);
 1572               	.LM152:
 1573 04f8 82E0      		ldi r24,lo8(2)
 1574 04fa 8093 C000 		sts 192,r24
 393:../freeRTOS750/lib_serial/lib_serial.c **** 
 394:../freeRTOS750/lib_serial/lib_serial.c **** 		/* Enable the Rx and Tx. Also enable the Rx interrupt. The Tx interrupt will get enabled later. *
 395:../freeRTOS750/lib_serial/lib_serial.c **** 		UCSR0B = ( _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0));
 1576               	.LM153:
 1577 04fe 88E9      		ldi r24,lo8(-104)
 1578 0500 8093 C100 		sts 193,r24
 396:../freeRTOS750/lib_serial/lib_serial.c **** 
 397:../freeRTOS750/lib_serial/lib_serial.c **** 		/* Set the data bit register to 8n1. */
 398:../freeRTOS750/lib_serial/lib_serial.c **** 		UCSR0C = ( _BV(UCSZ01) | _BV(UCSZ00) );
 1580               	.LM154:
 1581 0504 86E0      		ldi r24,lo8(6)
 1582 0506 8093 C200 		sts 194,r24
 1583               	.L54:
 399:../freeRTOS750/lib_serial/lib_serial.c **** 
 400:../freeRTOS750/lib_serial/lib_serial.c **** 		break;
 401:../freeRTOS750/lib_serial/lib_serial.c **** 
 402:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART1:
 403:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) || d
 404:../freeRTOS750/lib_serial/lib_serial.c **** 		UBRR1 = (uint16_t)((configCPU_CLOCK_HZ + ulWantedBaud * 4UL) / (ulWantedBaud * 8UL) - 1);
 405:../freeRTOS750/lib_serial/lib_serial.c **** 		UCSR1A = _BV(U2X1);
 406:../freeRTOS750/lib_serial/lib_serial.c **** 		UCSR1B = ( _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1));
 407:../freeRTOS750/lib_serial/lib_serial.c **** 		UCSR1C = ( _BV(UCSZ11) | _BV(UCSZ10) );
 408:../freeRTOS750/lib_serial/lib_serial.c **** 
 409:../freeRTOS750/lib_serial/lib_serial.c **** 		break;
 410:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 411:../freeRTOS750/lib_serial/lib_serial.c **** 
 412:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART2:
 413:../freeRTOS750/lib_serial/lib_serial.c **** 	case USART3:
 414:../freeRTOS750/lib_serial/lib_serial.c **** 	default:
 415:../freeRTOS750/lib_serial/lib_serial.c **** 		break;
 416:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 417:../freeRTOS750/lib_serial/lib_serial.c **** 
 418:../freeRTOS750/lib_serial/lib_serial.c **** 	portEXIT_CRITICAL();
 1585               	.LM155:
 1586               	/* #APP */
 1587               	 ;  418 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1588 050a 0F90      		pop		__tmp_reg__
 1589               	 ;  0 "" 2
 1590               	 ;  418 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1591 050c 0FBE      		out		__SREG__, __tmp_reg__
 1592               	 ;  0 "" 2
 419:../freeRTOS750/lib_serial/lib_serial.c **** 
 420:../freeRTOS750/lib_serial/lib_serial.c **** 	return newComPort;
 1594               	.LM156:
 1595               	/* #NOAPP */
 1596 050e 8EE1      		ldi r24,lo8(30)
 1597 0510 FE01      		movw r30,r28
 1598 0512 3196      		adiw r30,1
 1599 0514 D601      		movw r26,r12
 1600               		0:
 1601 0516 0190      		ld r0,Z+
 1602 0518 0D92      		st X+,r0
 1603 051a 8A95      		dec r24
 1604 051c 01F4      		brne 0b
 421:../freeRTOS750/lib_serial/lib_serial.c **** }
 1606               	.LM157:
 1607 051e C601      		movw r24,r12
 1608               	/* epilogue start */
 1609 0520 A296      		adiw r28,34
 1610 0522 0FB6      		in __tmp_reg__,__SREG__
 1611 0524 F894      		cli
 1612 0526 DEBF      		out __SP_H__,r29
 1613 0528 0FBE      		out __SREG__,__tmp_reg__
 1614 052a CDBF      		out __SP_L__,r28
 1615 052c DF91      		pop r29
 1616 052e CF91      		pop r28
 1617 0530 1F91      		pop r17
 1618 0532 0F91      		pop r16
 1619 0534 FF90      		pop r15
 1620 0536 EF90      		pop r14
 1621 0538 DF90      		pop r13
 1622 053a CF90      		pop r12
 1623 053c BF90      		pop r11
 1624 053e 0895      		ret
 1629               	.Lscope13:
 1631               		.stabd	78,0,0
 1634               	.global	vSerialClose
 1636               	vSerialClose:
 1637               		.stabd	46,0,0
 422:../freeRTOS750/lib_serial/lib_serial.c **** 
 423:../freeRTOS750/lib_serial/lib_serial.c **** void vSerialClose( xComPortHandlePtr oldComPortPtr )
 424:../freeRTOS750/lib_serial/lib_serial.c **** {
 1639               	.LM158:
 1640               	.LFBB14:
 1641 0540 CF93      		push r28
 1642 0542 DF93      		push r29
 1643               	/* prologue: function */
 1644               	/* frame size = 0 */
 1645               	/* stack size = 2 */
 1646               	.L__stack_usage = 2
 1647 0544 EC01      		movw r28,r24
 425:../freeRTOS750/lib_serial/lib_serial.c **** 	uint8_t ucByte;
 426:../freeRTOS750/lib_serial/lib_serial.c **** 
 427:../freeRTOS750/lib_serial/lib_serial.c **** 	/* Turn off the interrupts.  We may also want to delete the queues and/or
 428:../freeRTOS750/lib_serial/lib_serial.c **** 	re-install the original ISR. */
 429:../freeRTOS750/lib_serial/lib_serial.c **** 
 430:../freeRTOS750/lib_serial/lib_serial.c **** 	vPortFree( oldComPortPtr->serialWorkBuffer );
 1649               	.LM159:
 1650 0546 898D      		ldd r24,Y+25
 1651 0548 9A8D      		ldd r25,Y+26
 1652 054a 0E94 0000 		call vPortFree
 431:../freeRTOS750/lib_serial/lib_serial.c **** 	vPortFree( oldComPortPtr->xRxedChars.start );
 1654               	.LM160:
 1655 054e 8F81      		ldd r24,Y+7
 1656 0550 9885      		ldd r25,Y+8
 1657 0552 0E94 0000 		call vPortFree
 432:../freeRTOS750/lib_serial/lib_serial.c **** 	vPortFree( oldComPortPtr->xCharsForTx.start );
 1659               	.LM161:
 1660 0556 8B89      		ldd r24,Y+19
 1661 0558 9C89      		ldd r25,Y+20
 1662 055a 0E94 0000 		call vPortFree
 433:../freeRTOS750/lib_serial/lib_serial.c **** 
 434:../freeRTOS750/lib_serial/lib_serial.c **** 	portENTER_CRITICAL();
 1664               	.LM162:
 1665               	/* #APP */
 1666               	 ;  434 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1667 055e 0FB6      		in		__tmp_reg__, __SREG__
 1668               	 ;  0 "" 2
 1669               	 ;  434 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1670 0560 F894      		cli
 1671               	 ;  0 "" 2
 1672               	 ;  434 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1673 0562 0F92      		push	__tmp_reg__
 1674               	 ;  0 "" 2
 435:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 436:../freeRTOS750/lib_serial/lib_serial.c **** 		switch (oldComPortPtr->usart)
 1676               	.LM163:
 1677               	/* #NOAPP */
 1678 0564 8881      		ld r24,Y
 1679 0566 8111      		cpse r24,__zero_reg__
 1680 0568 00C0      		rjmp .L63
 1681               	.LBB190:
 437:../freeRTOS750/lib_serial/lib_serial.c **** 		{
 438:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART0:
 439:../freeRTOS750/lib_serial/lib_serial.c **** 			vInterrupt0_Off();
 1683               	.LM164:
 1684 056a 8091 C100 		lds r24,193
 1685 056e 8F7D      		andi r24,lo8(-33)
 1686 0570 8093 C100 		sts 193,r24
 1687               	.LBE190:
 440:../freeRTOS750/lib_serial/lib_serial.c **** 			ucByte = UCSR0B;
 1689               	.LM165:
 1690 0574 8091 C100 		lds r24,193
 441:../freeRTOS750/lib_serial/lib_serial.c **** 			ucByte &= ~(_BV(RXCIE0));
 1692               	.LM166:
 1693 0578 8F77      		andi r24,lo8(127)
 442:../freeRTOS750/lib_serial/lib_serial.c **** 			UCSR0B = ucByte;
 1695               	.LM167:
 1696 057a 8093 C100 		sts 193,r24
 1697               	.L63:
 443:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 444:../freeRTOS750/lib_serial/lib_serial.c **** 
 445:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART1:
 446:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) || d
 447:../freeRTOS750/lib_serial/lib_serial.c **** 			vInterrupt1_Off();
 448:../freeRTOS750/lib_serial/lib_serial.c **** 			ucByte = UCSR1B;
 449:../freeRTOS750/lib_serial/lib_serial.c **** 			ucByte &= ~(_BV(RXCIE1));
 450:../freeRTOS750/lib_serial/lib_serial.c **** 			UCSR1B = ucByte;
 451:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 452:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 453:../freeRTOS750/lib_serial/lib_serial.c **** 
 454:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART2:
 455:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART3:
 456:../freeRTOS750/lib_serial/lib_serial.c **** 		default:
 457:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 458:../freeRTOS750/lib_serial/lib_serial.c **** 		}
 459:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 460:../freeRTOS750/lib_serial/lib_serial.c **** 	portEXIT_CRITICAL();
 1699               	.LM168:
 1700               	/* #APP */
 1701               	 ;  460 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1702 057e 0F90      		pop		__tmp_reg__
 1703               	 ;  0 "" 2
 1704               	 ;  460 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1705 0580 0FBE      		out		__SREG__, __tmp_reg__
 1706               	 ;  0 "" 2
 1707               	/* epilogue start */
 461:../freeRTOS750/lib_serial/lib_serial.c **** }
 1709               	.LM169:
 1710               	/* #NOAPP */
 1711 0582 DF91      		pop r29
 1712 0584 CF91      		pop r28
 1713 0586 0895      		ret
 1715               	.Lscope14:
 1717               		.stabd	78,0,0
 1720               	.global	avrSerialWrite
 1722               	avrSerialWrite:
 1723               		.stabd	46,0,0
 462:../freeRTOS750/lib_serial/lib_serial.c **** 
 463:../freeRTOS750/lib_serial/lib_serial.c **** /*-----------------------------------------------------------*/
 464:../freeRTOS750/lib_serial/lib_serial.c **** 
 465:../freeRTOS750/lib_serial/lib_serial.c **** // polling read and write routines, for use before freeRTOS vTaskStartScheduler (interrupts enabled
 466:../freeRTOS750/lib_serial/lib_serial.c **** // same as above, but doesn't use interrupts.
 467:../freeRTOS750/lib_serial/lib_serial.c **** 
 468:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialPrintf(const char * format, ...)
 469:../freeRTOS750/lib_serial/lib_serial.c **** {
 470:../freeRTOS750/lib_serial/lib_serial.c **** 	va_list arg;
 471:../freeRTOS750/lib_serial/lib_serial.c **** 
 472:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 473:../freeRTOS750/lib_serial/lib_serial.c **** 
 474:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 475:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = ENGAGED;
 476:../freeRTOS750/lib_serial/lib_serial.c **** 
 477:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf((char *)(xSerialPort.serialWorkBuffer), xSerialPort.serialWorkBufferSize, (const char *)
 478:../freeRTOS750/lib_serial/lib_serial.c **** 	avrSerialPrint((xSerialPort.serialWorkBuffer));
 479:../freeRTOS750/lib_serial/lib_serial.c **** 
 480:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = VACANT;
 481:../freeRTOS750/lib_serial/lib_serial.c **** 
 482:../freeRTOS750/lib_serial/lib_serial.c **** 	va_end(arg);
 483:../freeRTOS750/lib_serial/lib_serial.c **** }
 484:../freeRTOS750/lib_serial/lib_serial.c **** 
 485:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialPrintf_P(PGM_P format, ...)
 486:../freeRTOS750/lib_serial/lib_serial.c **** {
 487:../freeRTOS750/lib_serial/lib_serial.c **** 	va_list arg;
 488:../freeRTOS750/lib_serial/lib_serial.c **** 
 489:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 490:../freeRTOS750/lib_serial/lib_serial.c **** 
 491:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 492:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = ENGAGED;
 493:../freeRTOS750/lib_serial/lib_serial.c **** 
 494:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf_P((char *)(xSerialPort.serialWorkBuffer), xSerialPort.serialWorkBufferSize, format, arg)
 495:../freeRTOS750/lib_serial/lib_serial.c **** 	avrSerialPrint((xSerialPort.serialWorkBuffer));
 496:../freeRTOS750/lib_serial/lib_serial.c **** 
 497:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = VACANT;
 498:../freeRTOS750/lib_serial/lib_serial.c **** 
 499:../freeRTOS750/lib_serial/lib_serial.c **** 	va_end(arg);
 500:../freeRTOS750/lib_serial/lib_serial.c **** }
 501:../freeRTOS750/lib_serial/lib_serial.c **** 
 502:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialPrint(uint8_t * str)
 503:../freeRTOS750/lib_serial/lib_serial.c **** {
 504:../freeRTOS750/lib_serial/lib_serial.c **** 	uint16_t i = 0;
 505:../freeRTOS750/lib_serial/lib_serial.c **** 	size_t stringlength;
 506:../freeRTOS750/lib_serial/lib_serial.c **** 
 507:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen((char *)str);
 508:../freeRTOS750/lib_serial/lib_serial.c **** 
 509:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 510:../freeRTOS750/lib_serial/lib_serial.c **** 		avrSerialWrite(str[i++]);
 511:../freeRTOS750/lib_serial/lib_serial.c **** }
 512:../freeRTOS750/lib_serial/lib_serial.c **** 
 513:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialPrint_P(PGM_P str)
 514:../freeRTOS750/lib_serial/lib_serial.c **** {
 515:../freeRTOS750/lib_serial/lib_serial.c **** 	uint16_t i = 0;
 516:../freeRTOS750/lib_serial/lib_serial.c **** 	size_t stringlength;
 517:../freeRTOS750/lib_serial/lib_serial.c **** 
 518:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen_P(str);
 519:../freeRTOS750/lib_serial/lib_serial.c **** 
 520:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 521:../freeRTOS750/lib_serial/lib_serial.c **** 		avrSerialWrite(pgm_read_byte(&str[i++]));
 522:../freeRTOS750/lib_serial/lib_serial.c **** }
 523:../freeRTOS750/lib_serial/lib_serial.c **** 
 524:../freeRTOS750/lib_serial/lib_serial.c **** inline void avrSerialWrite(int8_t DataOut)
 525:../freeRTOS750/lib_serial/lib_serial.c **** {
 1725               	.LM170:
 1726               	.LFBB15:
 1727               	/* prologue: function */
 1728               	/* frame size = 0 */
 1729               	/* stack size = 0 */
 1730               	.L__stack_usage = 0
 526:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialCheckTxReady())		// while NOT ready to transmit
 1732               	.LM171:
 1733 0588 00C0      		rjmp .L66
 1734               	.L67:
 1735               	.LBB191:
 1736               	.LBB192:
 1738               	.Ltext24:
 1740               	.LM172:
 1741 058a 98E0      		ldi r25,lo8(8)
 1742 058c 9A95      		1: dec r25
 1743 058e 01F4      		brne 1b
 1744 0590 0000      		nop
 1745               	.L66:
 1746               	.LBE192:
 1747               	.LBE191:
 1748               	.LBB193:
 1749               	.LBB194:
 1751               	.Ltext25:
 527:../freeRTOS750/lib_serial/lib_serial.c ****         _delay_us(25);     					// delay
 528:../freeRTOS750/lib_serial/lib_serial.c **** 	UDR0 = DataOut;
 529:../freeRTOS750/lib_serial/lib_serial.c **** }
 530:../freeRTOS750/lib_serial/lib_serial.c **** 
 531:../freeRTOS750/lib_serial/lib_serial.c **** inline int8_t avrSerialRead(void)
 532:../freeRTOS750/lib_serial/lib_serial.c **** {
 533:../freeRTOS750/lib_serial/lib_serial.c **** 
 534:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialCheckRxComplete())		// While data is NOT available to read
 535:../freeRTOS750/lib_serial/lib_serial.c **** 		_delay_us(25);     					// delay
 536:../freeRTOS750/lib_serial/lib_serial.c **** 	/* Get status and data */
 537:../freeRTOS750/lib_serial/lib_serial.c **** 	/* from buffer */
 538:../freeRTOS750/lib_serial/lib_serial.c **** 
 539:../freeRTOS750/lib_serial/lib_serial.c **** 	/* If error, return 0xFF */
 540:../freeRTOS750/lib_serial/lib_serial.c **** 	if ( UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) )
 541:../freeRTOS750/lib_serial/lib_serial.c **** 	return 0xFF;
 542:../freeRTOS750/lib_serial/lib_serial.c **** 	else
 543:../freeRTOS750/lib_serial/lib_serial.c **** 	return UDR0;
 544:../freeRTOS750/lib_serial/lib_serial.c **** }
 545:../freeRTOS750/lib_serial/lib_serial.c **** 
 546:../freeRTOS750/lib_serial/lib_serial.c **** inline int8_t avrSerialCheckRxComplete(void)
 547:../freeRTOS750/lib_serial/lib_serial.c **** {
 548:../freeRTOS750/lib_serial/lib_serial.c **** 	return( UCSR0A & (_BV(RXC0)) );			// nonzero if serial data is available to read.
 549:../freeRTOS750/lib_serial/lib_serial.c **** }
 550:../freeRTOS750/lib_serial/lib_serial.c **** 
 551:../freeRTOS750/lib_serial/lib_serial.c **** inline int8_t avrSerialCheckTxReady(void)
 552:../freeRTOS750/lib_serial/lib_serial.c **** {
 553:../freeRTOS750/lib_serial/lib_serial.c **** 	return( UCSR0A & (_BV(UDRE0)) );		// nonzero if transmit register is ready to receive new data.
 1753               	.LM173:
 1754 0592 9091 C000 		lds r25,192
 1755               	.LBE194:
 1756               	.LBE193:
 526:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialCheckTxReady())		// while NOT ready to transmit
 1758               	.LM174:
 1759 0596 95FF      		sbrs r25,5
 1760 0598 00C0      		rjmp .L67
 528:../freeRTOS750/lib_serial/lib_serial.c **** 	UDR0 = DataOut;
 1762               	.LM175:
 1763 059a 8093 C600 		sts 198,r24
 1764 059e 0895      		ret
 1766               	.Lscope15:
 1768               		.stabd	78,0,0
 1771               	.global	avrSerialPrint_P
 1773               	avrSerialPrint_P:
 1774               		.stabd	46,0,0
 514:../freeRTOS750/lib_serial/lib_serial.c **** {
 1776               	.LM176:
 1777               	.LFBB16:
 1778 05a0 EF92      		push r14
 1779 05a2 FF92      		push r15
 1780 05a4 0F93      		push r16
 1781 05a6 1F93      		push r17
 1782 05a8 CF93      		push r28
 1783 05aa DF93      		push r29
 1784               	/* prologue: function */
 1785               	/* frame size = 0 */
 1786               	/* stack size = 6 */
 1787               	.L__stack_usage = 6
 1788 05ac 8C01      		movw r16,r24
 1789               	.LBB195:
 1790               	.LBB196:
 1792               	.Ltext26:
 1794               	.LM177:
 1795 05ae 0E94 0000 		call __strlen_P
 1796 05b2 7C01      		movw r14,r24
 1797               	.LBE196:
 1798               	.LBE195:
 1800               	.Ltext27:
 515:../freeRTOS750/lib_serial/lib_serial.c **** 	uint16_t i = 0;
 1802               	.LM178:
 1803 05b4 C0E0      		ldi r28,0
 1804 05b6 D0E0      		ldi r29,0
 520:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 1806               	.LM179:
 1807 05b8 00C0      		rjmp .L69
 1808               	.L70:
 513:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialPrint_P(PGM_P str)
 1810               	.LM180:
 1811 05ba F801      		movw r30,r16
 1812 05bc EC0F      		add r30,r28
 1813 05be FD1F      		adc r31,r29
 1814               	.LBB197:
 521:../freeRTOS750/lib_serial/lib_serial.c **** 		avrSerialWrite(pgm_read_byte(&str[i++]));
 1816               	.LM181:
 1817 05c0 2196      		adiw r28,1
 1818               	/* #APP */
 1819               	 ;  521 "../freeRTOS750/lib_serial/lib_serial.c" 1
 1820 05c2 8491      		lpm r24, Z
 1821               		
 1822               	 ;  0 "" 2
 1823               	/* #NOAPP */
 1824               	.LBE197:
 1825 05c4 0E94 0000 		call avrSerialWrite
 1826               	.L69:
 520:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 1828               	.LM182:
 1829 05c8 CE15      		cp r28,r14
 1830 05ca DF05      		cpc r29,r15
 1831 05cc 01F4      		brne .L70
 1832               	/* epilogue start */
 522:../freeRTOS750/lib_serial/lib_serial.c **** }
 1834               	.LM183:
 1835 05ce DF91      		pop r29
 1836 05d0 CF91      		pop r28
 1837 05d2 1F91      		pop r17
 1838 05d4 0F91      		pop r16
 1839 05d6 FF90      		pop r15
 1840 05d8 EF90      		pop r14
 1841 05da 0895      		ret
 1847               	.Lscope16:
 1849               		.stabd	78,0,0
 1851               	.global	avrSerialPrint
 1853               	avrSerialPrint:
 1854               		.stabd	46,0,0
 503:../freeRTOS750/lib_serial/lib_serial.c **** {
 1856               	.LM184:
 1857               	.LFBB17:
 1858 05dc 0F93      		push r16
 1859 05de 1F93      		push r17
 1860 05e0 CF93      		push r28
 1861 05e2 DF93      		push r29
 1862               	/* prologue: function */
 1863               	/* frame size = 0 */
 1864               	/* stack size = 4 */
 1865               	.L__stack_usage = 4
 507:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen((char *)str);
 1867               	.LM185:
 1868 05e4 EC01      		movw r28,r24
 1869               		0:
 1870 05e6 0990      		ld __tmp_reg__,Y+
 1871 05e8 0020      		tst __tmp_reg__
 1872 05ea 01F4      		brne 0b
 1873 05ec 2197      		sbiw r28,1
 1874 05ee C81B      		sub r28,r24
 1875 05f0 D90B      		sbc r29,r25
 1876 05f2 8C01      		movw r16,r24
 502:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialPrint(uint8_t * str)
 1878               	.LM186:
 1879 05f4 C80F      		add r28,r24
 1880 05f6 D91F      		adc r29,r25
 509:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 1882               	.LM187:
 1883 05f8 00C0      		rjmp .L72
 1884               	.L73:
 510:../freeRTOS750/lib_serial/lib_serial.c **** 		avrSerialWrite(str[i++]);
 1886               	.LM188:
 1887 05fa F801      		movw r30,r16
 1888 05fc 8191      		ld r24,Z+
 1889 05fe 8F01      		movw r16,r30
 1890 0600 0E94 0000 		call avrSerialWrite
 1891               	.L72:
 509:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 1893               	.LM189:
 1894 0604 0C17      		cp r16,r28
 1895 0606 1D07      		cpc r17,r29
 1896 0608 01F4      		brne .L73
 1897               	/* epilogue start */
 511:../freeRTOS750/lib_serial/lib_serial.c **** }
 1899               	.LM190:
 1900 060a DF91      		pop r29
 1901 060c CF91      		pop r28
 1902 060e 1F91      		pop r17
 1903 0610 0F91      		pop r16
 1904 0612 0895      		ret
 1906               	.Lscope17:
 1908               		.stabd	78,0,0
 1911               	.global	avrSerialPrintf_P
 1913               	avrSerialPrintf_P:
 1914               		.stabd	46,0,0
 486:../freeRTOS750/lib_serial/lib_serial.c **** {
 1916               	.LM191:
 1917               	.LFBB18:
 1918 0614 CF93      		push r28
 1919 0616 DF93      		push r29
 1920 0618 CDB7      		in r28,__SP_L__
 1921 061a DEB7      		in r29,__SP_H__
 1922               	/* prologue: function */
 1923               	/* frame size = 0 */
 1924               	/* stack size = 2 */
 1925               	.L__stack_usage = 2
 1926 061c FE01      		movw r30,r28
 1927 061e 3596      		adiw r30,5
 1928 0620 4191      		ld r20,Z+
 1929 0622 5191      		ld r21,Z+
 489:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 1931               	.LM192:
 1932 0624 9F01      		movw r18,r30
 491:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 1934               	.LM193:
 1935 0626 00C0      		rjmp .L75
 1936               	.L76:
 1937               	.LBB198:
 1938               	.LBB199:
 1940               	.Ltext28:
 1942               	.LM194:
 1943 0628 88E0      		ldi r24,lo8(8)
 1944 062a 8A95      		1: dec r24
 1945 062c 01F4      		brne 1b
 1946 062e 0000      		nop
 1947               	.L75:
 1948               	.LBE199:
 1949               	.LBE198:
 1951               	.Ltext29:
 491:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 1953               	.LM195:
 1954 0630 8091 0000 		lds r24,xSerialPort+29
 1955 0634 8130      		cpi r24,lo8(1)
 1956 0636 01F0      		breq .L76
 492:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = ENGAGED;
 1958               	.LM196:
 1959 0638 81E0      		ldi r24,lo8(1)
 1960 063a 8093 0000 		sts xSerialPort+29,r24
 494:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf_P((char *)(xSerialPort.serialWorkBuffer), xSerialPort.serialWorkBufferSize, format, arg)
 1962               	.LM197:
 1963 063e 6091 0000 		lds r22,xSerialPort+27
 1964 0642 7091 0000 		lds r23,xSerialPort+27+1
 1965 0646 8091 0000 		lds r24,xSerialPort+25
 1966 064a 9091 0000 		lds r25,xSerialPort+25+1
 1967 064e 0E94 0000 		call vsnprintf_P
 495:../freeRTOS750/lib_serial/lib_serial.c **** 	avrSerialPrint((xSerialPort.serialWorkBuffer));
 1969               	.LM198:
 1970 0652 8091 0000 		lds r24,xSerialPort+25
 1971 0656 9091 0000 		lds r25,xSerialPort+25+1
 1972 065a 0E94 0000 		call avrSerialPrint
 497:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = VACANT;
 1974               	.LM199:
 1975 065e 1092 0000 		sts xSerialPort+29,__zero_reg__
 1976               	/* epilogue start */
 500:../freeRTOS750/lib_serial/lib_serial.c **** }
 1978               	.LM200:
 1979 0662 DF91      		pop r29
 1980 0664 CF91      		pop r28
 1981 0666 0895      		ret
 1984               	.Lscope18:
 1986               		.stabd	78,0,0
 1989               	.global	avrSerialPrintf
 1991               	avrSerialPrintf:
 1992               		.stabd	46,0,0
 469:../freeRTOS750/lib_serial/lib_serial.c **** {
 1994               	.LM201:
 1995               	.LFBB19:
 1996 0668 CF93      		push r28
 1997 066a DF93      		push r29
 1998 066c CDB7      		in r28,__SP_L__
 1999 066e DEB7      		in r29,__SP_H__
 2000               	/* prologue: function */
 2001               	/* frame size = 0 */
 2002               	/* stack size = 2 */
 2003               	.L__stack_usage = 2
 2004 0670 FE01      		movw r30,r28
 2005 0672 3596      		adiw r30,5
 2006 0674 4191      		ld r20,Z+
 2007 0676 5191      		ld r21,Z+
 472:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 2009               	.LM202:
 2010 0678 9F01      		movw r18,r30
 474:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 2012               	.LM203:
 2013 067a 00C0      		rjmp .L78
 2014               	.L79:
 2015               	.LBB200:
 2016               	.LBB201:
 2018               	.Ltext30:
 2020               	.LM204:
 2021 067c 88E0      		ldi r24,lo8(8)
 2022 067e 8A95      		1: dec r24
 2023 0680 01F4      		brne 1b
 2024 0682 0000      		nop
 2025               	.L78:
 2026               	.LBE201:
 2027               	.LBE200:
 2029               	.Ltext31:
 474:../freeRTOS750/lib_serial/lib_serial.c **** 	while(xSerialPort.serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 2031               	.LM205:
 2032 0684 8091 0000 		lds r24,xSerialPort+29
 2033 0688 8130      		cpi r24,lo8(1)
 2034 068a 01F0      		breq .L79
 475:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = ENGAGED;
 2036               	.LM206:
 2037 068c 81E0      		ldi r24,lo8(1)
 2038 068e 8093 0000 		sts xSerialPort+29,r24
 477:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf((char *)(xSerialPort.serialWorkBuffer), xSerialPort.serialWorkBufferSize, (const char *)
 2040               	.LM207:
 2041 0692 6091 0000 		lds r22,xSerialPort+27
 2042 0696 7091 0000 		lds r23,xSerialPort+27+1
 2043 069a 8091 0000 		lds r24,xSerialPort+25
 2044 069e 9091 0000 		lds r25,xSerialPort+25+1
 2045 06a2 0E94 0000 		call vsnprintf
 478:../freeRTOS750/lib_serial/lib_serial.c **** 	avrSerialPrint((xSerialPort.serialWorkBuffer));
 2047               	.LM208:
 2048 06a6 8091 0000 		lds r24,xSerialPort+25
 2049 06aa 9091 0000 		lds r25,xSerialPort+25+1
 2050 06ae 0E94 0000 		call avrSerialPrint
 480:../freeRTOS750/lib_serial/lib_serial.c **** 	xSerialPort.serialWorkBufferInUse = VACANT;
 2052               	.LM209:
 2053 06b2 1092 0000 		sts xSerialPort+29,__zero_reg__
 2054               	/* epilogue start */
 483:../freeRTOS750/lib_serial/lib_serial.c **** }
 2056               	.LM210:
 2057 06b6 DF91      		pop r29
 2058 06b8 CF91      		pop r28
 2059 06ba 0895      		ret
 2062               	.Lscope19:
 2064               		.stabd	78,0,0
 2066               	.global	avrSerialRead
 2068               	avrSerialRead:
 2069               		.stabd	46,0,0
 532:../freeRTOS750/lib_serial/lib_serial.c **** {
 2071               	.LM211:
 2072               	.LFBB20:
 2073               	/* prologue: function */
 2074               	/* frame size = 0 */
 2075               	/* stack size = 0 */
 2076               	.L__stack_usage = 0
 534:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialCheckRxComplete())		// While data is NOT available to read
 2078               	.LM212:
 2079 06bc 00C0      		rjmp .L81
 2080               	.L82:
 2081               	.LBB202:
 2082               	.LBB203:
 2084               	.Ltext32:
 2086               	.LM213:
 2087 06be 88E0      		ldi r24,lo8(8)
 2088 06c0 8A95      		1: dec r24
 2089 06c2 01F4      		brne 1b
 2090 06c4 0000      		nop
 2091               	.L81:
 2092               	.LBE203:
 2093               	.LBE202:
 2094               	.LBB204:
 2095               	.LBB205:
 2097               	.Ltext33:
 548:../freeRTOS750/lib_serial/lib_serial.c **** 	return( UCSR0A & (_BV(RXC0)) );			// nonzero if serial data is available to read.
 2099               	.LM214:
 2100 06c6 8091 C000 		lds r24,192
 2101               	.LBE205:
 2102               	.LBE204:
 534:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialCheckRxComplete())		// While data is NOT available to read
 2104               	.LM215:
 2105 06ca 87FF      		sbrs r24,7
 2106 06cc 00C0      		rjmp .L82
 540:../freeRTOS750/lib_serial/lib_serial.c **** 	if ( UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) )
 2108               	.LM216:
 2109 06ce 8091 C000 		lds r24,192
 2110 06d2 8C71      		andi r24,lo8(28)
 2111 06d4 01F4      		brne .L84
 543:../freeRTOS750/lib_serial/lib_serial.c **** 	return UDR0;
 2113               	.LM217:
 2114 06d6 8091 C600 		lds r24,198
 2115 06da 0895      		ret
 2116               	.L84:
 541:../freeRTOS750/lib_serial/lib_serial.c **** 	return 0xFF;
 2118               	.LM218:
 2119 06dc 8FEF      		ldi r24,lo8(-1)
 544:../freeRTOS750/lib_serial/lib_serial.c **** }
 2121               	.LM219:
 2122 06de 0895      		ret
 2124               	.Lscope20:
 2126               		.stabd	78,0,0
 2128               	.global	avrSerialCheckRxComplete
 2130               	avrSerialCheckRxComplete:
 2131               		.stabd	46,0,0
 547:../freeRTOS750/lib_serial/lib_serial.c **** {
 2133               	.LM220:
 2134               	.LFBB21:
 2135               	/* prologue: function */
 2136               	/* frame size = 0 */
 2137               	/* stack size = 0 */
 2138               	.L__stack_usage = 0
 548:../freeRTOS750/lib_serial/lib_serial.c **** 	return( UCSR0A & (_BV(RXC0)) );			// nonzero if serial data is available to read.
 2140               	.LM221:
 2141 06e0 8091 C000 		lds r24,192
 549:../freeRTOS750/lib_serial/lib_serial.c **** }
 2143               	.LM222:
 2144 06e4 8078      		andi r24,lo8(-128)
 2145 06e6 0895      		ret
 2147               	.Lscope21:
 2149               		.stabd	78,0,0
 2151               	.global	avrSerialCheckTxReady
 2153               	avrSerialCheckTxReady:
 2154               		.stabd	46,0,0
 552:../freeRTOS750/lib_serial/lib_serial.c **** {
 2156               	.LM223:
 2157               	.LFBB22:
 2158               	/* prologue: function */
 2159               	/* frame size = 0 */
 2160               	/* stack size = 0 */
 2161               	.L__stack_usage = 0
 2163               	.LM224:
 2164 06e8 8091 C000 		lds r24,192
 554:../freeRTOS750/lib_serial/lib_serial.c **** }
 2166               	.LM225:
 2167 06ec 8072      		andi r24,lo8(32)
 2168 06ee 0895      		ret
 2170               	.Lscope22:
 2172               		.stabd	78,0,0
 2175               	.global	avrSerialxCheckRxComplete
 2177               	avrSerialxCheckRxComplete:
 2178               		.stabd	46,0,0
 555:../freeRTOS750/lib_serial/lib_serial.c **** 
 556:../freeRTOS750/lib_serial/lib_serial.c **** /*-----------------------------------------------------------*/
 557:../freeRTOS750/lib_serial/lib_serial.c **** 
 558:../freeRTOS750/lib_serial/lib_serial.c **** // Polling read and write routines, for use before freeRTOS vTaskStartScheduler (interrupts enabled
 559:../freeRTOS750/lib_serial/lib_serial.c **** // Same as above, but doesn't use interrupts.
 560:../freeRTOS750/lib_serial/lib_serial.c **** // These can be set to use any USART (but only two implemented for now).
 561:../freeRTOS750/lib_serial/lib_serial.c **** 
 562:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialxPrintf(xComPortHandlePtr pxPort, const char * format, ...)
 563:../freeRTOS750/lib_serial/lib_serial.c **** {
 564:../freeRTOS750/lib_serial/lib_serial.c **** 	va_list arg;
 565:../freeRTOS750/lib_serial/lib_serial.c **** 
 566:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 567:../freeRTOS750/lib_serial/lib_serial.c **** 
 568:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 569:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = ENGAGED;
 570:../freeRTOS750/lib_serial/lib_serial.c **** 
 571:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf((char *)(pxPort->serialWorkBuffer), pxPort->serialWorkBufferSize, (const char *)format, 
 572:../freeRTOS750/lib_serial/lib_serial.c **** 	avrSerialxPrint(pxPort, pxPort->serialWorkBuffer);
 573:../freeRTOS750/lib_serial/lib_serial.c **** 
 574:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = VACANT;
 575:../freeRTOS750/lib_serial/lib_serial.c **** 
 576:../freeRTOS750/lib_serial/lib_serial.c **** 	va_end(arg);
 577:../freeRTOS750/lib_serial/lib_serial.c **** }
 578:../freeRTOS750/lib_serial/lib_serial.c **** 
 579:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialxPrintf_P(xComPortHandlePtr pxPort, PGM_P format, ...)
 580:../freeRTOS750/lib_serial/lib_serial.c **** {
 581:../freeRTOS750/lib_serial/lib_serial.c **** 	va_list arg;
 582:../freeRTOS750/lib_serial/lib_serial.c **** 
 583:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 584:../freeRTOS750/lib_serial/lib_serial.c **** 
 585:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 586:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = ENGAGED;
 587:../freeRTOS750/lib_serial/lib_serial.c **** 
 588:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf_P((char *)(pxPort->serialWorkBuffer), pxPort->serialWorkBufferSize, format, arg);
 589:../freeRTOS750/lib_serial/lib_serial.c **** 	avrSerialxPrint(pxPort, pxPort->serialWorkBuffer);
 590:../freeRTOS750/lib_serial/lib_serial.c **** 
 591:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = VACANT;
 592:../freeRTOS750/lib_serial/lib_serial.c **** 
 593:../freeRTOS750/lib_serial/lib_serial.c **** 	va_end(arg);
 594:../freeRTOS750/lib_serial/lib_serial.c **** }
 595:../freeRTOS750/lib_serial/lib_serial.c **** 
 596:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialxPrint(xComPortHandlePtr pxPort, uint8_t * str)
 597:../freeRTOS750/lib_serial/lib_serial.c **** {
 598:../freeRTOS750/lib_serial/lib_serial.c **** 	uint16_t i = 0;
 599:../freeRTOS750/lib_serial/lib_serial.c **** 	size_t stringlength;
 600:../freeRTOS750/lib_serial/lib_serial.c **** 
 601:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen((char *)str);
 602:../freeRTOS750/lib_serial/lib_serial.c **** 
 603:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 604:../freeRTOS750/lib_serial/lib_serial.c **** 		avrSerialxWrite(pxPort, str[i++]);
 605:../freeRTOS750/lib_serial/lib_serial.c **** }
 606:../freeRTOS750/lib_serial/lib_serial.c **** 
 607:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialxPrint_P(xComPortHandlePtr pxPort, PGM_P str)
 608:../freeRTOS750/lib_serial/lib_serial.c **** {
 609:../freeRTOS750/lib_serial/lib_serial.c **** 	uint16_t i = 0;
 610:../freeRTOS750/lib_serial/lib_serial.c **** 	size_t stringlength;
 611:../freeRTOS750/lib_serial/lib_serial.c **** 
 612:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen_P(str);
 613:../freeRTOS750/lib_serial/lib_serial.c **** 
 614:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 615:../freeRTOS750/lib_serial/lib_serial.c **** 		avrSerialxWrite(pxPort, pgm_read_byte(&str[i++]));
 616:../freeRTOS750/lib_serial/lib_serial.c **** }
 617:../freeRTOS750/lib_serial/lib_serial.c **** 
 618:../freeRTOS750/lib_serial/lib_serial.c **** inline void avrSerialxWrite(xComPortHandlePtr pxPort, int8_t DataOut)
 619:../freeRTOS750/lib_serial/lib_serial.c **** {
 620:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialxCheckTxReady(pxPort))		// while NOT ready to transmit
 621:../freeRTOS750/lib_serial/lib_serial.c ****         _delay_us(25);     						// delay
 622:../freeRTOS750/lib_serial/lib_serial.c **** 
 623:../freeRTOS750/lib_serial/lib_serial.c **** 	switch (pxPort->usart)
 624:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 625:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART0:
 626:../freeRTOS750/lib_serial/lib_serial.c **** 			UDR0 = DataOut;
 627:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 628:../freeRTOS750/lib_serial/lib_serial.c **** 
 629:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART1:
 630:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) || d
 631:../freeRTOS750/lib_serial/lib_serial.c **** 			UDR1 = DataOut;
 632:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 633:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 634:../freeRTOS750/lib_serial/lib_serial.c **** 
 635:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART2:
 636:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART3:
 637:../freeRTOS750/lib_serial/lib_serial.c **** 		default:
 638:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 639:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 640:../freeRTOS750/lib_serial/lib_serial.c **** }
 641:../freeRTOS750/lib_serial/lib_serial.c **** 
 642:../freeRTOS750/lib_serial/lib_serial.c **** inline int8_t avrSerialxRead(xComPortHandlePtr pxPort)
 643:../freeRTOS750/lib_serial/lib_serial.c **** {
 644:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialxCheckRxComplete(pxPort))	// While data is NOT available to read
 645:../freeRTOS750/lib_serial/lib_serial.c **** 		_delay_us(25);     						// delay
 646:../freeRTOS750/lib_serial/lib_serial.c **** 	/* Get status and data */
 647:../freeRTOS750/lib_serial/lib_serial.c **** 	/* from buffer */
 648:../freeRTOS750/lib_serial/lib_serial.c **** 
 649:../freeRTOS750/lib_serial/lib_serial.c **** 	switch (pxPort->usart)
 650:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 651:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART0:
 652:../freeRTOS750/lib_serial/lib_serial.c **** 			/* If error, return 0xFF */
 653:../freeRTOS750/lib_serial/lib_serial.c **** 			if ( UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) )
 654:../freeRTOS750/lib_serial/lib_serial.c **** 				return 0xFF;
 655:../freeRTOS750/lib_serial/lib_serial.c **** 			else
 656:../freeRTOS750/lib_serial/lib_serial.c **** 				return UDR0;
 657:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 658:../freeRTOS750/lib_serial/lib_serial.c **** 
 659:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART1:
 660:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) || d
 661:../freeRTOS750/lib_serial/lib_serial.c **** 			/* If error, return 0xFF */
 662:../freeRTOS750/lib_serial/lib_serial.c **** 			if ( UCSR1A & (_BV(FE1)|_BV(DOR1)|_BV(UPE1)) )
 663:../freeRTOS750/lib_serial/lib_serial.c **** 				return 0xFF;
 664:../freeRTOS750/lib_serial/lib_serial.c **** 			else
 665:../freeRTOS750/lib_serial/lib_serial.c **** 				return UDR1;
 666:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 667:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 668:../freeRTOS750/lib_serial/lib_serial.c **** 
 669:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART2:
 670:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART3:
 671:../freeRTOS750/lib_serial/lib_serial.c **** 		default:
 672:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 673:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 674:../freeRTOS750/lib_serial/lib_serial.c **** 	/* If error, return 0xFF */
 675:../freeRTOS750/lib_serial/lib_serial.c **** 	return 0xFF;
 676:../freeRTOS750/lib_serial/lib_serial.c **** }
 677:../freeRTOS750/lib_serial/lib_serial.c **** 
 678:../freeRTOS750/lib_serial/lib_serial.c **** inline int8_t avrSerialxCheckRxComplete(xComPortHandlePtr pxPort )
 679:../freeRTOS750/lib_serial/lib_serial.c **** {
 2180               	.LM226:
 2181               	.LFBB23:
 2182               	/* prologue: function */
 2183               	/* frame size = 0 */
 2184               	/* stack size = 0 */
 2185               	.L__stack_usage = 0
 680:../freeRTOS750/lib_serial/lib_serial.c **** 	switch (pxPort->usart)
 2187               	.LM227:
 2188 06f0 FC01      		movw r30,r24
 2189 06f2 8081      		ld r24,Z
 2190 06f4 8111      		cpse r24,__zero_reg__
 2191 06f6 00C0      		rjmp .L91
 681:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 682:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART0:
 683:../freeRTOS750/lib_serial/lib_serial.c **** 			return( UCSR0A & (_BV(RXC0)) );			// nonzero if serial data is available to read.
 2193               	.LM228:
 2194 06f8 8091 C000 		lds r24,192
 2195 06fc 8078      		andi r24,lo8(-128)
 2196 06fe 0895      		ret
 2197               	.L91:
 684:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 685:../freeRTOS750/lib_serial/lib_serial.c **** 
 686:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART1:
 687:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) || d
 688:../freeRTOS750/lib_serial/lib_serial.c **** 			return( UCSR1A & (_BV(RXC1)) );			// nonzero if serial data is available to read.
 689:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 690:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 691:../freeRTOS750/lib_serial/lib_serial.c **** 
 692:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART2:
 693:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART3:
 694:../freeRTOS750/lib_serial/lib_serial.c **** 		default:
 695:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 696:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 697:../freeRTOS750/lib_serial/lib_serial.c **** 	return 0;
 2199               	.LM229:
 2200 0700 80E0      		ldi r24,0
 698:../freeRTOS750/lib_serial/lib_serial.c **** }
 2202               	.LM230:
 2203 0702 0895      		ret
 2205               	.Lscope23:
 2207               		.stabd	78,0,0
 2210               	.global	avrSerialxRead
 2212               	avrSerialxRead:
 2213               		.stabd	46,0,0
 643:../freeRTOS750/lib_serial/lib_serial.c **** {
 2215               	.LM231:
 2216               	.LFBB24:
 2217 0704 CF93      		push r28
 2218 0706 DF93      		push r29
 2219               	/* prologue: function */
 2220               	/* frame size = 0 */
 2221               	/* stack size = 2 */
 2222               	.L__stack_usage = 2
 2223 0708 EC01      		movw r28,r24
 644:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialxCheckRxComplete(pxPort))	// While data is NOT available to read
 2225               	.LM232:
 2226 070a 00C0      		rjmp .L93
 2227               	.L94:
 2228               	.LBB206:
 2229               	.LBB207:
 2231               	.Ltext34:
 2233               	.LM233:
 2234 070c 88E0      		ldi r24,lo8(8)
 2235 070e 8A95      		1: dec r24
 2236 0710 01F4      		brne 1b
 2237 0712 0000      		nop
 2238               	.L93:
 2239               	.LBE207:
 2240               	.LBE206:
 2242               	.Ltext35:
 644:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialxCheckRxComplete(pxPort))	// While data is NOT available to read
 2244               	.LM234:
 2245 0714 CE01      		movw r24,r28
 2246 0716 0E94 0000 		call avrSerialxCheckRxComplete
 2247 071a 8823      		tst r24
 2248 071c 01F0      		breq .L94
 649:../freeRTOS750/lib_serial/lib_serial.c **** 	switch (pxPort->usart)
 2250               	.LM235:
 2251 071e 8881      		ld r24,Y
 2252 0720 8111      		cpse r24,__zero_reg__
 2253 0722 00C0      		rjmp .L98
 653:../freeRTOS750/lib_serial/lib_serial.c **** 			if ( UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) )
 2255               	.LM236:
 2256 0724 8091 C000 		lds r24,192
 2257 0728 8C71      		andi r24,lo8(28)
 2258 072a 01F4      		brne .L98
 656:../freeRTOS750/lib_serial/lib_serial.c **** 				return UDR0;
 2260               	.LM237:
 2261 072c 8091 C600 		lds r24,198
 2262 0730 00C0      		rjmp .L95
 2263               	.L98:
 654:../freeRTOS750/lib_serial/lib_serial.c **** 				return 0xFF;
 2265               	.LM238:
 2266 0732 8FEF      		ldi r24,lo8(-1)
 2267               	.L95:
 2268               	/* epilogue start */
 676:../freeRTOS750/lib_serial/lib_serial.c **** }
 2270               	.LM239:
 2271 0734 DF91      		pop r29
 2272 0736 CF91      		pop r28
 2273 0738 0895      		ret
 2275               	.Lscope24:
 2277               		.stabd	78,0,0
 2280               	.global	avrSerialxCheckTxReady
 2282               	avrSerialxCheckTxReady:
 2283               		.stabd	46,0,0
 699:../freeRTOS750/lib_serial/lib_serial.c **** 
 700:../freeRTOS750/lib_serial/lib_serial.c **** inline int8_t avrSerialxCheckTxReady(xComPortHandlePtr pxPort )
 701:../freeRTOS750/lib_serial/lib_serial.c **** {
 2285               	.LM240:
 2286               	.LFBB25:
 2287               	/* prologue: function */
 2288               	/* frame size = 0 */
 2289               	/* stack size = 0 */
 2290               	.L__stack_usage = 0
 702:../freeRTOS750/lib_serial/lib_serial.c **** 	switch (pxPort->usart)
 2292               	.LM241:
 2293 073a FC01      		movw r30,r24
 2294 073c 8081      		ld r24,Z
 2295 073e 8111      		cpse r24,__zero_reg__
 2296 0740 00C0      		rjmp .L104
 703:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 704:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART0:
 705:../freeRTOS750/lib_serial/lib_serial.c **** 			return( UCSR0A & (_BV(UDRE0)) );		// nonzero if transmit register is ready to receive new data.
 2298               	.LM242:
 2299 0742 8091 C000 		lds r24,192
 2300 0746 8072      		andi r24,lo8(32)
 2301 0748 0895      		ret
 2302               	.L104:
 706:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 707:../freeRTOS750/lib_serial/lib_serial.c **** 
 708:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART1:
 709:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) || d
 710:../freeRTOS750/lib_serial/lib_serial.c **** 			return( UCSR1A & (_BV(UDRE1)) );		// nonzero if transmit register is ready to receive new data.
 711:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 712:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 713:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART2:
 714:../freeRTOS750/lib_serial/lib_serial.c **** 		case USART3:
 715:../freeRTOS750/lib_serial/lib_serial.c **** 		default:
 716:../freeRTOS750/lib_serial/lib_serial.c **** 			break;
 717:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 718:../freeRTOS750/lib_serial/lib_serial.c **** 	return 0;
 2304               	.LM243:
 2305 074a 80E0      		ldi r24,0
 719:../freeRTOS750/lib_serial/lib_serial.c **** }
 2307               	.LM244:
 2308 074c 0895      		ret
 2310               	.Lscope25:
 2312               		.stabd	78,0,0
 2316               	.global	avrSerialxWrite
 2318               	avrSerialxWrite:
 2319               		.stabd	46,0,0
 619:../freeRTOS750/lib_serial/lib_serial.c **** {
 2321               	.LM245:
 2322               	.LFBB26:
 2323 074e 0F93      		push r16
 2324 0750 1F93      		push r17
 2325 0752 CF93      		push r28
 2326 0754 DF93      		push r29
 2327 0756 1F92      		push __zero_reg__
 2328 0758 CDB7      		in r28,__SP_L__
 2329 075a DEB7      		in r29,__SP_H__
 2330               	/* prologue: function */
 2331               	/* frame size = 1 */
 2332               	/* stack size = 5 */
 2333               	.L__stack_usage = 5
 2334 075c 8C01      		movw r16,r24
 620:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialxCheckTxReady(pxPort))		// while NOT ready to transmit
 2336               	.LM246:
 2337 075e 00C0      		rjmp .L106
 2338               	.L107:
 2339               	.LBB208:
 2340               	.LBB209:
 2342               	.Ltext36:
 2344               	.LM247:
 2345 0760 88E0      		ldi r24,lo8(8)
 2346 0762 8A95      		1: dec r24
 2347 0764 01F4      		brne 1b
 2348 0766 0000      		nop
 2349               	.L106:
 2350               	.LBE209:
 2351               	.LBE208:
 2353               	.Ltext37:
 620:../freeRTOS750/lib_serial/lib_serial.c **** 	while (!avrSerialxCheckTxReady(pxPort))		// while NOT ready to transmit
 2355               	.LM248:
 2356 0768 C801      		movw r24,r16
 2357 076a 6983      		std Y+1,r22
 2358 076c 0E94 0000 		call avrSerialxCheckTxReady
 2359 0770 6981      		ldd r22,Y+1
 2360 0772 8823      		tst r24
 2361 0774 01F0      		breq .L107
 623:../freeRTOS750/lib_serial/lib_serial.c **** 	switch (pxPort->usart)
 2363               	.LM249:
 2364 0776 F801      		movw r30,r16
 2365 0778 8081      		ld r24,Z
 2366 077a 8111      		cpse r24,__zero_reg__
 2367 077c 00C0      		rjmp .L105
 626:../freeRTOS750/lib_serial/lib_serial.c **** 			UDR0 = DataOut;
 2369               	.LM250:
 2370 077e 6093 C600 		sts 198,r22
 2371               	.L105:
 2372               	/* epilogue start */
 640:../freeRTOS750/lib_serial/lib_serial.c **** }
 2374               	.LM251:
 2375 0782 0F90      		pop __tmp_reg__
 2376 0784 DF91      		pop r29
 2377 0786 CF91      		pop r28
 2378 0788 1F91      		pop r17
 2379 078a 0F91      		pop r16
 2380 078c 0895      		ret
 2382               	.Lscope26:
 2384               		.stabd	78,0,0
 2388               	.global	avrSerialxPrint_P
 2390               	avrSerialxPrint_P:
 2391               		.stabd	46,0,0
 608:../freeRTOS750/lib_serial/lib_serial.c **** {
 2393               	.LM252:
 2394               	.LFBB27:
 2395 078e CF92      		push r12
 2396 0790 DF92      		push r13
 2397 0792 EF92      		push r14
 2398 0794 FF92      		push r15
 2399 0796 0F93      		push r16
 2400 0798 1F93      		push r17
 2401 079a CF93      		push r28
 2402 079c DF93      		push r29
 2403               	/* prologue: function */
 2404               	/* frame size = 0 */
 2405               	/* stack size = 8 */
 2406               	.L__stack_usage = 8
 2407 079e 7C01      		movw r14,r24
 2408 07a0 8B01      		movw r16,r22
 2409               	.LBB210:
 2410               	.LBB211:
 2412               	.Ltext38:
 2414               	.LM253:
 2415 07a2 CB01      		movw r24,r22
 2416 07a4 0E94 0000 		call __strlen_P
 2417 07a8 6C01      		movw r12,r24
 2418               	.LBE211:
 2419               	.LBE210:
 2421               	.Ltext39:
 609:../freeRTOS750/lib_serial/lib_serial.c **** 	uint16_t i = 0;
 2423               	.LM254:
 2424 07aa C0E0      		ldi r28,0
 2425 07ac D0E0      		ldi r29,0
 614:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 2427               	.LM255:
 2428 07ae 00C0      		rjmp .L111
 2429               	.L112:
 607:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialxPrint_P(xComPortHandlePtr pxPort, PGM_P str)
 2431               	.LM256:
 2432 07b0 F801      		movw r30,r16
 2433 07b2 EC0F      		add r30,r28
 2434 07b4 FD1F      		adc r31,r29
 2435               	.LBB212:
 615:../freeRTOS750/lib_serial/lib_serial.c **** 		avrSerialxWrite(pxPort, pgm_read_byte(&str[i++]));
 2437               	.LM257:
 2438 07b6 2196      		adiw r28,1
 2439               	/* #APP */
 2440               	 ;  615 "../freeRTOS750/lib_serial/lib_serial.c" 1
 2441 07b8 6491      		lpm r22, Z
 2442               		
 2443               	 ;  0 "" 2
 2444               	/* #NOAPP */
 2445               	.LBE212:
 2446 07ba C701      		movw r24,r14
 2447 07bc 0E94 0000 		call avrSerialxWrite
 2448               	.L111:
 614:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 2450               	.LM258:
 2451 07c0 CC15      		cp r28,r12
 2452 07c2 DD05      		cpc r29,r13
 2453 07c4 01F4      		brne .L112
 2454               	/* epilogue start */
 616:../freeRTOS750/lib_serial/lib_serial.c **** }
 2456               	.LM259:
 2457 07c6 DF91      		pop r29
 2458 07c8 CF91      		pop r28
 2459 07ca 1F91      		pop r17
 2460 07cc 0F91      		pop r16
 2461 07ce FF90      		pop r15
 2462 07d0 EF90      		pop r14
 2463 07d2 DF90      		pop r13
 2464 07d4 CF90      		pop r12
 2465 07d6 0895      		ret
 2471               	.Lscope27:
 2473               		.stabd	78,0,0
 2476               	.global	avrSerialxPrint
 2478               	avrSerialxPrint:
 2479               		.stabd	46,0,0
 597:../freeRTOS750/lib_serial/lib_serial.c **** {
 2481               	.LM260:
 2482               	.LFBB28:
 2483 07d8 EF92      		push r14
 2484 07da FF92      		push r15
 2485 07dc 0F93      		push r16
 2486 07de 1F93      		push r17
 2487 07e0 CF93      		push r28
 2488 07e2 DF93      		push r29
 2489               	/* prologue: function */
 2490               	/* frame size = 0 */
 2491               	/* stack size = 6 */
 2492               	.L__stack_usage = 6
 2493 07e4 7C01      		movw r14,r24
 601:../freeRTOS750/lib_serial/lib_serial.c **** 	stringlength = strlen((char *)str);
 2495               	.LM261:
 2496 07e6 EB01      		movw r28,r22
 2497               		0:
 2498 07e8 0990      		ld __tmp_reg__,Y+
 2499 07ea 0020      		tst __tmp_reg__
 2500 07ec 01F4      		brne 0b
 2501 07ee 2197      		sbiw r28,1
 2502 07f0 C61B      		sub r28,r22
 2503 07f2 D70B      		sbc r29,r23
 2504 07f4 8B01      		movw r16,r22
 596:../freeRTOS750/lib_serial/lib_serial.c **** void avrSerialxPrint(xComPortHandlePtr pxPort, uint8_t * str)
 2506               	.LM262:
 2507 07f6 C60F      		add r28,r22
 2508 07f8 D71F      		adc r29,r23
 603:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 2510               	.LM263:
 2511 07fa 00C0      		rjmp .L114
 2512               	.L115:
 604:../freeRTOS750/lib_serial/lib_serial.c **** 		avrSerialxWrite(pxPort, str[i++]);
 2514               	.LM264:
 2515 07fc F801      		movw r30,r16
 2516 07fe 6191      		ld r22,Z+
 2517 0800 8F01      		movw r16,r30
 2518 0802 C701      		movw r24,r14
 2519 0804 0E94 0000 		call avrSerialxWrite
 2520               	.L114:
 603:../freeRTOS750/lib_serial/lib_serial.c **** 	while(i < stringlength)
 2522               	.LM265:
 2523 0808 0C17      		cp r16,r28
 2524 080a 1D07      		cpc r17,r29
 2525 080c 01F4      		brne .L115
 2526               	/* epilogue start */
 605:../freeRTOS750/lib_serial/lib_serial.c **** }
 2528               	.LM266:
 2529 080e DF91      		pop r29
 2530 0810 CF91      		pop r28
 2531 0812 1F91      		pop r17
 2532 0814 0F91      		pop r16
 2533 0816 FF90      		pop r15
 2534 0818 EF90      		pop r14
 2535 081a 0895      		ret
 2537               	.Lscope28:
 2539               		.stabd	78,0,0
 2543               	.global	avrSerialxPrintf_P
 2545               	avrSerialxPrintf_P:
 2546               		.stabd	46,0,0
 580:../freeRTOS750/lib_serial/lib_serial.c **** {
 2548               	.LM267:
 2549               	.LFBB29:
 2550 081c 0F93      		push r16
 2551 081e 1F93      		push r17
 2552 0820 CF93      		push r28
 2553 0822 DF93      		push r29
 2554 0824 CDB7      		in r28,__SP_L__
 2555 0826 DEB7      		in r29,__SP_H__
 2556               	/* prologue: function */
 2557               	/* frame size = 0 */
 2558               	/* stack size = 4 */
 2559               	.L__stack_usage = 4
 2560 0828 0F81      		ldd r16,Y+7
 2561 082a 1885      		ldd r17,Y+8
 583:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 2563               	.LM268:
 2564 082c CE01      		movw r24,r28
 2565 082e 0B96      		adiw r24,11
 2566 0830 9C01      		movw r18,r24
 585:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 2568               	.LM269:
 2569 0832 00C0      		rjmp .L117
 2570               	.L118:
 2571               	.LBB213:
 2572               	.LBB214:
 2574               	.Ltext40:
 2576               	.LM270:
 2577 0834 88E0      		ldi r24,lo8(8)
 2578 0836 8A95      		1: dec r24
 2579 0838 01F4      		brne 1b
 2580 083a 0000      		nop
 2581               	.L117:
 2582               	.LBE214:
 2583               	.LBE213:
 2585               	.Ltext41:
 585:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 2587               	.LM271:
 2588 083c F801      		movw r30,r16
 2589 083e 858D      		ldd r24,Z+29
 2590 0840 8130      		cpi r24,lo8(1)
 2591 0842 01F0      		breq .L118
 586:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = ENGAGED;
 2593               	.LM272:
 2594 0844 81E0      		ldi r24,lo8(1)
 2595 0846 858F      		std Z+29,r24
 588:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf_P((char *)(pxPort->serialWorkBuffer), pxPort->serialWorkBufferSize, format, arg);
 2597               	.LM273:
 2598 0848 638D      		ldd r22,Z+27
 2599 084a 748D      		ldd r23,Z+28
 2600 084c 4985      		ldd r20,Y+9
 2601 084e 5A85      		ldd r21,Y+10
 2602 0850 818D      		ldd r24,Z+25
 2603 0852 928D      		ldd r25,Z+26
 2604 0854 0E94 0000 		call vsnprintf_P
 589:../freeRTOS750/lib_serial/lib_serial.c **** 	avrSerialxPrint(pxPort, pxPort->serialWorkBuffer);
 2606               	.LM274:
 2607 0858 F801      		movw r30,r16
 2608 085a 618D      		ldd r22,Z+25
 2609 085c 728D      		ldd r23,Z+26
 2610 085e C801      		movw r24,r16
 2611 0860 0E94 0000 		call avrSerialxPrint
 591:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = VACANT;
 2613               	.LM275:
 2614 0864 F801      		movw r30,r16
 2615 0866 158E      		std Z+29,__zero_reg__
 2616               	/* epilogue start */
 594:../freeRTOS750/lib_serial/lib_serial.c **** }
 2618               	.LM276:
 2619 0868 DF91      		pop r29
 2620 086a CF91      		pop r28
 2621 086c 1F91      		pop r17
 2622 086e 0F91      		pop r16
 2623 0870 0895      		ret
 2626               	.Lscope29:
 2628               		.stabd	78,0,0
 2632               	.global	avrSerialxPrintf
 2634               	avrSerialxPrintf:
 2635               		.stabd	46,0,0
 563:../freeRTOS750/lib_serial/lib_serial.c **** {
 2637               	.LM277:
 2638               	.LFBB30:
 2639 0872 0F93      		push r16
 2640 0874 1F93      		push r17
 2641 0876 CF93      		push r28
 2642 0878 DF93      		push r29
 2643 087a CDB7      		in r28,__SP_L__
 2644 087c DEB7      		in r29,__SP_H__
 2645               	/* prologue: function */
 2646               	/* frame size = 0 */
 2647               	/* stack size = 4 */
 2648               	.L__stack_usage = 4
 2649 087e 0F81      		ldd r16,Y+7
 2650 0880 1885      		ldd r17,Y+8
 566:../freeRTOS750/lib_serial/lib_serial.c **** 	va_start(arg, format);
 2652               	.LM278:
 2653 0882 CE01      		movw r24,r28
 2654 0884 0B96      		adiw r24,11
 2655 0886 9C01      		movw r18,r24
 568:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 2657               	.LM279:
 2658 0888 00C0      		rjmp .L120
 2659               	.L121:
 2660               	.LBB215:
 2661               	.LBB216:
 2663               	.Ltext42:
 2665               	.LM280:
 2666 088a 88E0      		ldi r24,lo8(8)
 2667 088c 8A95      		1: dec r24
 2668 088e 01F4      		brne 1b
 2669 0890 0000      		nop
 2670               	.L120:
 2671               	.LBE216:
 2672               	.LBE215:
 2674               	.Ltext43:
 568:../freeRTOS750/lib_serial/lib_serial.c **** 	while(pxPort->serialWorkBufferInUse == ENGAGED ) _delay_us(25);
 2676               	.LM281:
 2677 0892 F801      		movw r30,r16
 2678 0894 858D      		ldd r24,Z+29
 2679 0896 8130      		cpi r24,lo8(1)
 2680 0898 01F0      		breq .L121
 569:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = ENGAGED;
 2682               	.LM282:
 2683 089a 81E0      		ldi r24,lo8(1)
 2684 089c 858F      		std Z+29,r24
 571:../freeRTOS750/lib_serial/lib_serial.c **** 	vsnprintf((char *)(pxPort->serialWorkBuffer), pxPort->serialWorkBufferSize, (const char *)format, 
 2686               	.LM283:
 2687 089e 638D      		ldd r22,Z+27
 2688 08a0 748D      		ldd r23,Z+28
 2689 08a2 4985      		ldd r20,Y+9
 2690 08a4 5A85      		ldd r21,Y+10
 2691 08a6 818D      		ldd r24,Z+25
 2692 08a8 928D      		ldd r25,Z+26
 2693 08aa 0E94 0000 		call vsnprintf
 572:../freeRTOS750/lib_serial/lib_serial.c **** 	avrSerialxPrint(pxPort, pxPort->serialWorkBuffer);
 2695               	.LM284:
 2696 08ae F801      		movw r30,r16
 2697 08b0 618D      		ldd r22,Z+25
 2698 08b2 728D      		ldd r23,Z+26
 2699 08b4 C801      		movw r24,r16
 2700 08b6 0E94 0000 		call avrSerialxPrint
 574:../freeRTOS750/lib_serial/lib_serial.c **** 	pxPort->serialWorkBufferInUse = VACANT;
 2702               	.LM285:
 2703 08ba F801      		movw r30,r16
 2704 08bc 158E      		std Z+29,__zero_reg__
 2705               	/* epilogue start */
 577:../freeRTOS750/lib_serial/lib_serial.c **** }
 2707               	.LM286:
 2708 08be DF91      		pop r29
 2709 08c0 CF91      		pop r28
 2710 08c2 1F91      		pop r17
 2711 08c4 0F91      		pop r16
 2712 08c6 0895      		ret
 2715               	.Lscope30:
 2717               		.stabd	78,0,0
 2719               	.global	__vector_18
 2721               	__vector_18:
 2722               		.stabd	46,0,0
 720:../freeRTOS750/lib_serial/lib_serial.c **** /*-----------------------------------------------------------*/
 721:../freeRTOS750/lib_serial/lib_serial.c **** 
 722:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || def
 723:../freeRTOS750/lib_serial/lib_serial.c **** ISR( USART0_RX_vect )
 724:../freeRTOS750/lib_serial/lib_serial.c **** #elif defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) ||
 725:../freeRTOS750/lib_serial/lib_serial.c **** ISR( USART0_RX_vect )
 726:../freeRTOS750/lib_serial/lib_serial.c **** #elif defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__)
 727:../freeRTOS750/lib_serial/lib_serial.c **** ISR( USART_RX_vect )
 728:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 729:../freeRTOS750/lib_serial/lib_serial.c **** {
 2724               	.LM287:
 2725               	.LFBB31:
 2726 08c8 1F92      		push r1
 2727 08ca 0F92      		push r0
 2728 08cc 0FB6      		in r0,__SREG__
 2729 08ce 0F92      		push r0
 2730 08d0 1124      		clr __zero_reg__
 2731 08d2 2F93      		push r18
 2732 08d4 3F93      		push r19
 2733 08d6 4F93      		push r20
 2734 08d8 8F93      		push r24
 2735 08da 9F93      		push r25
 2736 08dc AF93      		push r26
 2737 08de BF93      		push r27
 2738 08e0 EF93      		push r30
 2739 08e2 FF93      		push r31
 2740               	/* prologue: Signal */
 2741               	/* frame size = 0 */
 2742               	/* stack size = 12 */
 2743               	.L__stack_usage = 12
 730:../freeRTOS750/lib_serial/lib_serial.c **** 	uint8_t cChar;
 731:../freeRTOS750/lib_serial/lib_serial.c **** 
 732:../freeRTOS750/lib_serial/lib_serial.c **** 	/* Get status and data from buffer */
 733:../freeRTOS750/lib_serial/lib_serial.c **** 
 734:../freeRTOS750/lib_serial/lib_serial.c **** 	/* If error bit set (Frame Error, Data Over Run, Parity), return nothing */
 735:../freeRTOS750/lib_serial/lib_serial.c **** 	if ( ! (UCSR0A & ((1<<FE0)|(1<<DOR0)|(1<<UPE0)) ) )
 2745               	.LM288:
 2746 08e4 8091 C000 		lds r24,192
 2747 08e8 8C71      		andi r24,lo8(28)
 2748 08ea 01F4      		brne .L122
 736:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 737:../freeRTOS750/lib_serial/lib_serial.c **** 		/* If no error, get the character and post it on the buffer of Rxed characters.*/
 738:../freeRTOS750/lib_serial/lib_serial.c **** 		cChar = UDR0;
 2750               	.LM289:
 2751 08ec 4091 C600 		lds r20,198
 2752               	.LBB217:
 2753               	.LBB218:
 2754               	.LBB219:
 2755               	.LBB220:
 2757               	.Ltext44:
 306:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 2759               	.LM290:
 2760               	/* #APP */
 2761               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 2762 08f0 0FB6      		in		__tmp_reg__, __SREG__
 2763               	 ;  0 "" 2
 2764               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 2765 08f2 F894      		cli
 2766               	 ;  0 "" 2
 2767               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 2768 08f4 0F92      		push	__tmp_reg__
 2769               	 ;  0 "" 2
 308:../freeRTOS750/include/ringBuffer.h **** 	count = buffer->count;
 2771               	.LM291:
 2772               	/* #NOAPP */
 2773 08f6 2091 0000 		lds r18,xSerialPort+1
 2774 08fa 3091 0000 		lds r19,xSerialPort+1+1
 310:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 2776               	.LM292:
 2777               	/* #APP */
 2778               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 2779 08fe 0F90      		pop		__tmp_reg__
 2780               	 ;  0 "" 2
 2781               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 2782 0900 0FBE      		out		__SREG__, __tmp_reg__
 2783               	 ;  0 "" 2
 2784               	/* #NOAPP */
 2785               	.LBE220:
 2786               	.LBE219:
 2787               	.LBE218:
 2788               	.LBE217:
 2790               	.Ltext45:
 739:../freeRTOS750/lib_serial/lib_serial.c **** 
 740:../freeRTOS750/lib_serial/lib_serial.c **** 		if( ! ringBuffer_IsFull( &(xSerialPort.xRxedChars) ) )
 2792               	.LM293:
 2793 0902 8091 0000 		lds r24,xSerialPort+11
 2794 0906 9091 0000 		lds r25,xSerialPort+11+1
 2795 090a 2817      		cp r18,r24
 2796 090c 3907      		cpc r19,r25
 2797 090e 01F0      		breq .L122
 2798               	.LBB221:
 2799               	.LBB222:
 2801               	.Ltext46:
 335:../freeRTOS750/include/ringBuffer.h **** 	GCC_FORCE_POINTER_ACCESS(buffer);
 2803               	.LM294:
 2804 0910 E0E0      		ldi r30,lo8(xSerialPort+1)
 2805 0912 F0E0      		ldi r31,hi8(xSerialPort+1)
 337:../freeRTOS750/include/ringBuffer.h **** 	*buffer->in = data;
 2807               	.LM295:
 2808 0914 A281      		ldd r26,Z+2
 2809 0916 B381      		ldd r27,Z+3
 2810 0918 4C93      		st X,r20
 339:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 2812               	.LM296:
 2813               	/* #APP */
 2814               	 ;  339 "../freeRTOS750/include/ringBuffer.h" 1
 2815 091a 0FB6      		in		__tmp_reg__, __SREG__
 2816               	 ;  0 "" 2
 2817               	 ;  339 "../freeRTOS750/include/ringBuffer.h" 1
 2818 091c F894      		cli
 2819               	 ;  0 "" 2
 2820               	 ;  339 "../freeRTOS750/include/ringBuffer.h" 1
 2821 091e 0F92      		push	__tmp_reg__
 2822               	 ;  0 "" 2
 341:../freeRTOS750/include/ringBuffer.h **** 	if (++buffer->in == buffer->end)
 2824               	.LM297:
 2825               	/* #NOAPP */
 2826 0920 8281      		ldd r24,Z+2
 2827 0922 9381      		ldd r25,Z+3
 2828 0924 0196      		adiw r24,1
 2829 0926 9383      		std Z+3,r25
 2830 0928 8283      		std Z+2,r24
 2831 092a 2085      		ldd r18,Z+8
 2832 092c 3185      		ldd r19,Z+9
 2833 092e 8217      		cp r24,r18
 2834 0930 9307      		cpc r25,r19
 2835 0932 01F4      		brne .L124
 342:../freeRTOS750/include/ringBuffer.h **** 	  buffer->in = buffer->start;
 2837               	.LM298:
 2838 0934 8681      		ldd r24,Z+6
 2839 0936 9781      		ldd r25,Z+7
 2840 0938 9383      		std Z+3,r25
 2841 093a 8283      		std Z+2,r24
 2842               	.L124:
 344:../freeRTOS750/include/ringBuffer.h **** 	buffer->count++;
 2844               	.LM299:
 2845 093c 8081      		ld r24,Z
 2846 093e 9181      		ldd r25,Z+1
 2847 0940 0196      		adiw r24,1
 2848 0942 9183      		std Z+1,r25
 2849 0944 8083      		st Z,r24
 346:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 2851               	.LM300:
 2852               	/* #APP */
 2853               	 ;  346 "../freeRTOS750/include/ringBuffer.h" 1
 2854 0946 0F90      		pop		__tmp_reg__
 2855               	 ;  0 "" 2
 2856               	 ;  346 "../freeRTOS750/include/ringBuffer.h" 1
 2857 0948 0FBE      		out		__SREG__, __tmp_reg__
 2858               	 ;  0 "" 2
 2859               	/* #NOAPP */
 2860               	.L122:
 2861               	/* epilogue start */
 2862               	.LBE222:
 2863               	.LBE221:
 2865               	.Ltext47:
 741:../freeRTOS750/lib_serial/lib_serial.c **** 			ringBuffer_Poke( &(xSerialPort.xRxedChars), cChar);
 742:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 743:../freeRTOS750/lib_serial/lib_serial.c **** }
 2867               	.LM301:
 2868 094a FF91      		pop r31
 2869 094c EF91      		pop r30
 2870 094e BF91      		pop r27
 2871 0950 AF91      		pop r26
 2872 0952 9F91      		pop r25
 2873 0954 8F91      		pop r24
 2874 0956 4F91      		pop r20
 2875 0958 3F91      		pop r19
 2876 095a 2F91      		pop r18
 2877 095c 0F90      		pop r0
 2878 095e 0FBE      		out __SREG__,r0
 2879 0960 0F90      		pop r0
 2880 0962 1F90      		pop r1
 2881 0964 1895      		reti
 2892               	.Lscope31:
 2894               		.stabd	78,0,0
 2896               	.global	__vector_19
 2898               	__vector_19:
 2899               		.stabd	46,0,0
 744:../freeRTOS750/lib_serial/lib_serial.c **** /*-----------------------------------------------------------*/
 745:../freeRTOS750/lib_serial/lib_serial.c **** 
 746:../freeRTOS750/lib_serial/lib_serial.c **** #if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || def
 747:../freeRTOS750/lib_serial/lib_serial.c **** ISR( USART0_UDRE_vect )
 748:../freeRTOS750/lib_serial/lib_serial.c **** #elif defined(__AVR_ATmega324P__)  || defined(__AVR_ATmega644P__)|| defined(__AVR_ATmega1284P__) ||
 749:../freeRTOS750/lib_serial/lib_serial.c **** ISR( USART0_UDRE_vect )
 750:../freeRTOS750/lib_serial/lib_serial.c **** #elif defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__)
 751:../freeRTOS750/lib_serial/lib_serial.c **** ISR( USART_UDRE_vect )
 752:../freeRTOS750/lib_serial/lib_serial.c **** #endif
 753:../freeRTOS750/lib_serial/lib_serial.c **** {
 2901               	.LM302:
 2902               	.LFBB32:
 2903 0966 1F92      		push r1
 2904 0968 0F92      		push r0
 2905 096a 0FB6      		in r0,__SREG__
 2906 096c 0F92      		push r0
 2907 096e 1124      		clr __zero_reg__
 2908 0970 2F93      		push r18
 2909 0972 8F93      		push r24
 2910 0974 9F93      		push r25
 2911 0976 AF93      		push r26
 2912 0978 BF93      		push r27
 2913 097a EF93      		push r30
 2914 097c FF93      		push r31
 2915               	/* prologue: Signal */
 2916               	/* frame size = 0 */
 2917               	/* stack size = 10 */
 2918               	.L__stack_usage = 10
 2919               	.LBB223:
 2920               	.LBB224:
 2921               	.LBB225:
 2923               	.Ltext48:
 306:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 2925               	.LM303:
 2926               	/* #APP */
 2927               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 2928 097e 0FB6      		in		__tmp_reg__, __SREG__
 2929               	 ;  0 "" 2
 2930               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 2931 0980 F894      		cli
 2932               	 ;  0 "" 2
 2933               	 ;  306 "../freeRTOS750/include/ringBuffer.h" 1
 2934 0982 0F92      		push	__tmp_reg__
 2935               	 ;  0 "" 2
 308:../freeRTOS750/include/ringBuffer.h **** 	count = buffer->count;
 2937               	.LM304:
 2938               	/* #NOAPP */
 2939 0984 8091 0000 		lds r24,xSerialPort+13
 2940 0988 9091 0000 		lds r25,xSerialPort+13+1
 310:../freeRTOS750/include/ringBuffer.h **** 	portEXIT_CRITICAL();
 2942               	.LM305:
 2943               	/* #APP */
 2944               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 2945 098c 0F90      		pop		__tmp_reg__
 2946               	 ;  0 "" 2
 2947               	 ;  310 "../freeRTOS750/include/ringBuffer.h" 1
 2948 098e 0FBE      		out		__SREG__, __tmp_reg__
 2949               	 ;  0 "" 2
 2950               	/* #NOAPP */
 2951               	.LBE225:
 2952               	.LBE224:
 2953               	.LBE223:
 2955               	.Ltext49:
 754:../freeRTOS750/lib_serial/lib_serial.c **** 	if( ringBuffer_IsEmpty( &(xSerialPort.xCharsForTx) ) )
 2957               	.LM306:
 2958 0990 892B      		or r24,r25
 2959 0992 01F4      		brne .L126
 2960               	.LBB226:
 755:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 756:../freeRTOS750/lib_serial/lib_serial.c **** 		// Queue empty, nothing to send.
 757:../freeRTOS750/lib_serial/lib_serial.c **** 		vInterrupt0_Off();
 2962               	.LM307:
 2963 0994 8091 C100 		lds r24,193
 2964 0998 8F7D      		andi r24,lo8(-33)
 2965 099a 8093 C100 		sts 193,r24
 2966 099e 00C0      		rjmp .L125
 2967               	.L126:
 2968               	.LBE226:
 2969               	.LBB227:
 2970               	.LBB228:
 2972               	.Ltext50:
 352:../freeRTOS750/include/ringBuffer.h **** 	GCC_FORCE_POINTER_ACCESS(buffer);
 2974               	.LM308:
 2975 09a0 E0E0      		ldi r30,lo8(xSerialPort+13)
 2976 09a2 F0E0      		ldi r31,hi8(xSerialPort+13)
 354:../freeRTOS750/include/ringBuffer.h **** 	uint8_t data = *buffer->out;
 2978               	.LM309:
 2979 09a4 A481      		ldd r26,Z+4
 2980 09a6 B581      		ldd r27,Z+5
 2981 09a8 2D91      		ld r18,X+
 356:../freeRTOS750/include/ringBuffer.h **** 	portENTER_CRITICAL();
 2983               	.LM310:
 2984               	/* #APP */
 2985               	 ;  356 "../freeRTOS750/include/ringBuffer.h" 1
 2986 09aa 0FB6      		in		__tmp_reg__, __SREG__
 2987               	 ;  0 "" 2
 2988               	 ;  356 "../freeRTOS750/include/ringBuffer.h" 1
 2989 09ac F894      		cli
 2990               	 ;  0 "" 2
 2991               	 ;  356 "../freeRTOS750/include/ringBuffer.h" 1
 2992 09ae 0F92      		push	__tmp_reg__
 2993               	 ;  0 "" 2
 358:../freeRTOS750/include/ringBuffer.h **** 	if (++buffer->out == buffer->end)
 2995               	.LM311:
 2996               	/* #NOAPP */
 2997 09b0 B583      		std Z+5,r27
 2998 09b2 A483      		std Z+4,r26
 2999 09b4 8085      		ldd r24,Z+8
 3000 09b6 9185      		ldd r25,Z+9
 3001 09b8 A817      		cp r26,r24
 3002 09ba B907      		cpc r27,r25
 3003 09bc 01F4      		brne .L128
 359:../freeRTOS750/include/ringBuffer.h **** 	  buffer->out = buffer->start;
 3005               	.LM312:
 3006 09be 8681      		ldd r24,Z+6
 3007 09c0 9781      		ldd r25,Z+7
 3008 09c2 9583      		std Z+5,r25
 3009 09c4 8483      		std Z+4,r24
 3010               	.L128:
 361:../freeRTOS750/include/ringBuffer.h **** 	buffer->count--;
 3012               	.LM313:
 3013 09c6 8081      		ld r24,Z
 3014 09c8 9181      		ldd r25,Z+1
 3015 09ca 0197      		sbiw r24,1
 3016 09cc 9183      		std Z+1,r25
 3017 09ce 8083      		st Z,r24
 3019               	.LM314:
 3020               	/* #APP */
 3021               	 ;  363 "../freeRTOS750/include/ringBuffer.h" 1
 3022 09d0 0F90      		pop		__tmp_reg__
 3023               	 ;  0 "" 2
 3024               	 ;  363 "../freeRTOS750/include/ringBuffer.h" 1
 3025 09d2 0FBE      		out		__SREG__, __tmp_reg__
 3026               	 ;  0 "" 2
 3027               	/* #NOAPP */
 3028               	.LBE228:
 3029               	.LBE227:
 3031               	.Ltext51:
 758:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 759:../freeRTOS750/lib_serial/lib_serial.c **** 	else
 760:../freeRTOS750/lib_serial/lib_serial.c **** 	{
 761:../freeRTOS750/lib_serial/lib_serial.c **** 		UDR0 = ringBuffer_Pop( &(xSerialPort.xCharsForTx) );
 3033               	.LM315:
 3034 09d4 2093 C600 		sts 198,r18
 3035               	.L125:
 3036               	/* epilogue start */
 762:../freeRTOS750/lib_serial/lib_serial.c **** 	}
 763:../freeRTOS750/lib_serial/lib_serial.c **** }
 3038               	.LM316:
 3039 09d8 FF91      		pop r31
 3040 09da EF91      		pop r30
 3041 09dc BF91      		pop r27
 3042 09de AF91      		pop r26
 3043 09e0 9F91      		pop r25
 3044 09e2 8F91      		pop r24
 3045 09e4 2F91      		pop r18
 3046 09e6 0F90      		pop r0
 3047 09e8 0FBE      		out __SREG__,r0
 3048 09ea 0F90      		pop r0
 3049 09ec 1F90      		pop r1
 3050 09ee 1895      		reti
 3061               	.Lscope32:
 3063               		.stabd	78,0,0
 3064               		.comm	xSerialPort,30,1
 3067               	.Letext0:
 3068               		.ident	"GCC: (GNU) 4.7.2"
 3069               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 lib_serial.c
     /tmp/ccW5Rqsp.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccW5Rqsp.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccW5Rqsp.s:4      *ABS*:0000003f __SREG__
     /tmp/ccW5Rqsp.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccW5Rqsp.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccW5Rqsp.s:137    .text:00000000 xSerialFlush
     /tmp/ccW5Rqsp.s:219    .text:00000032 xSerialAvailableChar
     /tmp/ccW5Rqsp.s:282    .text:00000046 xSerialGetChar
     /tmp/ccW5Rqsp.s:431    .text:0000009a xSerialPutChar
     /tmp/ccW5Rqsp.s:701    .text:0000015a xSerialxPrint_P
     /tmp/ccW5Rqsp.s:789    .text:000001a4 xSerialxPrint
     /tmp/ccW5Rqsp.s:856    .text:000001e8 xSerialxPrintf_P
     /tmp/ccW5Rqsp.s:941    .text:00000248 xSerialxPrintf
     /tmp/ccW5Rqsp.s:1025   .text:000002a8 xSerialPrint_P
                            *COM*:0000001e xSerialPort
     /tmp/ccW5Rqsp.s:1107   .text:000002e8 xSerialPrint
     /tmp/ccW5Rqsp.s:1169   .text:00000324 xSerialPrintf_P
     /tmp/ccW5Rqsp.s:1244   .text:00000386 xSerialPrintf
     /tmp/ccW5Rqsp.s:1322   .text:000003e8 xSerialPortInitMinimal
     /tmp/ccW5Rqsp.s:1636   .text:00000540 vSerialClose
     /tmp/ccW5Rqsp.s:1722   .text:00000588 avrSerialWrite
     /tmp/ccW5Rqsp.s:1773   .text:000005a0 avrSerialPrint_P
     /tmp/ccW5Rqsp.s:1853   .text:000005dc avrSerialPrint
     /tmp/ccW5Rqsp.s:1913   .text:00000614 avrSerialPrintf_P
     /tmp/ccW5Rqsp.s:1991   .text:00000668 avrSerialPrintf
     /tmp/ccW5Rqsp.s:2068   .text:000006bc avrSerialRead
     /tmp/ccW5Rqsp.s:2130   .text:000006e0 avrSerialCheckRxComplete
     /tmp/ccW5Rqsp.s:2153   .text:000006e8 avrSerialCheckTxReady
     /tmp/ccW5Rqsp.s:2177   .text:000006f0 avrSerialxCheckRxComplete
     /tmp/ccW5Rqsp.s:2212   .text:00000704 avrSerialxRead
     /tmp/ccW5Rqsp.s:2282   .text:0000073a avrSerialxCheckTxReady
     /tmp/ccW5Rqsp.s:2318   .text:0000074e avrSerialxWrite
     /tmp/ccW5Rqsp.s:2390   .text:0000078e avrSerialxPrint_P
     /tmp/ccW5Rqsp.s:2478   .text:000007d8 avrSerialxPrint
     /tmp/ccW5Rqsp.s:2545   .text:0000081c avrSerialxPrintf_P
     /tmp/ccW5Rqsp.s:2634   .text:00000872 avrSerialxPrintf
     /tmp/ccW5Rqsp.s:2721   .text:000008c8 __vector_18
     /tmp/ccW5Rqsp.s:2898   .text:00000966 __vector_19

UNDEFINED SYMBOLS
__strlen_P
vPortYield
vsnprintf_P
vsnprintf
pvPortMalloc
__udivmodsi4
vPortFree
__do_clear_bss
