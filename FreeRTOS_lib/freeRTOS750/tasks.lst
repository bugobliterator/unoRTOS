   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 127               	prvAddCurrentTaskToDelayedList:
 128               		.stabd	46,0,0
   1:../freeRTOS750/tasks.c **** /*
   2:../freeRTOS750/tasks.c ****     FreeRTOS V7.5.0 - Copyright (C) 2013 Real Time Engineers Ltd.
   3:../freeRTOS750/tasks.c **** 
   4:../freeRTOS750/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   5:../freeRTOS750/tasks.c **** 
   6:../freeRTOS750/tasks.c ****     ***************************************************************************
   7:../freeRTOS750/tasks.c ****      *                                                                       *
   8:../freeRTOS750/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
   9:../freeRTOS750/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  10:../freeRTOS750/tasks.c ****      *    platform software that has become a de facto standard.             *
  11:../freeRTOS750/tasks.c ****      *                                                                       *
  12:../freeRTOS750/tasks.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  13:../freeRTOS750/tasks.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  14:../freeRTOS750/tasks.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  15:../freeRTOS750/tasks.c ****      *                                                                       *
  16:../freeRTOS750/tasks.c ****      *    Thank you!                                                         *
  17:../freeRTOS750/tasks.c ****      *                                                                       *
  18:../freeRTOS750/tasks.c ****     ***************************************************************************
  19:../freeRTOS750/tasks.c **** 
  20:../freeRTOS750/tasks.c ****     This file is part of the FreeRTOS distribution.
  21:../freeRTOS750/tasks.c **** 
  22:../freeRTOS750/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  23:../freeRTOS750/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  24:../freeRTOS750/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  25:../freeRTOS750/tasks.c **** 
  26:../freeRTOS750/tasks.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  27:../freeRTOS750/tasks.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  28:../freeRTOS750/tasks.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  29:../freeRTOS750/tasks.c ****     >>! kernel.
  30:../freeRTOS750/tasks.c **** 
  31:../freeRTOS750/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  32:../freeRTOS750/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  33:../freeRTOS750/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  34:../freeRTOS750/tasks.c ****     link: http://www.freertos.org/a00114.html
  35:../freeRTOS750/tasks.c **** 
  36:../freeRTOS750/tasks.c ****     1 tab == 4 spaces!
  37:../freeRTOS750/tasks.c **** 
  38:../freeRTOS750/tasks.c ****     ***************************************************************************
  39:../freeRTOS750/tasks.c ****      *                                                                       *
  40:../freeRTOS750/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  41:../freeRTOS750/tasks.c ****      *    not run, what could be wrong?"                                     *
  42:../freeRTOS750/tasks.c ****      *                                                                       *
  43:../freeRTOS750/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  44:../freeRTOS750/tasks.c ****      *                                                                       *
  45:../freeRTOS750/tasks.c ****     ***************************************************************************
  46:../freeRTOS750/tasks.c **** 
  47:../freeRTOS750/tasks.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  48:../freeRTOS750/tasks.c ****     license and Real Time Engineers Ltd. contact details.
  49:../freeRTOS750/tasks.c **** 
  50:../freeRTOS750/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  51:../freeRTOS750/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  52:../freeRTOS750/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  53:../freeRTOS750/tasks.c **** 
  54:../freeRTOS750/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  55:../freeRTOS750/tasks.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  56:../freeRTOS750/tasks.c ****     licenses offer ticketed support, indemnification and middleware.
  57:../freeRTOS750/tasks.c **** 
  58:../freeRTOS750/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  59:../freeRTOS750/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  60:../freeRTOS750/tasks.c ****     mission critical applications that require provable dependability.
  61:../freeRTOS750/tasks.c **** 
  62:../freeRTOS750/tasks.c ****     1 tab == 4 spaces!
  63:../freeRTOS750/tasks.c **** */
  64:../freeRTOS750/tasks.c **** 
  65:../freeRTOS750/tasks.c **** /* Standard includes. */
  66:../freeRTOS750/tasks.c **** #include <stdlib.h>
  67:../freeRTOS750/tasks.c **** #include <string.h>
  68:../freeRTOS750/tasks.c **** 
  69:../freeRTOS750/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  70:../freeRTOS750/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  71:../freeRTOS750/tasks.c **** task.h is included from an application file. */
  72:../freeRTOS750/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  73:../freeRTOS750/tasks.c **** 
  74:../freeRTOS750/tasks.c **** /* FreeRTOS includes. */
  75:../freeRTOS750/tasks.c **** #include "FreeRTOS.h"
  76:../freeRTOS750/tasks.c **** #include "task.h"
  77:../freeRTOS750/tasks.c **** #include "timers.h"
  78:../freeRTOS750/tasks.c **** #include "StackMacros.h"
  79:../freeRTOS750/tasks.c **** 
  80:../freeRTOS750/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  81:../freeRTOS750/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  82:../freeRTOS750/tasks.c **** header files above, but not in this file, in order to generate the correct
  83:../freeRTOS750/tasks.c **** privileged Vs unprivileged linkage and placement. */
  84:../freeRTOS750/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  85:../freeRTOS750/tasks.c **** 
  86:../freeRTOS750/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  87:../freeRTOS750/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  88:../freeRTOS750/tasks.c **** 	to generate human readable text from the raw data generated by the
  89:../freeRTOS750/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  90:../freeRTOS750/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  91:../freeRTOS750/tasks.c **** 	#include <stdio.h>
  92:../freeRTOS750/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  93:../freeRTOS750/tasks.c **** 
  94:../freeRTOS750/tasks.c **** /* Sanity check the configuration. */
  95:../freeRTOS750/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
  96:../freeRTOS750/tasks.c **** 	#if INCLUDE_vTaskSuspend != 1
  97:../freeRTOS750/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
  98:../freeRTOS750/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
  99:../freeRTOS750/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 100:../freeRTOS750/tasks.c **** 
 101:../freeRTOS750/tasks.c **** /*
 102:../freeRTOS750/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 103:../freeRTOS750/tasks.c ****  */
 104:../freeRTOS750/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 105:../freeRTOS750/tasks.c **** 
 106:../freeRTOS750/tasks.c **** /*
 107:../freeRTOS750/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 108:../freeRTOS750/tasks.c ****  * and stores task state information, including a pointer to the task's context
 109:../freeRTOS750/tasks.c ****  * (the task's run time environment, including register values)
 110:../freeRTOS750/tasks.c ****  */
 111:../freeRTOS750/tasks.c **** typedef struct tskTaskControlBlock
 112:../freeRTOS750/tasks.c **** {
 113:../freeRTOS750/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
 114:../freeRTOS750/tasks.c **** 
 115:../freeRTOS750/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 116:../freeRTOS750/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
 117:../freeRTOS750/tasks.c **** 	#endif
 118:../freeRTOS750/tasks.c **** 
 119:../freeRTOS750/tasks.c **** 	xListItem				xGenericListItem;	/*< The list that the state list item of a task is reference from d
 120:../freeRTOS750/tasks.c **** 	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
 121:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 122:../freeRTOS750/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
 123:../freeRTOS750/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
 124:../freeRTOS750/tasks.c **** 
 125:../freeRTOS750/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 126:../freeRTOS750/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the sta
 127:../freeRTOS750/tasks.c **** 	#endif
 128:../freeRTOS750/tasks.c **** 
 129:../freeRTOS750/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 130:../freeRTOS750/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports 
 131:../freeRTOS750/tasks.c **** 	#endif
 132:../freeRTOS750/tasks.c **** 
 133:../freeRTOS750/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 134:../freeRTOS750/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is create
 135:../freeRTOS750/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party tra
 136:../freeRTOS750/tasks.c **** 	#endif
 137:../freeRTOS750/tasks.c **** 
 138:../freeRTOS750/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 139:../freeRTOS750/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 140:../freeRTOS750/tasks.c **** 	#endif
 141:../freeRTOS750/tasks.c **** 
 142:../freeRTOS750/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 143:../freeRTOS750/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 144:../freeRTOS750/tasks.c **** 	#endif
 145:../freeRTOS750/tasks.c **** 
 146:../freeRTOS750/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 147:../freeRTOS750/tasks.c **** 		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running
 148:../freeRTOS750/tasks.c **** 	#endif
 149:../freeRTOS750/tasks.c **** 
 150:../freeRTOS750/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 151:../freeRTOS750/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 152:../freeRTOS750/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 153:../freeRTOS750/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 154:../freeRTOS750/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 155:../freeRTOS750/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 156:../freeRTOS750/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 157:../freeRTOS750/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 158:../freeRTOS750/tasks.c **** 		struct _reent xNewLib_reent;
 159:../freeRTOS750/tasks.c **** 	#endif
 160:../freeRTOS750/tasks.c **** 
 161:../freeRTOS750/tasks.c **** } tskTCB;
 162:../freeRTOS750/tasks.c **** 
 163:../freeRTOS750/tasks.c **** 
 164:../freeRTOS750/tasks.c **** /*
 165:../freeRTOS750/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 166:../freeRTOS750/tasks.c ****  * be global, rather than file scope.
 167:../freeRTOS750/tasks.c ****  */
 168:../freeRTOS750/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 169:../freeRTOS750/tasks.c **** 	#define static
 170:../freeRTOS750/tasks.c **** #endif
 171:../freeRTOS750/tasks.c **** 
 172:../freeRTOS750/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 173:../freeRTOS750/tasks.c **** static variables must be declared volatile. */
 174:../freeRTOS750/tasks.c **** 
 175:../freeRTOS750/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 176:../freeRTOS750/tasks.c **** 
 177:../freeRTOS750/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 178:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 179:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 180:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 181:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList;				/*< Points to the delayed task list c
 182:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 183:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 184:../freeRTOS750/tasks.c **** 
 185:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 186:../freeRTOS750/tasks.c **** 
 187:../freeRTOS750/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 188:../freeRTOS750/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 189:../freeRTOS750/tasks.c **** 
 190:../freeRTOS750/tasks.c **** #endif
 191:../freeRTOS750/tasks.c **** 
 192:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 193:../freeRTOS750/tasks.c **** 
 194:../freeRTOS750/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 195:../freeRTOS750/tasks.c **** 
 196:../freeRTOS750/tasks.c **** #endif
 197:../freeRTOS750/tasks.c **** 
 198:../freeRTOS750/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 199:../freeRTOS750/tasks.c **** 
 200:../freeRTOS750/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task
 201:../freeRTOS750/tasks.c **** 
 202:../freeRTOS750/tasks.c **** #endif
 203:../freeRTOS750/tasks.c **** 
 204:../freeRTOS750/tasks.c **** /* Other file private variables. --------------------------------*/
 205:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 206:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 207:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 208:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 209:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 210:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxPendedTicks 			= ( unsigned portBASE_TYPE 
 211:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xYieldPending 					= pdFALSE;
 212:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 213:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 214:../freeRTOS750/tasks.c **** PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= portMAX_DELAY;
 215:../freeRTOS750/tasks.c **** 
 216:../freeRTOS750/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 217:../freeRTOS750/tasks.c **** 
 218:../freeRTOS750/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 219:../freeRTOS750/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTotalRunTime = 0UL;			/*< Holds the total amount of executi
 220:../freeRTOS750/tasks.c **** 
 221:../freeRTOS750/tasks.c **** #endif
 222:../freeRTOS750/tasks.c **** 
 223:../freeRTOS750/tasks.c **** /*lint +e956 */
 224:../freeRTOS750/tasks.c **** 
 225:../freeRTOS750/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 226:../freeRTOS750/tasks.c **** 
 227:../freeRTOS750/tasks.c **** /*
 228:../freeRTOS750/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 229:../freeRTOS750/tasks.c ****  * is used purely for checking the high water mark for tasks.
 230:../freeRTOS750/tasks.c ****  */
 231:../freeRTOS750/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 232:../freeRTOS750/tasks.c **** 
 233:../freeRTOS750/tasks.c **** /*
 234:../freeRTOS750/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 235:../freeRTOS750/tasks.c ****  */
 236:../freeRTOS750/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 237:../freeRTOS750/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 238:../freeRTOS750/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 239:../freeRTOS750/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 240:../freeRTOS750/tasks.c **** 
 241:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
 242:../freeRTOS750/tasks.c **** 
 243:../freeRTOS750/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 244:../freeRTOS750/tasks.c **** 
 245:../freeRTOS750/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 246:../freeRTOS750/tasks.c **** 	performed in a generic way that is not optimised to any particular
 247:../freeRTOS750/tasks.c **** 	microcontroller architecture. */
 248:../freeRTOS750/tasks.c **** 
 249:../freeRTOS750/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 250:../freeRTOS750/tasks.c **** 	state task. */
 251:../freeRTOS750/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
 252:../freeRTOS750/tasks.c **** 	{																													\
 253:../freeRTOS750/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )																		\
 254:../freeRTOS750/tasks.c **** 		{																												\
 255:../freeRTOS750/tasks.c **** 			uxTopReadyPriority = ( uxPriority );																		\
 256:../freeRTOS750/tasks.c **** 		}																												\
 257:../freeRTOS750/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 258:../freeRTOS750/tasks.c **** 
 259:../freeRTOS750/tasks.c **** 	/*-----------------------------------------------------------*/
 260:../freeRTOS750/tasks.c **** 
 261:../freeRTOS750/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
 262:../freeRTOS750/tasks.c **** 	{																													\
 263:../freeRTOS750/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */												\
 264:../freeRTOS750/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
 265:../freeRTOS750/tasks.c **** 		{																												\
 266:../freeRTOS750/tasks.c **** 			configASSERT( uxTopReadyPriority );																			\
 267:../freeRTOS750/tasks.c **** 			--uxTopReadyPriority;																						\
 268:../freeRTOS750/tasks.c **** 		}																												\
 269:../freeRTOS750/tasks.c **** 																														\
 270:../freeRTOS750/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
 271:../freeRTOS750/tasks.c **** 		the	same priority get an equal share of the processor time. */													\
 272:../freeRTOS750/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
 273:../freeRTOS750/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 274:../freeRTOS750/tasks.c **** 
 275:../freeRTOS750/tasks.c **** 	/*-----------------------------------------------------------*/
 276:../freeRTOS750/tasks.c **** 
 277:../freeRTOS750/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 278:../freeRTOS750/tasks.c **** 	they are only required when a port optimised method of task selection is
 279:../freeRTOS750/tasks.c **** 	being used. */
 280:../freeRTOS750/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 281:../freeRTOS750/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 282:../freeRTOS750/tasks.c **** 
 283:../freeRTOS750/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 284:../freeRTOS750/tasks.c **** 
 285:../freeRTOS750/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 286:../freeRTOS750/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 287:../freeRTOS750/tasks.c **** 	architecture being used. */
 288:../freeRTOS750/tasks.c **** 
 289:../freeRTOS750/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 290:../freeRTOS750/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 291:../freeRTOS750/tasks.c **** 
 292:../freeRTOS750/tasks.c **** 	/*-----------------------------------------------------------*/
 293:../freeRTOS750/tasks.c **** 
 294:../freeRTOS750/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 295:../freeRTOS750/tasks.c **** 	{																								\
 296:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxTopPriority;															\
 297:../freeRTOS750/tasks.c **** 																									\
 298:../freeRTOS750/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 299:../freeRTOS750/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 300:../freeRTOS750/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 301:../freeRTOS750/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 302:../freeRTOS750/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 303:../freeRTOS750/tasks.c **** 
 304:../freeRTOS750/tasks.c **** 	/*-----------------------------------------------------------*/
 305:../freeRTOS750/tasks.c **** 
 306:../freeRTOS750/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 307:../freeRTOS750/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 308:../freeRTOS750/tasks.c **** 	or suspended list then it won't be in a ready list. */
 309:../freeRTOS750/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 310:../freeRTOS750/tasks.c **** 	{																								\
 311:../freeRTOS750/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 312:../freeRTOS750/tasks.c **** 		{																							\
 313:../freeRTOS750/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 314:../freeRTOS750/tasks.c **** 		}																							\
 315:../freeRTOS750/tasks.c **** 	}
 316:../freeRTOS750/tasks.c **** 
 317:../freeRTOS750/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 318:../freeRTOS750/tasks.c **** 
 319:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
 320:../freeRTOS750/tasks.c **** 
 321:../freeRTOS750/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 322:../freeRTOS750/tasks.c **** count overflows. */
 323:../freeRTOS750/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 324:../freeRTOS750/tasks.c **** {																									\
 325:../freeRTOS750/tasks.c **** 	xList *pxTemp;																					\
 326:../freeRTOS750/tasks.c **** 																									\
 327:../freeRTOS750/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 328:../freeRTOS750/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 329:../freeRTOS750/tasks.c **** 																									\
 330:../freeRTOS750/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 331:../freeRTOS750/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 332:../freeRTOS750/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 333:../freeRTOS750/tasks.c **** 	xNumOfOverflows++;																				\
 334:../freeRTOS750/tasks.c **** 																									\
 335:../freeRTOS750/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )											\
 336:../freeRTOS750/tasks.c **** 	{																								\
 337:../freeRTOS750/tasks.c **** 		/* The new current delayed list is empty.  Set												\
 338:../freeRTOS750/tasks.c **** 		xNextTaskUnblockTime to the maximum possible value so it is									\
 339:../freeRTOS750/tasks.c **** 		extremely unlikely that the																	\
 340:../freeRTOS750/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until								\
 341:../freeRTOS750/tasks.c **** 		there is an item in the delayed list. */													\
 342:../freeRTOS750/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;														\
 343:../freeRTOS750/tasks.c **** 	}																								\
 344:../freeRTOS750/tasks.c **** 	else																							\
 345:../freeRTOS750/tasks.c **** 	{																								\
 346:../freeRTOS750/tasks.c **** 		/* The new current delayed list is not empty, get the value of								\
 347:../freeRTOS750/tasks.c **** 		the item at the head of the delayed list.  This is the time at								\
 348:../freeRTOS750/tasks.c **** 		which the task at the head of the delayed list should be removed							\
 349:../freeRTOS750/tasks.c **** 		from the Blocked state. */																	\
 350:../freeRTOS750/tasks.c **** 		pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );						\
 351:../freeRTOS750/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );				\
 352:../freeRTOS750/tasks.c **** 	}																								\
 353:../freeRTOS750/tasks.c **** }
 354:../freeRTOS750/tasks.c **** 
 355:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
 356:../freeRTOS750/tasks.c **** 
 357:../freeRTOS750/tasks.c **** /*
 358:../freeRTOS750/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 359:../freeRTOS750/tasks.c ****  * the task.  It is inserted at the end of the list.
 360:../freeRTOS750/tasks.c ****  */
 361:../freeRTOS750/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																				\
 362:../freeRTOS750/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
 363:../freeRTOS750/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
 364:../freeRTOS750/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) 
 365:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
 366:../freeRTOS750/tasks.c **** 
 367:../freeRTOS750/tasks.c **** /*
 368:../freeRTOS750/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 369:../freeRTOS750/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 370:../freeRTOS750/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 371:../freeRTOS750/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 372:../freeRTOS750/tasks.c ****  */
 373:../freeRTOS750/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 374:../freeRTOS750/tasks.c **** 
 375:../freeRTOS750/tasks.c **** /* Callback function prototypes. --------------------------*/
 376:../freeRTOS750/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle xTask, signed char *pcTaskName );
 377:../freeRTOS750/tasks.c **** extern void vApplicationTickHook( void );
 378:../freeRTOS750/tasks.c **** 
 379:../freeRTOS750/tasks.c **** /* File private functions. --------------------------------*/
 380:../freeRTOS750/tasks.c **** 
 381:../freeRTOS750/tasks.c **** /*
 382:../freeRTOS750/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 383:../freeRTOS750/tasks.c ****  * into the TCB structure.
 384:../freeRTOS750/tasks.c ****  */
 385:../freeRTOS750/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 386:../freeRTOS750/tasks.c **** 
 387:../freeRTOS750/tasks.c **** /*
 388:../freeRTOS750/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 389:../freeRTOS750/tasks.c ****  * automatically upon the creation of the first task.
 390:../freeRTOS750/tasks.c ****  */
 391:../freeRTOS750/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 392:../freeRTOS750/tasks.c **** 
 393:../freeRTOS750/tasks.c **** /*
 394:../freeRTOS750/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 395:../freeRTOS750/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 396:../freeRTOS750/tasks.c ****  * creation of the first user task.
 397:../freeRTOS750/tasks.c ****  *
 398:../freeRTOS750/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 399:../freeRTOS750/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 400:../freeRTOS750/tasks.c ****  *
 401:../freeRTOS750/tasks.c ****  * void prvIdleTask( void *pvParameters );
 402:../freeRTOS750/tasks.c ****  *
 403:../freeRTOS750/tasks.c ****  */
 404:../freeRTOS750/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 405:../freeRTOS750/tasks.c **** 
 406:../freeRTOS750/tasks.c **** /*
 407:../freeRTOS750/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 408:../freeRTOS750/tasks.c ****  * including the stack pointed to by the TCB.
 409:../freeRTOS750/tasks.c ****  *
 410:../freeRTOS750/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 411:../freeRTOS750/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 412:../freeRTOS750/tasks.c ****  */
 413:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 414:../freeRTOS750/tasks.c **** 
 415:../freeRTOS750/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 416:../freeRTOS750/tasks.c **** 
 417:../freeRTOS750/tasks.c **** #endif
 418:../freeRTOS750/tasks.c **** 
 419:../freeRTOS750/tasks.c **** /*
 420:../freeRTOS750/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 421:../freeRTOS750/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 422:../freeRTOS750/tasks.c ****  * and its TCB deleted.
 423:../freeRTOS750/tasks.c ****  */
 424:../freeRTOS750/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 425:../freeRTOS750/tasks.c **** 
 426:../freeRTOS750/tasks.c **** /*
 427:../freeRTOS750/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 428:../freeRTOS750/tasks.c ****  * either the current or the overflow delayed task list.
 429:../freeRTOS750/tasks.c ****  */
 430:../freeRTOS750/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 431:../freeRTOS750/tasks.c **** 
 432:../freeRTOS750/tasks.c **** /*
 433:../freeRTOS750/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 434:../freeRTOS750/tasks.c ****  * allocation was successful.
 435:../freeRTOS750/tasks.c ****  */
 436:../freeRTOS750/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 437:../freeRTOS750/tasks.c **** 
 438:../freeRTOS750/tasks.c **** /*
 439:../freeRTOS750/tasks.c ****  * Fills an xTaskStatusType structure with information on each task that is
 440:../freeRTOS750/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 441:../freeRTOS750/tasks.c ****  * a suspended list, etc.).
 442:../freeRTOS750/tasks.c ****  *
 443:../freeRTOS750/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 444:../freeRTOS750/tasks.c ****  * NORMAL APPLICATION CODE.
 445:../freeRTOS750/tasks.c ****  */
 446:../freeRTOS750/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 447:../freeRTOS750/tasks.c **** 
 448:../freeRTOS750/tasks.c **** 	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xLi
 449:../freeRTOS750/tasks.c **** 
 450:../freeRTOS750/tasks.c **** #endif
 451:../freeRTOS750/tasks.c **** 
 452:../freeRTOS750/tasks.c **** /*
 453:../freeRTOS750/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 454:../freeRTOS750/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 455:../freeRTOS750/tasks.c ****  * determining how much of the stack remains at the original preset value.
 456:../freeRTOS750/tasks.c ****  */
 457:../freeRTOS750/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 458:../freeRTOS750/tasks.c **** 
 459:../freeRTOS750/tasks.c **** 	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_
 460:../freeRTOS750/tasks.c **** 
 461:../freeRTOS750/tasks.c **** #endif
 462:../freeRTOS750/tasks.c **** 
 463:../freeRTOS750/tasks.c **** /*
 464:../freeRTOS750/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 465:../freeRTOS750/tasks.c ****  * next move a task from the Blocked state to the Running state.
 466:../freeRTOS750/tasks.c ****  *
 467:../freeRTOS750/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 468:../freeRTOS750/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 469:../freeRTOS750/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 470:../freeRTOS750/tasks.c ****  * set to a value other than 1.
 471:../freeRTOS750/tasks.c ****  */
 472:../freeRTOS750/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 473:../freeRTOS750/tasks.c **** 
 474:../freeRTOS750/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 475:../freeRTOS750/tasks.c **** 
 476:../freeRTOS750/tasks.c **** #endif
 477:../freeRTOS750/tasks.c **** 
 478:../freeRTOS750/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 479:../freeRTOS750/tasks.c **** {
 480:../freeRTOS750/tasks.c **** signed portBASE_TYPE xReturn;
 481:../freeRTOS750/tasks.c **** tskTCB * pxNewTCB;
 482:../freeRTOS750/tasks.c **** 
 483:../freeRTOS750/tasks.c **** 	configASSERT( pxTaskCode );
 484:../freeRTOS750/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 485:../freeRTOS750/tasks.c **** 
 486:../freeRTOS750/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 487:../freeRTOS750/tasks.c **** 	checking that the allocation was successful. */
 488:../freeRTOS750/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 489:../freeRTOS750/tasks.c **** 
 490:../freeRTOS750/tasks.c **** 	if( pxNewTCB != NULL )
 491:../freeRTOS750/tasks.c **** 	{
 492:../freeRTOS750/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 493:../freeRTOS750/tasks.c **** 
 494:../freeRTOS750/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 495:../freeRTOS750/tasks.c **** 			/* Should the task be created in privileged mode? */
 496:../freeRTOS750/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 497:../freeRTOS750/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 498:../freeRTOS750/tasks.c **** 			{
 499:../freeRTOS750/tasks.c **** 				xRunPrivileged = pdTRUE;
 500:../freeRTOS750/tasks.c **** 			}
 501:../freeRTOS750/tasks.c **** 			else
 502:../freeRTOS750/tasks.c **** 			{
 503:../freeRTOS750/tasks.c **** 				xRunPrivileged = pdFALSE;
 504:../freeRTOS750/tasks.c **** 			}
 505:../freeRTOS750/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 506:../freeRTOS750/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 507:../freeRTOS750/tasks.c **** 
 508:../freeRTOS750/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 509:../freeRTOS750/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 510:../freeRTOS750/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 511:../freeRTOS750/tasks.c **** 		required by the port. */
 512:../freeRTOS750/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 513:../freeRTOS750/tasks.c **** 		{
 514:../freeRTOS750/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 515:../freeRTOS750/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 516:../freeRTOS750/tasks.c **** 
 517:../freeRTOS750/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 518:../freeRTOS750/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 519:../freeRTOS750/tasks.c **** 		}
 520:../freeRTOS750/tasks.c **** 		#else /* portSTACK_GROWTH */
 521:../freeRTOS750/tasks.c **** 		{
 522:../freeRTOS750/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 523:../freeRTOS750/tasks.c **** 
 524:../freeRTOS750/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 525:../freeRTOS750/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 526:../freeRTOS750/tasks.c **** 
 527:../freeRTOS750/tasks.c **** 			/* If we want to use stack checking on architectures that use
 528:../freeRTOS750/tasks.c **** 			a positive stack growth direction then we also need to store the
 529:../freeRTOS750/tasks.c **** 			other extreme of the stack space. */
 530:../freeRTOS750/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 531:../freeRTOS750/tasks.c **** 		}
 532:../freeRTOS750/tasks.c **** 		#endif /* portSTACK_GROWTH */
 533:../freeRTOS750/tasks.c **** 
 534:../freeRTOS750/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 535:../freeRTOS750/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 536:../freeRTOS750/tasks.c **** 
 537:../freeRTOS750/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 538:../freeRTOS750/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 539:../freeRTOS750/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 540:../freeRTOS750/tasks.c **** 		the	top of stack variable is updated. */
 541:../freeRTOS750/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 542:../freeRTOS750/tasks.c **** 		{
 543:../freeRTOS750/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 544:../freeRTOS750/tasks.c **** 		}
 545:../freeRTOS750/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 546:../freeRTOS750/tasks.c **** 		{
 547:../freeRTOS750/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 548:../freeRTOS750/tasks.c **** 		}
 549:../freeRTOS750/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 550:../freeRTOS750/tasks.c **** 
 551:../freeRTOS750/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 552:../freeRTOS750/tasks.c **** 		{
 553:../freeRTOS750/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 554:../freeRTOS750/tasks.c **** 			task can use this as a handle to delete the task later if
 555:../freeRTOS750/tasks.c **** 			required.*/
 556:../freeRTOS750/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 557:../freeRTOS750/tasks.c **** 		}
 558:../freeRTOS750/tasks.c **** 
 559:../freeRTOS750/tasks.c **** 		/* Ensure interrupts don't access the task lists while they are being
 560:../freeRTOS750/tasks.c **** 		updated. */
 561:../freeRTOS750/tasks.c **** 		taskENTER_CRITICAL();
 562:../freeRTOS750/tasks.c **** 		{
 563:../freeRTOS750/tasks.c **** 			uxCurrentNumberOfTasks++;
 564:../freeRTOS750/tasks.c **** 			if( pxCurrentTCB == NULL )
 565:../freeRTOS750/tasks.c **** 			{
 566:../freeRTOS750/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 567:../freeRTOS750/tasks.c **** 				the suspended state - make this the current task. */
 568:../freeRTOS750/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 569:../freeRTOS750/tasks.c **** 
 570:../freeRTOS750/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 571:../freeRTOS750/tasks.c **** 				{
 572:../freeRTOS750/tasks.c **** 					/* This is the first task to be created so do the preliminary
 573:../freeRTOS750/tasks.c **** 					initialisation required.  We will not recover if this call
 574:../freeRTOS750/tasks.c **** 					fails, but we will report the failure. */
 575:../freeRTOS750/tasks.c **** 					prvInitialiseTaskLists();
 576:../freeRTOS750/tasks.c **** 				}
 577:../freeRTOS750/tasks.c **** 			}
 578:../freeRTOS750/tasks.c **** 			else
 579:../freeRTOS750/tasks.c **** 			{
 580:../freeRTOS750/tasks.c **** 				/* If the scheduler is not already running, make this task the
 581:../freeRTOS750/tasks.c **** 				current task if it is the highest priority task to be created
 582:../freeRTOS750/tasks.c **** 				so far. */
 583:../freeRTOS750/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 584:../freeRTOS750/tasks.c **** 				{
 585:../freeRTOS750/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 586:../freeRTOS750/tasks.c **** 					{
 587:../freeRTOS750/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 588:../freeRTOS750/tasks.c **** 					}
 589:../freeRTOS750/tasks.c **** 				}
 590:../freeRTOS750/tasks.c **** 			}
 591:../freeRTOS750/tasks.c **** 
 592:../freeRTOS750/tasks.c **** 			uxTaskNumber++;
 593:../freeRTOS750/tasks.c **** 
 594:../freeRTOS750/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 595:../freeRTOS750/tasks.c **** 			{
 596:../freeRTOS750/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 597:../freeRTOS750/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 598:../freeRTOS750/tasks.c **** 			}
 599:../freeRTOS750/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 600:../freeRTOS750/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 601:../freeRTOS750/tasks.c **** 
 602:../freeRTOS750/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 603:../freeRTOS750/tasks.c **** 
 604:../freeRTOS750/tasks.c **** 			xReturn = pdPASS;
 605:../freeRTOS750/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 606:../freeRTOS750/tasks.c **** 		}
 607:../freeRTOS750/tasks.c **** 		taskEXIT_CRITICAL();
 608:../freeRTOS750/tasks.c **** 	}
 609:../freeRTOS750/tasks.c **** 	else
 610:../freeRTOS750/tasks.c **** 	{
 611:../freeRTOS750/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 612:../freeRTOS750/tasks.c **** 		traceTASK_CREATE_FAILED();
 613:../freeRTOS750/tasks.c **** 	}
 614:../freeRTOS750/tasks.c **** 
 615:../freeRTOS750/tasks.c **** 	if( xReturn == pdPASS )
 616:../freeRTOS750/tasks.c **** 	{
 617:../freeRTOS750/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 618:../freeRTOS750/tasks.c **** 		{
 619:../freeRTOS750/tasks.c **** 			/* If the created task is of a higher priority than the current task
 620:../freeRTOS750/tasks.c **** 			then it should run now. */
 621:../freeRTOS750/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 622:../freeRTOS750/tasks.c **** 			{
 623:../freeRTOS750/tasks.c **** 				portYIELD_WITHIN_API();
 624:../freeRTOS750/tasks.c **** 			}
 625:../freeRTOS750/tasks.c **** 		}
 626:../freeRTOS750/tasks.c **** 	}
 627:../freeRTOS750/tasks.c **** 
 628:../freeRTOS750/tasks.c **** 	return xReturn;
 629:../freeRTOS750/tasks.c **** }
 630:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
 631:../freeRTOS750/tasks.c **** 
 632:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 633:../freeRTOS750/tasks.c **** 
 634:../freeRTOS750/tasks.c **** 	void vTaskDelete( xTaskHandle xTaskToDelete )
 635:../freeRTOS750/tasks.c **** 	{
 636:../freeRTOS750/tasks.c **** 	tskTCB *pxTCB;
 637:../freeRTOS750/tasks.c **** 
 638:../freeRTOS750/tasks.c **** 		taskENTER_CRITICAL();
 639:../freeRTOS750/tasks.c **** 		{
 640:../freeRTOS750/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 641:../freeRTOS750/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 642:../freeRTOS750/tasks.c **** 
 643:../freeRTOS750/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 644:../freeRTOS750/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 645:../freeRTOS750/tasks.c **** 			the termination list and free up any memory allocated by the
 646:../freeRTOS750/tasks.c **** 			scheduler for the TCB and stack. */
 647:../freeRTOS750/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 648:../freeRTOS750/tasks.c **** 			{
 649:../freeRTOS750/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 650:../freeRTOS750/tasks.c **** 			}
 651:../freeRTOS750/tasks.c **** 
 652:../freeRTOS750/tasks.c **** 			/* Is the task waiting on an event also? */
 653:../freeRTOS750/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 654:../freeRTOS750/tasks.c **** 			{
 655:../freeRTOS750/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 656:../freeRTOS750/tasks.c **** 			}
 657:../freeRTOS750/tasks.c **** 
 658:../freeRTOS750/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 659:../freeRTOS750/tasks.c **** 
 660:../freeRTOS750/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 661:../freeRTOS750/tasks.c **** 			there is a task that has been deleted and that it should therefore
 662:../freeRTOS750/tasks.c **** 			check the xTasksWaitingTermination list. */
 663:../freeRTOS750/tasks.c **** 			++uxTasksDeleted;
 664:../freeRTOS750/tasks.c **** 
 665:../freeRTOS750/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 666:../freeRTOS750/tasks.c **** 			can detect that the task lists need re-generating. */
 667:../freeRTOS750/tasks.c **** 			uxTaskNumber++;
 668:../freeRTOS750/tasks.c **** 
 669:../freeRTOS750/tasks.c **** 			traceTASK_DELETE( pxTCB );
 670:../freeRTOS750/tasks.c **** 		}
 671:../freeRTOS750/tasks.c **** 		taskEXIT_CRITICAL();
 672:../freeRTOS750/tasks.c **** 
 673:../freeRTOS750/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 674:../freeRTOS750/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 675:../freeRTOS750/tasks.c **** 		{
 676:../freeRTOS750/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 677:../freeRTOS750/tasks.c **** 			{
 678:../freeRTOS750/tasks.c **** 				portYIELD_WITHIN_API();
 679:../freeRTOS750/tasks.c **** 			}
 680:../freeRTOS750/tasks.c **** 		}
 681:../freeRTOS750/tasks.c **** 	}
 682:../freeRTOS750/tasks.c **** 
 683:../freeRTOS750/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 684:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
 685:../freeRTOS750/tasks.c **** 
 686:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 687:../freeRTOS750/tasks.c **** 
 688:../freeRTOS750/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 689:../freeRTOS750/tasks.c **** 	{
 690:../freeRTOS750/tasks.c **** 	portTickType xTimeToWake;
 691:../freeRTOS750/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 692:../freeRTOS750/tasks.c **** 
 693:../freeRTOS750/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 694:../freeRTOS750/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 695:../freeRTOS750/tasks.c **** 
 696:../freeRTOS750/tasks.c **** 		vTaskSuspendAll();
 697:../freeRTOS750/tasks.c **** 		{
 698:../freeRTOS750/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
 699:../freeRTOS750/tasks.c **** 			block. */
 700:../freeRTOS750/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
 701:../freeRTOS750/tasks.c **** 
 702:../freeRTOS750/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 703:../freeRTOS750/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 704:../freeRTOS750/tasks.c **** 
 705:../freeRTOS750/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 706:../freeRTOS750/tasks.c **** 			{
 707:../freeRTOS750/tasks.c **** 				/* The tick count has overflowed since this function was
 708:../freeRTOS750/tasks.c **** 				lasted called.  In this case the only time we should ever
 709:../freeRTOS750/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 710:../freeRTOS750/tasks.c **** 				and the wake time is greater than the tick time.  When this
 711:../freeRTOS750/tasks.c **** 				is the case it is as if neither time had overflowed. */
 712:../freeRTOS750/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 713:../freeRTOS750/tasks.c **** 				{
 714:../freeRTOS750/tasks.c **** 					xShouldDelay = pdTRUE;
 715:../freeRTOS750/tasks.c **** 				}
 716:../freeRTOS750/tasks.c **** 			}
 717:../freeRTOS750/tasks.c **** 			else
 718:../freeRTOS750/tasks.c **** 			{
 719:../freeRTOS750/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 720:../freeRTOS750/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 721:../freeRTOS750/tasks.c **** 				tick time is less than the wake time. */
 722:../freeRTOS750/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 723:../freeRTOS750/tasks.c **** 				{
 724:../freeRTOS750/tasks.c **** 					xShouldDelay = pdTRUE;
 725:../freeRTOS750/tasks.c **** 				}
 726:../freeRTOS750/tasks.c **** 			}
 727:../freeRTOS750/tasks.c **** 
 728:../freeRTOS750/tasks.c **** 			/* Update the wake time ready for the next call. */
 729:../freeRTOS750/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 730:../freeRTOS750/tasks.c **** 
 731:../freeRTOS750/tasks.c **** 			if( xShouldDelay != pdFALSE )
 732:../freeRTOS750/tasks.c **** 			{
 733:../freeRTOS750/tasks.c **** 				traceTASK_DELAY_UNTIL();
 734:../freeRTOS750/tasks.c **** 
 735:../freeRTOS750/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 736:../freeRTOS750/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 737:../freeRTOS750/tasks.c **** 				both lists. */
 738:../freeRTOS750/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 739:../freeRTOS750/tasks.c **** 				{
 740:../freeRTOS750/tasks.c **** 					/* The current task must be in a ready list, so there is
 741:../freeRTOS750/tasks.c **** 					no need to check, and the port reset macro can be called
 742:../freeRTOS750/tasks.c **** 					directly. */
 743:../freeRTOS750/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 744:../freeRTOS750/tasks.c **** 				}
 745:../freeRTOS750/tasks.c **** 
 746:../freeRTOS750/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 747:../freeRTOS750/tasks.c **** 			}
 748:../freeRTOS750/tasks.c **** 		}
 749:../freeRTOS750/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 750:../freeRTOS750/tasks.c **** 
 751:../freeRTOS750/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 752:../freeRTOS750/tasks.c **** 		have put ourselves to sleep. */
 753:../freeRTOS750/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 754:../freeRTOS750/tasks.c **** 		{
 755:../freeRTOS750/tasks.c **** 			portYIELD_WITHIN_API();
 756:../freeRTOS750/tasks.c **** 		}
 757:../freeRTOS750/tasks.c **** 	}
 758:../freeRTOS750/tasks.c **** 
 759:../freeRTOS750/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 760:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
 761:../freeRTOS750/tasks.c **** 
 762:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 763:../freeRTOS750/tasks.c **** 
 764:../freeRTOS750/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 765:../freeRTOS750/tasks.c **** 	{
 766:../freeRTOS750/tasks.c **** 	portTickType xTimeToWake;
 767:../freeRTOS750/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 768:../freeRTOS750/tasks.c **** 
 769:../freeRTOS750/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 770:../freeRTOS750/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 771:../freeRTOS750/tasks.c **** 		{
 772:../freeRTOS750/tasks.c **** 			vTaskSuspendAll();
 773:../freeRTOS750/tasks.c **** 			{
 774:../freeRTOS750/tasks.c **** 				traceTASK_DELAY();
 775:../freeRTOS750/tasks.c **** 
 776:../freeRTOS750/tasks.c **** 				/* A task that is removed from the event list while the
 777:../freeRTOS750/tasks.c **** 				scheduler is suspended will not get placed in the ready
 778:../freeRTOS750/tasks.c **** 				list or removed from the blocked list until the scheduler
 779:../freeRTOS750/tasks.c **** 				is resumed.
 780:../freeRTOS750/tasks.c **** 
 781:../freeRTOS750/tasks.c **** 				This task cannot be in an event list as it is the currently
 782:../freeRTOS750/tasks.c **** 				executing task. */
 783:../freeRTOS750/tasks.c **** 
 784:../freeRTOS750/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 785:../freeRTOS750/tasks.c **** 				not a problem. */
 786:../freeRTOS750/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 787:../freeRTOS750/tasks.c **** 
 788:../freeRTOS750/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 789:../freeRTOS750/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 790:../freeRTOS750/tasks.c **** 				both lists. */
 791:../freeRTOS750/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 792:../freeRTOS750/tasks.c **** 				{
 793:../freeRTOS750/tasks.c **** 					/* The current task must be in a ready list, so there is
 794:../freeRTOS750/tasks.c **** 					no need to check, and the port reset macro can be called
 795:../freeRTOS750/tasks.c **** 					directly. */
 796:../freeRTOS750/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 797:../freeRTOS750/tasks.c **** 				}
 798:../freeRTOS750/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 799:../freeRTOS750/tasks.c **** 			}
 800:../freeRTOS750/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 801:../freeRTOS750/tasks.c **** 		}
 802:../freeRTOS750/tasks.c **** 
 803:../freeRTOS750/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 804:../freeRTOS750/tasks.c **** 		have put ourselves to sleep. */
 805:../freeRTOS750/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 806:../freeRTOS750/tasks.c **** 		{
 807:../freeRTOS750/tasks.c **** 			portYIELD_WITHIN_API();
 808:../freeRTOS750/tasks.c **** 		}
 809:../freeRTOS750/tasks.c **** 	}
 810:../freeRTOS750/tasks.c **** 
 811:../freeRTOS750/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 812:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
 813:../freeRTOS750/tasks.c **** 
 814:../freeRTOS750/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 815:../freeRTOS750/tasks.c **** 
 816:../freeRTOS750/tasks.c **** 	eTaskState eTaskGetState( xTaskHandle xTask )
 817:../freeRTOS750/tasks.c **** 	{
 818:../freeRTOS750/tasks.c **** 	eTaskState eReturn;
 819:../freeRTOS750/tasks.c **** 	xList *pxStateList;
 820:../freeRTOS750/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 821:../freeRTOS750/tasks.c **** 
 822:../freeRTOS750/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 823:../freeRTOS750/tasks.c **** 		{
 824:../freeRTOS750/tasks.c **** 			/* The task calling this function is querying its own state. */
 825:../freeRTOS750/tasks.c **** 			eReturn = eRunning;
 826:../freeRTOS750/tasks.c **** 		}
 827:../freeRTOS750/tasks.c **** 		else
 828:../freeRTOS750/tasks.c **** 		{
 829:../freeRTOS750/tasks.c **** 			taskENTER_CRITICAL();
 830:../freeRTOS750/tasks.c **** 			{
 831:../freeRTOS750/tasks.c **** 				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 832:../freeRTOS750/tasks.c **** 			}
 833:../freeRTOS750/tasks.c **** 			taskEXIT_CRITICAL();
 834:../freeRTOS750/tasks.c **** 
 835:../freeRTOS750/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 836:../freeRTOS750/tasks.c **** 			{
 837:../freeRTOS750/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 838:../freeRTOS750/tasks.c **** 				lists. */
 839:../freeRTOS750/tasks.c **** 				eReturn = eBlocked;
 840:../freeRTOS750/tasks.c **** 			}
 841:../freeRTOS750/tasks.c **** 
 842:../freeRTOS750/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 843:../freeRTOS750/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 844:../freeRTOS750/tasks.c **** 				{
 845:../freeRTOS750/tasks.c **** 					/* The task being queried is referenced from the suspended
 846:../freeRTOS750/tasks.c **** 					list. */
 847:../freeRTOS750/tasks.c **** 					eReturn = eSuspended;
 848:../freeRTOS750/tasks.c **** 				}
 849:../freeRTOS750/tasks.c **** 			#endif
 850:../freeRTOS750/tasks.c **** 
 851:../freeRTOS750/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 852:../freeRTOS750/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 853:../freeRTOS750/tasks.c **** 				{
 854:../freeRTOS750/tasks.c **** 					/* The task being queried is referenced from the deleted
 855:../freeRTOS750/tasks.c **** 					tasks list. */
 856:../freeRTOS750/tasks.c **** 					eReturn = eDeleted;
 857:../freeRTOS750/tasks.c **** 				}
 858:../freeRTOS750/tasks.c **** 			#endif
 859:../freeRTOS750/tasks.c **** 
 860:../freeRTOS750/tasks.c **** 			else
 861:../freeRTOS750/tasks.c **** 			{
 862:../freeRTOS750/tasks.c **** 				/* If the task is not in any other state, it must be in the
 863:../freeRTOS750/tasks.c **** 				Ready (including pending ready) state. */
 864:../freeRTOS750/tasks.c **** 				eReturn = eReady;
 865:../freeRTOS750/tasks.c **** 			}
 866:../freeRTOS750/tasks.c **** 		}
 867:../freeRTOS750/tasks.c **** 
 868:../freeRTOS750/tasks.c **** 		return eReturn;
 869:../freeRTOS750/tasks.c **** 	}
 870:../freeRTOS750/tasks.c **** 
 871:../freeRTOS750/tasks.c **** #endif /* INCLUDE_eTaskGetState */
 872:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
 873:../freeRTOS750/tasks.c **** 
 874:../freeRTOS750/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 875:../freeRTOS750/tasks.c **** 
 876:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
 877:../freeRTOS750/tasks.c **** 	{
 878:../freeRTOS750/tasks.c **** 	tskTCB *pxTCB;
 879:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 880:../freeRTOS750/tasks.c **** 
 881:../freeRTOS750/tasks.c **** 		taskENTER_CRITICAL();
 882:../freeRTOS750/tasks.c **** 		{
 883:../freeRTOS750/tasks.c **** 			/* If null is passed in here then we are changing the
 884:../freeRTOS750/tasks.c **** 			priority of the calling function. */
 885:../freeRTOS750/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 886:../freeRTOS750/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 887:../freeRTOS750/tasks.c **** 		}
 888:../freeRTOS750/tasks.c **** 		taskEXIT_CRITICAL();
 889:../freeRTOS750/tasks.c **** 
 890:../freeRTOS750/tasks.c **** 		return uxReturn;
 891:../freeRTOS750/tasks.c **** 	}
 892:../freeRTOS750/tasks.c **** 
 893:../freeRTOS750/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
 894:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
 895:../freeRTOS750/tasks.c **** 
 896:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 897:../freeRTOS750/tasks.c **** 
 898:../freeRTOS750/tasks.c **** 	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
 899:../freeRTOS750/tasks.c **** 	{
 900:../freeRTOS750/tasks.c **** 	tskTCB *pxTCB;
 901:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
 902:../freeRTOS750/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 903:../freeRTOS750/tasks.c **** 
 904:../freeRTOS750/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 905:../freeRTOS750/tasks.c **** 
 906:../freeRTOS750/tasks.c **** 		/* Ensure the new priority is valid. */
 907:../freeRTOS750/tasks.c **** 		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
 908:../freeRTOS750/tasks.c **** 		{
 909:../freeRTOS750/tasks.c **** 			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 910:../freeRTOS750/tasks.c **** 		}
 911:../freeRTOS750/tasks.c **** 
 912:../freeRTOS750/tasks.c **** 		taskENTER_CRITICAL();
 913:../freeRTOS750/tasks.c **** 		{
 914:../freeRTOS750/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
 915:../freeRTOS750/tasks.c **** 			task that is being changed. */
 916:../freeRTOS750/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 917:../freeRTOS750/tasks.c **** 
 918:../freeRTOS750/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 919:../freeRTOS750/tasks.c **** 
 920:../freeRTOS750/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 921:../freeRTOS750/tasks.c **** 			{
 922:../freeRTOS750/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 923:../freeRTOS750/tasks.c **** 			}
 924:../freeRTOS750/tasks.c **** 			#else
 925:../freeRTOS750/tasks.c **** 			{
 926:../freeRTOS750/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
 927:../freeRTOS750/tasks.c **** 			}
 928:../freeRTOS750/tasks.c **** 			#endif
 929:../freeRTOS750/tasks.c **** 
 930:../freeRTOS750/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 931:../freeRTOS750/tasks.c **** 			{
 932:../freeRTOS750/tasks.c **** 				/* The priority change may have readied a task of higher
 933:../freeRTOS750/tasks.c **** 				priority than the calling task. */
 934:../freeRTOS750/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 935:../freeRTOS750/tasks.c **** 				{
 936:../freeRTOS750/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 937:../freeRTOS750/tasks.c **** 					{
 938:../freeRTOS750/tasks.c **** 						/* The priority of a task other than the currently
 939:../freeRTOS750/tasks.c **** 						running task is being raised.  Is the priority being
 940:../freeRTOS750/tasks.c **** 						raised above that of the running task? */
 941:../freeRTOS750/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 942:../freeRTOS750/tasks.c **** 						{
 943:../freeRTOS750/tasks.c **** 							xYieldRequired = pdTRUE;
 944:../freeRTOS750/tasks.c **** 						}
 945:../freeRTOS750/tasks.c **** 					}
 946:../freeRTOS750/tasks.c **** 					else
 947:../freeRTOS750/tasks.c **** 					{
 948:../freeRTOS750/tasks.c **** 						/* The priority of the running task is being raised,
 949:../freeRTOS750/tasks.c **** 						but the running task must already be the highest
 950:../freeRTOS750/tasks.c **** 						priority task able to run so no yield is required. */
 951:../freeRTOS750/tasks.c **** 					}
 952:../freeRTOS750/tasks.c **** 				}
 953:../freeRTOS750/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 954:../freeRTOS750/tasks.c **** 				{
 955:../freeRTOS750/tasks.c **** 					/* Setting the priority of the running task down means
 956:../freeRTOS750/tasks.c **** 					there may now be another task of higher priority that
 957:../freeRTOS750/tasks.c **** 					is ready to execute. */
 958:../freeRTOS750/tasks.c **** 					xYieldRequired = pdTRUE;
 959:../freeRTOS750/tasks.c **** 				}
 960:../freeRTOS750/tasks.c **** 				else
 961:../freeRTOS750/tasks.c **** 				{
 962:../freeRTOS750/tasks.c **** 					/* Setting the priority of any other task down does not
 963:../freeRTOS750/tasks.c **** 					require a yield as the running task must be above the
 964:../freeRTOS750/tasks.c **** 					new priority of the task being modified. */
 965:../freeRTOS750/tasks.c **** 				}
 966:../freeRTOS750/tasks.c **** 
 967:../freeRTOS750/tasks.c **** 				/* Remember the ready list the task might be referenced from
 968:../freeRTOS750/tasks.c **** 				before its uxPriority member is changed so the
 969:../freeRTOS750/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
 970:../freeRTOS750/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 971:../freeRTOS750/tasks.c **** 
 972:../freeRTOS750/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 973:../freeRTOS750/tasks.c **** 				{
 974:../freeRTOS750/tasks.c **** 					/* Only change the priority being used if the task is not
 975:../freeRTOS750/tasks.c **** 					currently using an inherited priority. */
 976:../freeRTOS750/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 977:../freeRTOS750/tasks.c **** 					{
 978:../freeRTOS750/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 979:../freeRTOS750/tasks.c **** 					}
 980:../freeRTOS750/tasks.c **** 
 981:../freeRTOS750/tasks.c **** 					/* The base priority gets set whatever. */
 982:../freeRTOS750/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 983:../freeRTOS750/tasks.c **** 				}
 984:../freeRTOS750/tasks.c **** 				#else
 985:../freeRTOS750/tasks.c **** 				{
 986:../freeRTOS750/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 987:../freeRTOS750/tasks.c **** 				}
 988:../freeRTOS750/tasks.c **** 				#endif
 989:../freeRTOS750/tasks.c **** 
 990:../freeRTOS750/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - 
 991:../freeRTOS750/tasks.c **** 
 992:../freeRTOS750/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 993:../freeRTOS750/tasks.c **** 				nothing more than change it's priority variable. However, if
 994:../freeRTOS750/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 995:../freeRTOS750/tasks.c **** 				in the list appropriate to its new priority. */
 996:../freeRTOS750/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGeneri
 997:../freeRTOS750/tasks.c **** 				{
 998:../freeRTOS750/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 999:../freeRTOS750/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1000:../freeRTOS750/tasks.c **** 					can do this even if the scheduler is suspended. */
1001:../freeRTOS750/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
1002:../freeRTOS750/tasks.c **** 					{
1003:../freeRTOS750/tasks.c **** 						/* It is known that the task is in its ready list so
1004:../freeRTOS750/tasks.c **** 						there is no need to check again and the port level
1005:../freeRTOS750/tasks.c **** 						reset macro can be called directly. */
1006:../freeRTOS750/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1007:../freeRTOS750/tasks.c **** 					}
1008:../freeRTOS750/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1009:../freeRTOS750/tasks.c **** 				}
1010:../freeRTOS750/tasks.c **** 
1011:../freeRTOS750/tasks.c **** 				if( xYieldRequired == pdTRUE )
1012:../freeRTOS750/tasks.c **** 				{
1013:../freeRTOS750/tasks.c **** 					portYIELD_WITHIN_API();
1014:../freeRTOS750/tasks.c **** 				}
1015:../freeRTOS750/tasks.c **** 
1016:../freeRTOS750/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1017:../freeRTOS750/tasks.c **** 				optimised task selection is not being used. */
1018:../freeRTOS750/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1019:../freeRTOS750/tasks.c **** 			}
1020:../freeRTOS750/tasks.c **** 		}
1021:../freeRTOS750/tasks.c **** 		taskEXIT_CRITICAL();
1022:../freeRTOS750/tasks.c **** 	}
1023:../freeRTOS750/tasks.c **** 
1024:../freeRTOS750/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1025:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1026:../freeRTOS750/tasks.c **** 
1027:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1028:../freeRTOS750/tasks.c **** 
1029:../freeRTOS750/tasks.c **** 	void vTaskSuspend( xTaskHandle xTaskToSuspend )
1030:../freeRTOS750/tasks.c **** 	{
1031:../freeRTOS750/tasks.c **** 	tskTCB *pxTCB;
1032:../freeRTOS750/tasks.c **** 
1033:../freeRTOS750/tasks.c **** 		taskENTER_CRITICAL();
1034:../freeRTOS750/tasks.c **** 		{
1035:../freeRTOS750/tasks.c **** 			/* If null is passed in here then it is the running task that is
1036:../freeRTOS750/tasks.c **** 			being suspended. */
1037:../freeRTOS750/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1038:../freeRTOS750/tasks.c **** 
1039:../freeRTOS750/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1040:../freeRTOS750/tasks.c **** 
1041:../freeRTOS750/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
1042:../freeRTOS750/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
1043:../freeRTOS750/tasks.c **** 			{
1044:../freeRTOS750/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1045:../freeRTOS750/tasks.c **** 			}
1046:../freeRTOS750/tasks.c **** 
1047:../freeRTOS750/tasks.c **** 			/* Is the task waiting on an event also? */
1048:../freeRTOS750/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1049:../freeRTOS750/tasks.c **** 			{
1050:../freeRTOS750/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1051:../freeRTOS750/tasks.c **** 			}
1052:../freeRTOS750/tasks.c **** 
1053:../freeRTOS750/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
1054:../freeRTOS750/tasks.c **** 		}
1055:../freeRTOS750/tasks.c **** 		taskEXIT_CRITICAL();
1056:../freeRTOS750/tasks.c **** 
1057:../freeRTOS750/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1058:../freeRTOS750/tasks.c **** 		{
1059:../freeRTOS750/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1060:../freeRTOS750/tasks.c **** 			{
1061:../freeRTOS750/tasks.c **** 				/* The current task has just been suspended. */
1062:../freeRTOS750/tasks.c **** 				portYIELD_WITHIN_API();
1063:../freeRTOS750/tasks.c **** 			}
1064:../freeRTOS750/tasks.c **** 			else
1065:../freeRTOS750/tasks.c **** 			{
1066:../freeRTOS750/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1067:../freeRTOS750/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1068:../freeRTOS750/tasks.c **** 				must be adjusted to point to a different task. */
1069:../freeRTOS750/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
1070:../freeRTOS750/tasks.c **** 				{
1071:../freeRTOS750/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1072:../freeRTOS750/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1073:../freeRTOS750/tasks.c **** 					be set to point to it no matter what its relative priority
1074:../freeRTOS750/tasks.c **** 					is. */
1075:../freeRTOS750/tasks.c **** 					pxCurrentTCB = NULL;
1076:../freeRTOS750/tasks.c **** 				}
1077:../freeRTOS750/tasks.c **** 				else
1078:../freeRTOS750/tasks.c **** 				{
1079:../freeRTOS750/tasks.c **** 					vTaskSwitchContext();
1080:../freeRTOS750/tasks.c **** 				}
1081:../freeRTOS750/tasks.c **** 			}
1082:../freeRTOS750/tasks.c **** 		}
1083:../freeRTOS750/tasks.c **** 	}
1084:../freeRTOS750/tasks.c **** 
1085:../freeRTOS750/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1086:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1087:../freeRTOS750/tasks.c **** 
1088:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1089:../freeRTOS750/tasks.c **** 
1090:../freeRTOS750/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
1091:../freeRTOS750/tasks.c **** 	{
1092:../freeRTOS750/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
1093:../freeRTOS750/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
1094:../freeRTOS750/tasks.c **** 
1095:../freeRTOS750/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1096:../freeRTOS750/tasks.c **** 		configASSERT( xTask );
1097:../freeRTOS750/tasks.c **** 
1098:../freeRTOS750/tasks.c **** 		/* Is the task we are attempting to resume actually in the
1099:../freeRTOS750/tasks.c **** 		suspended list? */
1100:../freeRTOS750/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
1101:../freeRTOS750/tasks.c **** 		{
1102:../freeRTOS750/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1103:../freeRTOS750/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1104:../freeRTOS750/tasks.c **** 			{
1105:../freeRTOS750/tasks.c **** 				/* Is it in the suspended list because it is in the
1106:../freeRTOS750/tasks.c **** 				Suspended state?  It is possible to be in the suspended
1107:../freeRTOS750/tasks.c **** 				list because it is blocked on a task with no timeout
1108:../freeRTOS750/tasks.c **** 				specified. */
1109:../freeRTOS750/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
1110:../freeRTOS750/tasks.c **** 				{
1111:../freeRTOS750/tasks.c **** 					xReturn = pdTRUE;
1112:../freeRTOS750/tasks.c **** 				}
1113:../freeRTOS750/tasks.c **** 			}
1114:../freeRTOS750/tasks.c **** 		}
1115:../freeRTOS750/tasks.c **** 
1116:../freeRTOS750/tasks.c **** 		return xReturn;
1117:../freeRTOS750/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1118:../freeRTOS750/tasks.c **** 
1119:../freeRTOS750/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1120:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1121:../freeRTOS750/tasks.c **** 
1122:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1123:../freeRTOS750/tasks.c **** 
1124:../freeRTOS750/tasks.c **** 	void vTaskResume( xTaskHandle xTaskToResume )
1125:../freeRTOS750/tasks.c **** 	{
1126:../freeRTOS750/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
1127:../freeRTOS750/tasks.c **** 
1128:../freeRTOS750/tasks.c **** 		/* It does not make sense to resume the calling task. */
1129:../freeRTOS750/tasks.c **** 		configASSERT( xTaskToResume );
1130:../freeRTOS750/tasks.c **** 
1131:../freeRTOS750/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1132:../freeRTOS750/tasks.c **** 		currently executing task. */
1133:../freeRTOS750/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1134:../freeRTOS750/tasks.c **** 		{
1135:../freeRTOS750/tasks.c **** 			taskENTER_CRITICAL();
1136:../freeRTOS750/tasks.c **** 			{
1137:../freeRTOS750/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1138:../freeRTOS750/tasks.c **** 				{
1139:../freeRTOS750/tasks.c **** 					traceTASK_RESUME( pxTCB );
1140:../freeRTOS750/tasks.c **** 
1141:../freeRTOS750/tasks.c **** 					/* As we are in a critical section we can access the ready
1142:../freeRTOS750/tasks.c **** 					lists even if the scheduler is suspended. */
1143:../freeRTOS750/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
1144:../freeRTOS750/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1145:../freeRTOS750/tasks.c **** 
1146:../freeRTOS750/tasks.c **** 					/* We may have just resumed a higher priority task. */
1147:../freeRTOS750/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1148:../freeRTOS750/tasks.c **** 					{
1149:../freeRTOS750/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1150:../freeRTOS750/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1151:../freeRTOS750/tasks.c **** 						portYIELD_WITHIN_API();
1152:../freeRTOS750/tasks.c **** 					}
1153:../freeRTOS750/tasks.c **** 				}
1154:../freeRTOS750/tasks.c **** 			}
1155:../freeRTOS750/tasks.c **** 			taskEXIT_CRITICAL();
1156:../freeRTOS750/tasks.c **** 		}
1157:../freeRTOS750/tasks.c **** 	}
1158:../freeRTOS750/tasks.c **** 
1159:../freeRTOS750/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1160:../freeRTOS750/tasks.c **** 
1161:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1162:../freeRTOS750/tasks.c **** 
1163:../freeRTOS750/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1164:../freeRTOS750/tasks.c **** 
1165:../freeRTOS750/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
1166:../freeRTOS750/tasks.c **** 	{
1167:../freeRTOS750/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
1168:../freeRTOS750/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
1169:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1170:../freeRTOS750/tasks.c **** 
1171:../freeRTOS750/tasks.c **** 		configASSERT( xTaskToResume );
1172:../freeRTOS750/tasks.c **** 
1173:../freeRTOS750/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1174:../freeRTOS750/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1175:../freeRTOS750/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1176:../freeRTOS750/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1177:../freeRTOS750/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1178:../freeRTOS750/tasks.c **** 		is defined in FreeRTOSConfig.h then
1179:../freeRTOS750/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1180:../freeRTOS750/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1181:../freeRTOS750/tasks.c **** 		been assigned a priority above the configured maximum system call
1182:../freeRTOS750/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1183:../freeRTOS750/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1184:../freeRTOS750/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1185:../freeRTOS750/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1186:../freeRTOS750/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1187:../freeRTOS750/tasks.c **** 		provided on the following link:
1188:../freeRTOS750/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1189:../freeRTOS750/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1190:../freeRTOS750/tasks.c **** 
1191:../freeRTOS750/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1192:../freeRTOS750/tasks.c **** 		{
1193:../freeRTOS750/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1194:../freeRTOS750/tasks.c **** 			{
1195:../freeRTOS750/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1196:../freeRTOS750/tasks.c **** 
1197:../freeRTOS750/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1198:../freeRTOS750/tasks.c **** 				{
1199:../freeRTOS750/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
1200:../freeRTOS750/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
1201:../freeRTOS750/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1202:../freeRTOS750/tasks.c **** 				}
1203:../freeRTOS750/tasks.c **** 				else
1204:../freeRTOS750/tasks.c **** 				{
1205:../freeRTOS750/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1206:../freeRTOS750/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1207:../freeRTOS750/tasks.c **** 					yield will be performed if necessary. */
1208:../freeRTOS750/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1209:../freeRTOS750/tasks.c **** 				}
1210:../freeRTOS750/tasks.c **** 			}
1211:../freeRTOS750/tasks.c **** 		}
1212:../freeRTOS750/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1213:../freeRTOS750/tasks.c **** 
1214:../freeRTOS750/tasks.c **** 		return xYieldRequired;
1215:../freeRTOS750/tasks.c **** 	}
1216:../freeRTOS750/tasks.c **** 
1217:../freeRTOS750/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1218:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1219:../freeRTOS750/tasks.c **** 
1220:../freeRTOS750/tasks.c **** void vTaskStartScheduler( void )
1221:../freeRTOS750/tasks.c **** {
1222:../freeRTOS750/tasks.c **** portBASE_TYPE xReturn;
1223:../freeRTOS750/tasks.c **** 
1224:../freeRTOS750/tasks.c **** 	/* Add the idle task at the lowest priority. */
1225:../freeRTOS750/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1226:../freeRTOS750/tasks.c **** 	{
1227:../freeRTOS750/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1228:../freeRTOS750/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1229:../freeRTOS750/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1230:../freeRTOS750/tasks.c **** 	}
1231:../freeRTOS750/tasks.c **** 	#else
1232:../freeRTOS750/tasks.c **** 	{
1233:../freeRTOS750/tasks.c **** 		/* Create the idle task without storing its handle. */
1234:../freeRTOS750/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1235:../freeRTOS750/tasks.c **** 	}
1236:../freeRTOS750/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1237:../freeRTOS750/tasks.c **** 
1238:../freeRTOS750/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1239:../freeRTOS750/tasks.c **** 	{
1240:../freeRTOS750/tasks.c **** 		if( xReturn == pdPASS )
1241:../freeRTOS750/tasks.c **** 		{
1242:../freeRTOS750/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1243:../freeRTOS750/tasks.c **** 		}
1244:../freeRTOS750/tasks.c **** 	}
1245:../freeRTOS750/tasks.c **** 	#endif /* configUSE_TIMERS */
1246:../freeRTOS750/tasks.c **** 
1247:../freeRTOS750/tasks.c **** 	if( xReturn == pdPASS )
1248:../freeRTOS750/tasks.c **** 	{
1249:../freeRTOS750/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1250:../freeRTOS750/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1251:../freeRTOS750/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1252:../freeRTOS750/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1253:../freeRTOS750/tasks.c **** 		starts to run.
1254:../freeRTOS750/tasks.c **** 
1255:../freeRTOS750/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1256:../freeRTOS750/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1257:../freeRTOS750/tasks.c **** 		portDISABLE_INTERRUPTS();
1258:../freeRTOS750/tasks.c **** 
1259:../freeRTOS750/tasks.c **** 		xSchedulerRunning = pdTRUE;
1260:../freeRTOS750/tasks.c **** 		xTickCount = ( portTickType ) 0U;
1261:../freeRTOS750/tasks.c **** 
1262:../freeRTOS750/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1263:../freeRTOS750/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1264:../freeRTOS750/tasks.c **** 		the run time counter time base. */
1265:../freeRTOS750/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1266:../freeRTOS750/tasks.c **** 
1267:../freeRTOS750/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1268:../freeRTOS750/tasks.c **** 		portable interface. */
1269:../freeRTOS750/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
1270:../freeRTOS750/tasks.c **** 		{
1271:../freeRTOS750/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1272:../freeRTOS750/tasks.c **** 			function will not return. */
1273:../freeRTOS750/tasks.c **** 		}
1274:../freeRTOS750/tasks.c **** 		else
1275:../freeRTOS750/tasks.c **** 		{
1276:../freeRTOS750/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1277:../freeRTOS750/tasks.c **** 		}
1278:../freeRTOS750/tasks.c **** 	}
1279:../freeRTOS750/tasks.c **** 	else
1280:../freeRTOS750/tasks.c **** 	{
1281:../freeRTOS750/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1282:../freeRTOS750/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1283:../freeRTOS750/tasks.c **** 		or the timer task. */
1284:../freeRTOS750/tasks.c **** 		configASSERT( xReturn );
1285:../freeRTOS750/tasks.c **** 	}
1286:../freeRTOS750/tasks.c **** }
1287:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1288:../freeRTOS750/tasks.c **** 
1289:../freeRTOS750/tasks.c **** void vTaskEndScheduler( void )
1290:../freeRTOS750/tasks.c **** {
1291:../freeRTOS750/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1292:../freeRTOS750/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1293:../freeRTOS750/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1294:../freeRTOS750/tasks.c **** 	portDISABLE_INTERRUPTS();
1295:../freeRTOS750/tasks.c **** 	xSchedulerRunning = pdFALSE;
1296:../freeRTOS750/tasks.c **** 	vPortEndScheduler();
1297:../freeRTOS750/tasks.c **** }
1298:../freeRTOS750/tasks.c **** /*----------------------------------------------------------*/
1299:../freeRTOS750/tasks.c **** 
1300:../freeRTOS750/tasks.c **** void vTaskSuspendAll( void )
1301:../freeRTOS750/tasks.c **** {
1302:../freeRTOS750/tasks.c **** 	/* A critical section is not required as the variable is of type
1303:../freeRTOS750/tasks.c **** 	portBASE_TYPE. */
1304:../freeRTOS750/tasks.c **** 	++uxSchedulerSuspended;
1305:../freeRTOS750/tasks.c **** }
1306:../freeRTOS750/tasks.c **** /*----------------------------------------------------------*/
1307:../freeRTOS750/tasks.c **** 
1308:../freeRTOS750/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1309:../freeRTOS750/tasks.c **** 
1310:../freeRTOS750/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void )
1311:../freeRTOS750/tasks.c **** 	{
1312:../freeRTOS750/tasks.c **** 	portTickType xReturn;
1313:../freeRTOS750/tasks.c **** 
1314:../freeRTOS750/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1315:../freeRTOS750/tasks.c **** 		{
1316:../freeRTOS750/tasks.c **** 			xReturn = 0;
1317:../freeRTOS750/tasks.c **** 		}
1318:../freeRTOS750/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1319:../freeRTOS750/tasks.c **** 		{
1320:../freeRTOS750/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1321:../freeRTOS750/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1322:../freeRTOS750/tasks.c **** 			processed. */
1323:../freeRTOS750/tasks.c **** 			xReturn = 0;
1324:../freeRTOS750/tasks.c **** 		}
1325:../freeRTOS750/tasks.c **** 		else
1326:../freeRTOS750/tasks.c **** 		{
1327:../freeRTOS750/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1328:../freeRTOS750/tasks.c **** 		}
1329:../freeRTOS750/tasks.c **** 
1330:../freeRTOS750/tasks.c **** 		return xReturn;
1331:../freeRTOS750/tasks.c **** 	}
1332:../freeRTOS750/tasks.c **** 
1333:../freeRTOS750/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1334:../freeRTOS750/tasks.c **** /*----------------------------------------------------------*/
1335:../freeRTOS750/tasks.c **** 
1336:../freeRTOS750/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1337:../freeRTOS750/tasks.c **** {
1338:../freeRTOS750/tasks.c **** tskTCB *pxTCB;
1339:../freeRTOS750/tasks.c **** portBASE_TYPE xAlreadyYielded = pdFALSE;
1340:../freeRTOS750/tasks.c **** portBASE_TYPE xYieldRequired = pdFALSE;
1341:../freeRTOS750/tasks.c **** 
1342:../freeRTOS750/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1343:../freeRTOS750/tasks.c **** 	previous call to vTaskSuspendAll(). */
1344:../freeRTOS750/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1345:../freeRTOS750/tasks.c **** 
1346:../freeRTOS750/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1347:../freeRTOS750/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1348:../freeRTOS750/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1349:../freeRTOS750/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1350:../freeRTOS750/tasks.c **** 	tasks from this list into their appropriate ready list. */
1351:../freeRTOS750/tasks.c **** 	taskENTER_CRITICAL();
1352:../freeRTOS750/tasks.c **** 	{
1353:../freeRTOS750/tasks.c **** 		--uxSchedulerSuspended;
1354:../freeRTOS750/tasks.c **** 
1355:../freeRTOS750/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1356:../freeRTOS750/tasks.c **** 		{
1357:../freeRTOS750/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
1358:../freeRTOS750/tasks.c **** 			{
1359:../freeRTOS750/tasks.c **** 				/* Move any readied tasks from the pending list into the
1360:../freeRTOS750/tasks.c **** 				appropriate ready list. */
1361:../freeRTOS750/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
1362:../freeRTOS750/tasks.c **** 				{
1363:../freeRTOS750/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
1364:../freeRTOS750/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1365:../freeRTOS750/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
1366:../freeRTOS750/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1367:../freeRTOS750/tasks.c **** 
1368:../freeRTOS750/tasks.c **** 					/* If we have moved a task that has a priority higher than
1369:../freeRTOS750/tasks.c **** 					the current task then we should yield. */
1370:../freeRTOS750/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1371:../freeRTOS750/tasks.c **** 					{
1372:../freeRTOS750/tasks.c **** 						xYieldRequired = pdTRUE;
1373:../freeRTOS750/tasks.c **** 					}
1374:../freeRTOS750/tasks.c **** 				}
1375:../freeRTOS750/tasks.c **** 
1376:../freeRTOS750/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1377:../freeRTOS750/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1378:../freeRTOS750/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1379:../freeRTOS750/tasks.c **** 				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
1380:../freeRTOS750/tasks.c **** 				{
1381:../freeRTOS750/tasks.c **** 					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
1382:../freeRTOS750/tasks.c **** 					{
1383:../freeRTOS750/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
1384:../freeRTOS750/tasks.c **** 						{
1385:../freeRTOS750/tasks.c **** 							xYieldRequired = pdTRUE;
1386:../freeRTOS750/tasks.c **** 						}
1387:../freeRTOS750/tasks.c **** 						--uxPendedTicks;
1388:../freeRTOS750/tasks.c **** 					}
1389:../freeRTOS750/tasks.c **** 				}
1390:../freeRTOS750/tasks.c **** 
1391:../freeRTOS750/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xYieldPending == pdTRUE ) )
1392:../freeRTOS750/tasks.c **** 				{
1393:../freeRTOS750/tasks.c **** 					xAlreadyYielded = pdTRUE;
1394:../freeRTOS750/tasks.c **** 					xYieldPending = pdFALSE;
1395:../freeRTOS750/tasks.c **** 					portYIELD_WITHIN_API();
1396:../freeRTOS750/tasks.c **** 				}
1397:../freeRTOS750/tasks.c **** 			}
1398:../freeRTOS750/tasks.c **** 		}
1399:../freeRTOS750/tasks.c **** 	}
1400:../freeRTOS750/tasks.c **** 	taskEXIT_CRITICAL();
1401:../freeRTOS750/tasks.c **** 
1402:../freeRTOS750/tasks.c **** 	return xAlreadyYielded;
1403:../freeRTOS750/tasks.c **** }
1404:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1405:../freeRTOS750/tasks.c **** 
1406:../freeRTOS750/tasks.c **** portTickType xTaskGetTickCount( void )
1407:../freeRTOS750/tasks.c **** {
1408:../freeRTOS750/tasks.c **** portTickType xTicks;
1409:../freeRTOS750/tasks.c **** 
1410:../freeRTOS750/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1411:../freeRTOS750/tasks.c **** 	taskENTER_CRITICAL();
1412:../freeRTOS750/tasks.c **** 	{
1413:../freeRTOS750/tasks.c **** 		xTicks = xTickCount;
1414:../freeRTOS750/tasks.c **** 	}
1415:../freeRTOS750/tasks.c **** 	taskEXIT_CRITICAL();
1416:../freeRTOS750/tasks.c **** 
1417:../freeRTOS750/tasks.c **** 	return xTicks;
1418:../freeRTOS750/tasks.c **** }
1419:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1420:../freeRTOS750/tasks.c **** 
1421:../freeRTOS750/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1422:../freeRTOS750/tasks.c **** {
1423:../freeRTOS750/tasks.c **** portTickType xReturn;
1424:../freeRTOS750/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1425:../freeRTOS750/tasks.c **** 
1426:../freeRTOS750/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1427:../freeRTOS750/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1428:../freeRTOS750/tasks.c **** 	above the maximum system call priority are keep permanently enabled, even
1429:../freeRTOS750/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1430:../freeRTOS750/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1431:../freeRTOS750/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1432:../freeRTOS750/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1433:../freeRTOS750/tasks.c **** 	assigned a priority above the configured maximum system call priority.
1434:../freeRTOS750/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1435:../freeRTOS750/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
1436:../freeRTOS750/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1437:../freeRTOS750/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1438:../freeRTOS750/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
1439:../freeRTOS750/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1440:../freeRTOS750/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1441:../freeRTOS750/tasks.c **** 
1442:../freeRTOS750/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1443:../freeRTOS750/tasks.c **** 	xReturn = xTickCount;
1444:../freeRTOS750/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1445:../freeRTOS750/tasks.c **** 
1446:../freeRTOS750/tasks.c **** 	return xReturn;
1447:../freeRTOS750/tasks.c **** }
1448:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1449:../freeRTOS750/tasks.c **** 
1450:../freeRTOS750/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1451:../freeRTOS750/tasks.c **** {
1452:../freeRTOS750/tasks.c **** 	/* A critical section is not required because the variables are of type
1453:../freeRTOS750/tasks.c **** 	portBASE_TYPE. */
1454:../freeRTOS750/tasks.c **** 	return uxCurrentNumberOfTasks;
1455:../freeRTOS750/tasks.c **** }
1456:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1457:../freeRTOS750/tasks.c **** 
1458:../freeRTOS750/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1459:../freeRTOS750/tasks.c **** 
1460:../freeRTOS750/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1461:../freeRTOS750/tasks.c **** 	{
1462:../freeRTOS750/tasks.c **** 	tskTCB *pxTCB;
1463:../freeRTOS750/tasks.c **** 
1464:../freeRTOS750/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1465:../freeRTOS750/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1466:../freeRTOS750/tasks.c **** 		configASSERT( pxTCB );
1467:../freeRTOS750/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1468:../freeRTOS750/tasks.c **** 	}
1469:../freeRTOS750/tasks.c **** 
1470:../freeRTOS750/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1471:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1472:../freeRTOS750/tasks.c **** 
1473:../freeRTOS750/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1474:../freeRTOS750/tasks.c **** 
1475:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetSystemState( xTaskStatusType *pxTaskStatusArray, unsigned portBASE
1476:../freeRTOS750/tasks.c **** 	{
1477:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxTask = 0, uxQueue = configMAX_PRIORITIES;
1478:../freeRTOS750/tasks.c **** 
1479:../freeRTOS750/tasks.c **** 		vTaskSuspendAll();
1480:../freeRTOS750/tasks.c **** 		{
1481:../freeRTOS750/tasks.c **** 			/* Is there a space in the array for each task in the system? */
1482:../freeRTOS750/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
1483:../freeRTOS750/tasks.c **** 			{
1484:../freeRTOS750/tasks.c **** 				/* Fill in an xTaskStatusType structure with information on each
1485:../freeRTOS750/tasks.c **** 				task in the Ready state. */
1486:../freeRTOS750/tasks.c **** 				do
1487:../freeRTOS750/tasks.c **** 				{
1488:../freeRTOS750/tasks.c **** 					uxQueue--;
1489:../freeRTOS750/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[
1490:../freeRTOS750/tasks.c **** 
1491:../freeRTOS750/tasks.c **** 				} while( uxQueue > ( unsigned portBASE_TYPE ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception 
1492:../freeRTOS750/tasks.c **** 
1493:../freeRTOS750/tasks.c **** 				/* Fill in an xTaskStatusType structure with information on each
1494:../freeRTOS750/tasks.c **** 				task in the Blocked state. */
1495:../freeRTOS750/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxDelayedT
1496:../freeRTOS750/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxOverflow
1497:../freeRTOS750/tasks.c **** 
1498:../freeRTOS750/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
1499:../freeRTOS750/tasks.c **** 				{
1500:../freeRTOS750/tasks.c **** 					/* Fill in an xTaskStatusType structure with information on
1501:../freeRTOS750/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
1502:../freeRTOS750/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermina
1503:../freeRTOS750/tasks.c **** 				}
1504:../freeRTOS750/tasks.c **** 				#endif
1505:../freeRTOS750/tasks.c **** 
1506:../freeRTOS750/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
1507:../freeRTOS750/tasks.c **** 				{
1508:../freeRTOS750/tasks.c **** 					/* Fill in an xTaskStatusType structure with information on
1509:../freeRTOS750/tasks.c **** 					each task in the Suspended state. */
1510:../freeRTOS750/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, 
1511:../freeRTOS750/tasks.c **** 				}
1512:../freeRTOS750/tasks.c **** 				#endif
1513:../freeRTOS750/tasks.c **** 
1514:../freeRTOS750/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
1515:../freeRTOS750/tasks.c **** 				{
1516:../freeRTOS750/tasks.c **** 					if( pulTotalRunTime != NULL )
1517:../freeRTOS750/tasks.c **** 					{
1518:../freeRTOS750/tasks.c **** 						*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1519:../freeRTOS750/tasks.c **** 					}
1520:../freeRTOS750/tasks.c **** 				}
1521:../freeRTOS750/tasks.c **** 				#else
1522:../freeRTOS750/tasks.c **** 				{
1523:../freeRTOS750/tasks.c **** 					if( pulTotalRunTime != NULL )
1524:../freeRTOS750/tasks.c **** 					{
1525:../freeRTOS750/tasks.c **** 						*pulTotalRunTime = 0;
1526:../freeRTOS750/tasks.c **** 					}
1527:../freeRTOS750/tasks.c **** 				}
1528:../freeRTOS750/tasks.c **** 				#endif
1529:../freeRTOS750/tasks.c **** 			}
1530:../freeRTOS750/tasks.c **** 		}
1531:../freeRTOS750/tasks.c **** 		( void ) xTaskResumeAll();
1532:../freeRTOS750/tasks.c **** 
1533:../freeRTOS750/tasks.c **** 		return uxTask;
1534:../freeRTOS750/tasks.c **** 	}
1535:../freeRTOS750/tasks.c **** 
1536:../freeRTOS750/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1537:../freeRTOS750/tasks.c **** /*----------------------------------------------------------*/
1538:../freeRTOS750/tasks.c **** 
1539:../freeRTOS750/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1540:../freeRTOS750/tasks.c **** 
1541:../freeRTOS750/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1542:../freeRTOS750/tasks.c **** 	{
1543:../freeRTOS750/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1544:../freeRTOS750/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1545:../freeRTOS750/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1546:../freeRTOS750/tasks.c **** 		return xIdleTaskHandle;
1547:../freeRTOS750/tasks.c **** 	}
1548:../freeRTOS750/tasks.c **** 
1549:../freeRTOS750/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1550:../freeRTOS750/tasks.c **** /*----------------------------------------------------------*/
1551:../freeRTOS750/tasks.c **** 
1552:../freeRTOS750/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1553:../freeRTOS750/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1554:../freeRTOS750/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1555:../freeRTOS750/tasks.c **** 1. */
1556:../freeRTOS750/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1557:../freeRTOS750/tasks.c **** 
1558:../freeRTOS750/tasks.c **** 	void vTaskStepTick( portTickType xTicksToJump )
1559:../freeRTOS750/tasks.c **** 	{
1560:../freeRTOS750/tasks.c **** 		/* Correct the tick count value after a period during which the tick
1561:../freeRTOS750/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
1562:../freeRTOS750/tasks.c **** 		each stepped tick. */
1563:../freeRTOS750/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1564:../freeRTOS750/tasks.c **** 		xTickCount += xTicksToJump;
1565:../freeRTOS750/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
1566:../freeRTOS750/tasks.c **** 	}
1567:../freeRTOS750/tasks.c **** 
1568:../freeRTOS750/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1569:../freeRTOS750/tasks.c **** /*----------------------------------------------------------*/
1570:../freeRTOS750/tasks.c **** 
1571:../freeRTOS750/tasks.c **** portBASE_TYPE xTaskIncrementTick( void )
1572:../freeRTOS750/tasks.c **** {
1573:../freeRTOS750/tasks.c **** tskTCB * pxTCB;
1574:../freeRTOS750/tasks.c **** portTickType xItemValue;
1575:../freeRTOS750/tasks.c **** portBASE_TYPE xSwitchRequired = pdFALSE;
1576:../freeRTOS750/tasks.c **** 
1577:../freeRTOS750/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1578:../freeRTOS750/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1579:../freeRTOS750/tasks.c **** 	tasks to be unblocked. */
1580:../freeRTOS750/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1581:../freeRTOS750/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1582:../freeRTOS750/tasks.c **** 	{
1583:../freeRTOS750/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
1584:../freeRTOS750/tasks.c **** 		delayed lists if it wraps to 0. */
1585:../freeRTOS750/tasks.c **** 		++xTickCount;
1586:../freeRTOS750/tasks.c **** 
1587:../freeRTOS750/tasks.c **** 		{
1588:../freeRTOS750/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1589:../freeRTOS750/tasks.c **** 			block. */
1590:../freeRTOS750/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
1591:../freeRTOS750/tasks.c **** 
1592:../freeRTOS750/tasks.c **** 			if( xConstTickCount == ( portTickType ) 0U )
1593:../freeRTOS750/tasks.c **** 			{
1594:../freeRTOS750/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
1595:../freeRTOS750/tasks.c **** 			}
1596:../freeRTOS750/tasks.c **** 
1597:../freeRTOS750/tasks.c **** 			/* See if this tick has made a timeout expire.  Tasks are stored in the
1598:../freeRTOS750/tasks.c **** 			queue in the order of their wake time - meaning once one tasks has been
1599:../freeRTOS750/tasks.c **** 			found whose block time has not expired there is no need not look any
1600:../freeRTOS750/tasks.c **** 			further	down the list. */
1601:../freeRTOS750/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
1602:../freeRTOS750/tasks.c **** 			{
1603:../freeRTOS750/tasks.c **** 				for( ;; )
1604:../freeRTOS750/tasks.c **** 				{
1605:../freeRTOS750/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1606:../freeRTOS750/tasks.c **** 					{
1607:../freeRTOS750/tasks.c **** 						/* The delayed list is empty.  Set xNextTaskUnblockTime to
1608:../freeRTOS750/tasks.c **** 						the	maximum possible value so it is extremely unlikely that
1609:../freeRTOS750/tasks.c **** 						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
1610:../freeRTOS750/tasks.c **** 						next time through. */
1611:../freeRTOS750/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
1612:../freeRTOS750/tasks.c **** 						break;
1613:../freeRTOS750/tasks.c **** 					}
1614:../freeRTOS750/tasks.c **** 					else
1615:../freeRTOS750/tasks.c **** 					{
1616:../freeRTOS750/tasks.c **** 						/* The delayed list is not empty, get the value of the item
1617:../freeRTOS750/tasks.c **** 						at the head of the delayed list.  This is the time at which
1618:../freeRTOS750/tasks.c **** 						the task at the head of the delayed list must be removed
1619:../freeRTOS750/tasks.c **** 						from the Blocked state. */
1620:../freeRTOS750/tasks.c **** 						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1621:../freeRTOS750/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
1622:../freeRTOS750/tasks.c **** 
1623:../freeRTOS750/tasks.c **** 						if( xConstTickCount < xItemValue )
1624:../freeRTOS750/tasks.c **** 						{
1625:../freeRTOS750/tasks.c **** 							/* It is not time to unblock this item yet, but the item
1626:../freeRTOS750/tasks.c **** 							value is the time at which the task at the head of the
1627:../freeRTOS750/tasks.c **** 							blocked list must be removed from the Blocked state -
1628:../freeRTOS750/tasks.c **** 							so record the item value in xNextTaskUnblockTime. */
1629:../freeRTOS750/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
1630:../freeRTOS750/tasks.c **** 							break;
1631:../freeRTOS750/tasks.c **** 						}
1632:../freeRTOS750/tasks.c **** 
1633:../freeRTOS750/tasks.c **** 						/* It is time to remove the item from the Blocked state. */
1634:../freeRTOS750/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
1635:../freeRTOS750/tasks.c **** 
1636:../freeRTOS750/tasks.c **** 						/* Is the task waiting on an event also?  If so remove it
1637:../freeRTOS750/tasks.c **** 						from the event list. */
1638:../freeRTOS750/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1639:../freeRTOS750/tasks.c **** 						{
1640:../freeRTOS750/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1641:../freeRTOS750/tasks.c **** 						}
1642:../freeRTOS750/tasks.c **** 
1643:../freeRTOS750/tasks.c **** 						/* Place the unblocked task into the appropriate ready
1644:../freeRTOS750/tasks.c **** 						list. */
1645:../freeRTOS750/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
1646:../freeRTOS750/tasks.c **** 
1647:../freeRTOS750/tasks.c **** 						/* A task being unblocked cannot cause an immediate context
1648:../freeRTOS750/tasks.c **** 						switch if preemption is turned off. */
1649:../freeRTOS750/tasks.c **** 						#if (  configUSE_PREEMPTION == 1 )
1650:../freeRTOS750/tasks.c **** 						{
1651:../freeRTOS750/tasks.c **** 							/* Preemption is on, but a context switch should only
1652:../freeRTOS750/tasks.c **** 							be performed if the unblocked task has a priority that
1653:../freeRTOS750/tasks.c **** 							is equal to or higher than the currently executing
1654:../freeRTOS750/tasks.c **** 							task. */
1655:../freeRTOS750/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1656:../freeRTOS750/tasks.c **** 							{
1657:../freeRTOS750/tasks.c **** 								xSwitchRequired = pdTRUE;
1658:../freeRTOS750/tasks.c **** 							}
1659:../freeRTOS750/tasks.c **** 						}
1660:../freeRTOS750/tasks.c **** 						#endif /* configUSE_PREEMPTION */
1661:../freeRTOS750/tasks.c **** 					}
1662:../freeRTOS750/tasks.c **** 				}
1663:../freeRTOS750/tasks.c **** 			}
1664:../freeRTOS750/tasks.c **** 		}
1665:../freeRTOS750/tasks.c **** 
1666:../freeRTOS750/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
1667:../freeRTOS750/tasks.c **** 		processing time (time slice) if preemption is on, and the application
1668:../freeRTOS750/tasks.c **** 		writer has not explicitly turned time slicing off. */
1669:../freeRTOS750/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1670:../freeRTOS750/tasks.c **** 		{
1671:../freeRTOS750/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned p
1672:../freeRTOS750/tasks.c **** 			{
1673:../freeRTOS750/tasks.c **** 				xSwitchRequired = pdTRUE;
1674:../freeRTOS750/tasks.c **** 			}
1675:../freeRTOS750/tasks.c **** 		}
1676:../freeRTOS750/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1677:../freeRTOS750/tasks.c **** 	}
1678:../freeRTOS750/tasks.c **** 	else
1679:../freeRTOS750/tasks.c **** 	{
1680:../freeRTOS750/tasks.c **** 		++uxPendedTicks;
1681:../freeRTOS750/tasks.c **** 
1682:../freeRTOS750/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1683:../freeRTOS750/tasks.c **** 		scheduler is locked. */
1684:../freeRTOS750/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1685:../freeRTOS750/tasks.c **** 		{
1686:../freeRTOS750/tasks.c **** 			vApplicationTickHook();
1687:../freeRTOS750/tasks.c **** 		}
1688:../freeRTOS750/tasks.c **** 		#endif
1689:../freeRTOS750/tasks.c **** 	}
1690:../freeRTOS750/tasks.c **** 
1691:../freeRTOS750/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1692:../freeRTOS750/tasks.c **** 	{
1693:../freeRTOS750/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1694:../freeRTOS750/tasks.c **** 		count is being unwound (when the scheduler is being unlocked). */
1695:../freeRTOS750/tasks.c **** 		if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
1696:../freeRTOS750/tasks.c **** 		{
1697:../freeRTOS750/tasks.c **** 			vApplicationTickHook();
1698:../freeRTOS750/tasks.c **** 		}
1699:../freeRTOS750/tasks.c **** 	}
1700:../freeRTOS750/tasks.c **** 	#endif /* configUSE_TICK_HOOK */
1701:../freeRTOS750/tasks.c **** 
1702:../freeRTOS750/tasks.c **** 	return xSwitchRequired;
1703:../freeRTOS750/tasks.c **** }
1704:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1705:../freeRTOS750/tasks.c **** 
1706:../freeRTOS750/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1707:../freeRTOS750/tasks.c **** 
1708:../freeRTOS750/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1709:../freeRTOS750/tasks.c **** 	{
1710:../freeRTOS750/tasks.c **** 	tskTCB *xTCB;
1711:../freeRTOS750/tasks.c **** 
1712:../freeRTOS750/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1713:../freeRTOS750/tasks.c **** 		if( xTask == NULL )
1714:../freeRTOS750/tasks.c **** 		{
1715:../freeRTOS750/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1716:../freeRTOS750/tasks.c **** 		}
1717:../freeRTOS750/tasks.c **** 		else
1718:../freeRTOS750/tasks.c **** 		{
1719:../freeRTOS750/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1720:../freeRTOS750/tasks.c **** 		}
1721:../freeRTOS750/tasks.c **** 
1722:../freeRTOS750/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1723:../freeRTOS750/tasks.c **** 		the value can be accessed from an interrupt. */
1724:../freeRTOS750/tasks.c **** 		taskENTER_CRITICAL();
1725:../freeRTOS750/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1726:../freeRTOS750/tasks.c **** 		taskEXIT_CRITICAL();
1727:../freeRTOS750/tasks.c **** 	}
1728:../freeRTOS750/tasks.c **** 
1729:../freeRTOS750/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1730:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1731:../freeRTOS750/tasks.c **** 
1732:../freeRTOS750/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1733:../freeRTOS750/tasks.c **** 
1734:../freeRTOS750/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1735:../freeRTOS750/tasks.c **** 	{
1736:../freeRTOS750/tasks.c **** 	tskTCB *xTCB;
1737:../freeRTOS750/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1738:../freeRTOS750/tasks.c **** 
1739:../freeRTOS750/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1740:../freeRTOS750/tasks.c **** 		if( xTask == NULL )
1741:../freeRTOS750/tasks.c **** 		{
1742:../freeRTOS750/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1743:../freeRTOS750/tasks.c **** 		}
1744:../freeRTOS750/tasks.c **** 		else
1745:../freeRTOS750/tasks.c **** 		{
1746:../freeRTOS750/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1747:../freeRTOS750/tasks.c **** 		}
1748:../freeRTOS750/tasks.c **** 
1749:../freeRTOS750/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1750:../freeRTOS750/tasks.c **** 		the value can be accessed from an interrupt. */
1751:../freeRTOS750/tasks.c **** 		taskENTER_CRITICAL();
1752:../freeRTOS750/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1753:../freeRTOS750/tasks.c **** 		taskEXIT_CRITICAL();
1754:../freeRTOS750/tasks.c **** 
1755:../freeRTOS750/tasks.c **** 		return xReturn;
1756:../freeRTOS750/tasks.c **** 	}
1757:../freeRTOS750/tasks.c **** 
1758:../freeRTOS750/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1759:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1760:../freeRTOS750/tasks.c **** 
1761:../freeRTOS750/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1762:../freeRTOS750/tasks.c **** 
1763:../freeRTOS750/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1764:../freeRTOS750/tasks.c **** 	{
1765:../freeRTOS750/tasks.c **** 	tskTCB *xTCB;
1766:../freeRTOS750/tasks.c **** 	portBASE_TYPE xReturn;
1767:../freeRTOS750/tasks.c **** 
1768:../freeRTOS750/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1769:../freeRTOS750/tasks.c **** 		if( xTask == NULL )
1770:../freeRTOS750/tasks.c **** 		{
1771:../freeRTOS750/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1772:../freeRTOS750/tasks.c **** 		}
1773:../freeRTOS750/tasks.c **** 		else
1774:../freeRTOS750/tasks.c **** 		{
1775:../freeRTOS750/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1776:../freeRTOS750/tasks.c **** 		}
1777:../freeRTOS750/tasks.c **** 
1778:../freeRTOS750/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1779:../freeRTOS750/tasks.c **** 		{
1780:../freeRTOS750/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1781:../freeRTOS750/tasks.c **** 		}
1782:../freeRTOS750/tasks.c **** 		else
1783:../freeRTOS750/tasks.c **** 		{
1784:../freeRTOS750/tasks.c **** 			xReturn = pdFAIL;
1785:../freeRTOS750/tasks.c **** 		}
1786:../freeRTOS750/tasks.c **** 
1787:../freeRTOS750/tasks.c **** 		return xReturn;
1788:../freeRTOS750/tasks.c **** 	}
1789:../freeRTOS750/tasks.c **** 
1790:../freeRTOS750/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1791:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1792:../freeRTOS750/tasks.c **** 
1793:../freeRTOS750/tasks.c **** void vTaskSwitchContext( void )
1794:../freeRTOS750/tasks.c **** {
1795:../freeRTOS750/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1796:../freeRTOS750/tasks.c **** 	{
1797:../freeRTOS750/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1798:../freeRTOS750/tasks.c **** 		switch. */
1799:../freeRTOS750/tasks.c **** 		xYieldPending = pdTRUE;
1800:../freeRTOS750/tasks.c **** 	}
1801:../freeRTOS750/tasks.c **** 	else
1802:../freeRTOS750/tasks.c **** 	{
1803:../freeRTOS750/tasks.c **** 		traceTASK_SWITCHED_OUT();
1804:../freeRTOS750/tasks.c **** 
1805:../freeRTOS750/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1806:../freeRTOS750/tasks.c **** 		{
1807:../freeRTOS750/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1808:../freeRTOS750/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1809:../freeRTOS750/tasks.c **** 				#else
1810:../freeRTOS750/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1811:../freeRTOS750/tasks.c **** 				#endif
1812:../freeRTOS750/tasks.c **** 
1813:../freeRTOS750/tasks.c **** 				/* Add the amount of time the task has been running to the
1814:../freeRTOS750/tasks.c **** 				accumulated	time so far.  The time the task started running was
1815:../freeRTOS750/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
1816:../freeRTOS750/tasks.c **** 				protection here	so count values are only valid until the timer
1817:../freeRTOS750/tasks.c **** 				overflows.  The guard against negative values is to protect
1818:../freeRTOS750/tasks.c **** 				against suspect run time stat counter implementations - which
1819:../freeRTOS750/tasks.c **** 				are provided by the application, not the kernel. */
1820:../freeRTOS750/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
1821:../freeRTOS750/tasks.c **** 				{
1822:../freeRTOS750/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
1823:../freeRTOS750/tasks.c **** 				}
1824:../freeRTOS750/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
1825:../freeRTOS750/tasks.c **** 		}
1826:../freeRTOS750/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
1827:../freeRTOS750/tasks.c **** 
1828:../freeRTOS750/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1829:../freeRTOS750/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1830:../freeRTOS750/tasks.c **** 
1831:../freeRTOS750/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
1832:../freeRTOS750/tasks.c **** 
1833:../freeRTOS750/tasks.c **** 		traceTASK_SWITCHED_IN();
1834:../freeRTOS750/tasks.c **** 
1835:../freeRTOS750/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1836:../freeRTOS750/tasks.c **** 		{
1837:../freeRTOS750/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1838:../freeRTOS750/tasks.c **** 			structure specific to this task. */
1839:../freeRTOS750/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1840:../freeRTOS750/tasks.c **** 		}
1841:../freeRTOS750/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1842:../freeRTOS750/tasks.c **** 	}
1843:../freeRTOS750/tasks.c **** }
1844:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1845:../freeRTOS750/tasks.c **** 
1846:../freeRTOS750/tasks.c **** void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
1847:../freeRTOS750/tasks.c **** {
1848:../freeRTOS750/tasks.c **** portTickType xTimeToWake;
1849:../freeRTOS750/tasks.c **** 
1850:../freeRTOS750/tasks.c **** 	configASSERT( pxEventList );
1851:../freeRTOS750/tasks.c **** 
1852:../freeRTOS750/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1853:../freeRTOS750/tasks.c **** 	SCHEDULER SUSPENDED. */
1854:../freeRTOS750/tasks.c **** 
1855:../freeRTOS750/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1856:../freeRTOS750/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1857:../freeRTOS750/tasks.c **** 	is the first to be woken by the event. */
1858:../freeRTOS750/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1859:../freeRTOS750/tasks.c **** 
1860:../freeRTOS750/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1861:../freeRTOS750/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1862:../freeRTOS750/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1863:../freeRTOS750/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
1864:../freeRTOS750/tasks.c **** 	{
1865:../freeRTOS750/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
1866:../freeRTOS750/tasks.c **** 		check, and the port reset macro can be called directly. */
1867:../freeRTOS750/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1868:../freeRTOS750/tasks.c **** 	}
1869:../freeRTOS750/tasks.c **** 
1870:../freeRTOS750/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1871:../freeRTOS750/tasks.c **** 	{
1872:../freeRTOS750/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1873:../freeRTOS750/tasks.c **** 		{
1874:../freeRTOS750/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1875:../freeRTOS750/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1876:../freeRTOS750/tasks.c **** 			indefinitely. */
1877:../freeRTOS750/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
1878:../freeRTOS750/tasks.c **** 		}
1879:../freeRTOS750/tasks.c **** 		else
1880:../freeRTOS750/tasks.c **** 		{
1881:../freeRTOS750/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1882:../freeRTOS750/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1883:../freeRTOS750/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1884:../freeRTOS750/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1885:../freeRTOS750/tasks.c **** 		}
1886:../freeRTOS750/tasks.c **** 	}
1887:../freeRTOS750/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
1888:../freeRTOS750/tasks.c **** 	{
1889:../freeRTOS750/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1890:../freeRTOS750/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1891:../freeRTOS750/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1892:../freeRTOS750/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1893:../freeRTOS750/tasks.c **** 	}
1894:../freeRTOS750/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
1895:../freeRTOS750/tasks.c **** }
1896:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1897:../freeRTOS750/tasks.c **** 
1898:../freeRTOS750/tasks.c **** #if configUSE_TIMERS == 1
1899:../freeRTOS750/tasks.c **** 
1900:../freeRTOS750/tasks.c **** 	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
1901:../freeRTOS750/tasks.c **** 	{
1902:../freeRTOS750/tasks.c **** 	portTickType xTimeToWake;
1903:../freeRTOS750/tasks.c **** 
1904:../freeRTOS750/tasks.c **** 		configASSERT( pxEventList );
1905:../freeRTOS750/tasks.c **** 
1906:../freeRTOS750/tasks.c **** 		/* This function should not be called by application code hence the
1907:../freeRTOS750/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1908:../freeRTOS750/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1909:../freeRTOS750/tasks.c **** 		it should be called from a critical section. */
1910:../freeRTOS750/tasks.c **** 
1911:../freeRTOS750/tasks.c **** 
1912:../freeRTOS750/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1913:../freeRTOS750/tasks.c **** 		In this case it is assume that this is the only task that is going to
1914:../freeRTOS750/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1915:../freeRTOS750/tasks.c **** 		can be used in place of vListInsert. */
1916:../freeRTOS750/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1917:../freeRTOS750/tasks.c **** 
1918:../freeRTOS750/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1919:../freeRTOS750/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1920:../freeRTOS750/tasks.c **** 		function is called form a critical section. */
1921:../freeRTOS750/tasks.c **** 		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
1922:../freeRTOS750/tasks.c **** 		{
1923:../freeRTOS750/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
1924:../freeRTOS750/tasks.c **** 			check, and the port reset macro can be called directly. */
1925:../freeRTOS750/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1926:../freeRTOS750/tasks.c **** 		}
1927:../freeRTOS750/tasks.c **** 
1928:../freeRTOS750/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1929:../freeRTOS750/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1930:../freeRTOS750/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1931:../freeRTOS750/tasks.c **** 
1932:../freeRTOS750/tasks.c **** 		traceTASK_DELAY_UNTIL();
1933:../freeRTOS750/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1934:../freeRTOS750/tasks.c **** 	}
1935:../freeRTOS750/tasks.c **** 
1936:../freeRTOS750/tasks.c **** #endif /* configUSE_TIMERS */
1937:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1938:../freeRTOS750/tasks.c **** 
1939:../freeRTOS750/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1940:../freeRTOS750/tasks.c **** {
1941:../freeRTOS750/tasks.c **** tskTCB *pxUnblockedTCB;
1942:../freeRTOS750/tasks.c **** portBASE_TYPE xReturn;
1943:../freeRTOS750/tasks.c **** 
1944:../freeRTOS750/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1945:../freeRTOS750/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1946:../freeRTOS750/tasks.c **** 
1947:../freeRTOS750/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1948:../freeRTOS750/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1949:../freeRTOS750/tasks.c **** 	it to the ready list.
1950:../freeRTOS750/tasks.c **** 
1951:../freeRTOS750/tasks.c **** 	If an event is for a queue that is locked then this function will never
1952:../freeRTOS750/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1953:../freeRTOS750/tasks.c **** 	means we can always expect exclusive access to the event list here.
1954:../freeRTOS750/tasks.c **** 
1955:../freeRTOS750/tasks.c **** 	This function assumes that a check has already been made to ensure that
1956:../freeRTOS750/tasks.c **** 	pxEventList is not empty. */
1957:../freeRTOS750/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1958:../freeRTOS750/tasks.c **** 	configASSERT( pxUnblockedTCB );
1959:../freeRTOS750/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
1960:../freeRTOS750/tasks.c **** 
1961:../freeRTOS750/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1962:../freeRTOS750/tasks.c **** 	{
1963:../freeRTOS750/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1964:../freeRTOS750/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
1965:../freeRTOS750/tasks.c **** 	}
1966:../freeRTOS750/tasks.c **** 	else
1967:../freeRTOS750/tasks.c **** 	{
1968:../freeRTOS750/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1969:../freeRTOS750/tasks.c **** 		task pending until the scheduler is resumed. */
1970:../freeRTOS750/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1971:../freeRTOS750/tasks.c **** 	}
1972:../freeRTOS750/tasks.c **** 
1973:../freeRTOS750/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1974:../freeRTOS750/tasks.c **** 	{
1975:../freeRTOS750/tasks.c **** 		/* Return true if the task removed from the event list has
1976:../freeRTOS750/tasks.c **** 		a higher priority than the calling task.  This allows
1977:../freeRTOS750/tasks.c **** 		the calling task to know if it should force a context
1978:../freeRTOS750/tasks.c **** 		switch now. */
1979:../freeRTOS750/tasks.c **** 		xReturn = pdTRUE;
1980:../freeRTOS750/tasks.c **** 	}
1981:../freeRTOS750/tasks.c **** 	else
1982:../freeRTOS750/tasks.c **** 	{
1983:../freeRTOS750/tasks.c **** 		xReturn = pdFALSE;
1984:../freeRTOS750/tasks.c **** 	}
1985:../freeRTOS750/tasks.c **** 
1986:../freeRTOS750/tasks.c **** 	return xReturn;
1987:../freeRTOS750/tasks.c **** }
1988:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1989:../freeRTOS750/tasks.c **** 
1990:../freeRTOS750/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1991:../freeRTOS750/tasks.c **** {
1992:../freeRTOS750/tasks.c **** 	configASSERT( pxTimeOut );
1993:../freeRTOS750/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
1994:../freeRTOS750/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
1995:../freeRTOS750/tasks.c **** }
1996:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
1997:../freeRTOS750/tasks.c **** 
1998:../freeRTOS750/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1999:../freeRTOS750/tasks.c **** {
2000:../freeRTOS750/tasks.c **** portBASE_TYPE xReturn;
2001:../freeRTOS750/tasks.c **** 
2002:../freeRTOS750/tasks.c **** 	configASSERT( pxTimeOut );
2003:../freeRTOS750/tasks.c **** 	configASSERT( pxTicksToWait );
2004:../freeRTOS750/tasks.c **** 
2005:../freeRTOS750/tasks.c **** 	taskENTER_CRITICAL();
2006:../freeRTOS750/tasks.c **** 	{
2007:../freeRTOS750/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2008:../freeRTOS750/tasks.c **** 		const portTickType xConstTickCount = xTickCount;
2009:../freeRTOS750/tasks.c **** 
2010:../freeRTOS750/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2011:../freeRTOS750/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2012:../freeRTOS750/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2013:../freeRTOS750/tasks.c **** 			therefore never time out. */
2014:../freeRTOS750/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
2015:../freeRTOS750/tasks.c **** 			{
2016:../freeRTOS750/tasks.c **** 				xReturn = pdFALSE;
2017:../freeRTOS750/tasks.c **** 			}
2018:../freeRTOS750/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2019:../freeRTOS750/tasks.c **** 		#endif
2020:../freeRTOS750/tasks.c **** 
2021:../freeRTOS750/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
2022:../freeRTOS750/tasks.c **** 		{
2023:../freeRTOS750/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2024:../freeRTOS750/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2025:../freeRTOS750/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2026:../freeRTOS750/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2027:../freeRTOS750/tasks.c **** 			xReturn = pdTRUE;
2028:../freeRTOS750/tasks.c **** 		}
2029:../freeRTOS750/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
2030:../freeRTOS750/tasks.c **** 		{
2031:../freeRTOS750/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2032:../freeRTOS750/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
2033:../freeRTOS750/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
2034:../freeRTOS750/tasks.c **** 			xReturn = pdFALSE;
2035:../freeRTOS750/tasks.c **** 		}
2036:../freeRTOS750/tasks.c **** 		else
2037:../freeRTOS750/tasks.c **** 		{
2038:../freeRTOS750/tasks.c **** 			xReturn = pdTRUE;
2039:../freeRTOS750/tasks.c **** 		}
2040:../freeRTOS750/tasks.c **** 	}
2041:../freeRTOS750/tasks.c **** 	taskEXIT_CRITICAL();
2042:../freeRTOS750/tasks.c **** 
2043:../freeRTOS750/tasks.c **** 	return xReturn;
2044:../freeRTOS750/tasks.c **** }
2045:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2046:../freeRTOS750/tasks.c **** 
2047:../freeRTOS750/tasks.c **** void vTaskMissedYield( void )
2048:../freeRTOS750/tasks.c **** {
2049:../freeRTOS750/tasks.c **** 	xYieldPending = pdTRUE;
2050:../freeRTOS750/tasks.c **** }
2051:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2052:../freeRTOS750/tasks.c **** 
2053:../freeRTOS750/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2054:../freeRTOS750/tasks.c **** 
2055:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
2056:../freeRTOS750/tasks.c **** 	{
2057:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2058:../freeRTOS750/tasks.c **** 	tskTCB *pxTCB;
2059:../freeRTOS750/tasks.c **** 
2060:../freeRTOS750/tasks.c **** 		if( xTask != NULL )
2061:../freeRTOS750/tasks.c **** 		{
2062:../freeRTOS750/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2063:../freeRTOS750/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2064:../freeRTOS750/tasks.c **** 		}
2065:../freeRTOS750/tasks.c **** 		else
2066:../freeRTOS750/tasks.c **** 		{
2067:../freeRTOS750/tasks.c **** 			uxReturn = 0U;
2068:../freeRTOS750/tasks.c **** 		}
2069:../freeRTOS750/tasks.c **** 
2070:../freeRTOS750/tasks.c **** 		return uxReturn;
2071:../freeRTOS750/tasks.c **** 	}
2072:../freeRTOS750/tasks.c **** 
2073:../freeRTOS750/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2074:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2075:../freeRTOS750/tasks.c **** 
2076:../freeRTOS750/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2077:../freeRTOS750/tasks.c **** 
2078:../freeRTOS750/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
2079:../freeRTOS750/tasks.c **** 	{
2080:../freeRTOS750/tasks.c **** 	tskTCB *pxTCB;
2081:../freeRTOS750/tasks.c **** 
2082:../freeRTOS750/tasks.c **** 		if( xTask != NULL )
2083:../freeRTOS750/tasks.c **** 		{
2084:../freeRTOS750/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2085:../freeRTOS750/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2086:../freeRTOS750/tasks.c **** 		}
2087:../freeRTOS750/tasks.c **** 	}
2088:../freeRTOS750/tasks.c **** 
2089:../freeRTOS750/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2090:../freeRTOS750/tasks.c **** 
2091:../freeRTOS750/tasks.c **** /*
2092:../freeRTOS750/tasks.c ****  * -----------------------------------------------------------
2093:../freeRTOS750/tasks.c ****  * The Idle task.
2094:../freeRTOS750/tasks.c ****  * ----------------------------------------------------------
2095:../freeRTOS750/tasks.c ****  *
2096:../freeRTOS750/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2097:../freeRTOS750/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2098:../freeRTOS750/tasks.c ****  *
2099:../freeRTOS750/tasks.c ****  * void prvIdleTask( void *pvParameters );
2100:../freeRTOS750/tasks.c ****  *
2101:../freeRTOS750/tasks.c ****  */
2102:../freeRTOS750/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2103:../freeRTOS750/tasks.c **** {
2104:../freeRTOS750/tasks.c **** 	/* Stop warnings. */
2105:../freeRTOS750/tasks.c **** 	( void ) pvParameters;
2106:../freeRTOS750/tasks.c **** 
2107:../freeRTOS750/tasks.c **** 	for( ;; )
2108:../freeRTOS750/tasks.c **** 	{
2109:../freeRTOS750/tasks.c **** 		/* See if any tasks have been deleted. */
2110:../freeRTOS750/tasks.c **** 		prvCheckTasksWaitingTermination();
2111:../freeRTOS750/tasks.c **** 
2112:../freeRTOS750/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2113:../freeRTOS750/tasks.c **** 		{
2114:../freeRTOS750/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2115:../freeRTOS750/tasks.c **** 			see if any other task has become available.  If we are using
2116:../freeRTOS750/tasks.c **** 			preemption we don't need to do this as any task becoming available
2117:../freeRTOS750/tasks.c **** 			will automatically get the processor anyway. */
2118:../freeRTOS750/tasks.c **** 			taskYIELD();
2119:../freeRTOS750/tasks.c **** 		}
2120:../freeRTOS750/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2121:../freeRTOS750/tasks.c **** 
2122:../freeRTOS750/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2123:../freeRTOS750/tasks.c **** 		{
2124:../freeRTOS750/tasks.c **** 			/* When using preemption tasks of equal priority will be
2125:../freeRTOS750/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2126:../freeRTOS750/tasks.c **** 			to run then the idle task should yield before the end of the
2127:../freeRTOS750/tasks.c **** 			timeslice.
2128:../freeRTOS750/tasks.c **** 
2129:../freeRTOS750/tasks.c **** 			A critical region is not required here as we are just reading from
2130:../freeRTOS750/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2131:../freeRTOS750/tasks.c **** 			the ready list at the idle priority contains more than one task
2132:../freeRTOS750/tasks.c **** 			then a task other than the idle task is ready to execute. */
2133:../freeRTOS750/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
2134:../freeRTOS750/tasks.c **** 			{
2135:../freeRTOS750/tasks.c **** 				taskYIELD();
2136:../freeRTOS750/tasks.c **** 			}
2137:../freeRTOS750/tasks.c **** 		}
2138:../freeRTOS750/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2139:../freeRTOS750/tasks.c **** 
2140:../freeRTOS750/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2141:../freeRTOS750/tasks.c **** 		{
2142:../freeRTOS750/tasks.c **** 			extern void vApplicationIdleHook( void );
2143:../freeRTOS750/tasks.c **** 
2144:../freeRTOS750/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2145:../freeRTOS750/tasks.c **** 			allows the application designer to add background functionality
2146:../freeRTOS750/tasks.c **** 			without the overhead of a separate task.
2147:../freeRTOS750/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2148:../freeRTOS750/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2149:../freeRTOS750/tasks.c **** 			vApplicationIdleHook();
2150:../freeRTOS750/tasks.c **** 		}
2151:../freeRTOS750/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2152:../freeRTOS750/tasks.c **** 
2153:../freeRTOS750/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2154:../freeRTOS750/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2155:../freeRTOS750/tasks.c **** 		user defined low power mode	implementations require
2156:../freeRTOS750/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2157:../freeRTOS750/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2158:../freeRTOS750/tasks.c **** 		{
2159:../freeRTOS750/tasks.c **** 		portTickType xExpectedIdleTime;
2160:../freeRTOS750/tasks.c **** 
2161:../freeRTOS750/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2162:../freeRTOS750/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2163:../freeRTOS750/tasks.c **** 			test of the expected idle time is performed without the
2164:../freeRTOS750/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2165:../freeRTOS750/tasks.c **** 			valid. */
2166:../freeRTOS750/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2167:../freeRTOS750/tasks.c **** 
2168:../freeRTOS750/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2169:../freeRTOS750/tasks.c **** 			{
2170:../freeRTOS750/tasks.c **** 				vTaskSuspendAll();
2171:../freeRTOS750/tasks.c **** 				{
2172:../freeRTOS750/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2173:../freeRTOS750/tasks.c **** 					time can be sampled again, and this time its value can
2174:../freeRTOS750/tasks.c **** 					be used. */
2175:../freeRTOS750/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2176:../freeRTOS750/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2177:../freeRTOS750/tasks.c **** 
2178:../freeRTOS750/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2179:../freeRTOS750/tasks.c **** 					{
2180:../freeRTOS750/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
2181:../freeRTOS750/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2182:../freeRTOS750/tasks.c **** 						traceLOW_POWER_IDLE_END();
2183:../freeRTOS750/tasks.c **** 					}
2184:../freeRTOS750/tasks.c **** 				}
2185:../freeRTOS750/tasks.c **** 				xTaskResumeAll();
2186:../freeRTOS750/tasks.c **** 			}
2187:../freeRTOS750/tasks.c **** 		}
2188:../freeRTOS750/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2189:../freeRTOS750/tasks.c **** 	}
2190:../freeRTOS750/tasks.c **** }
2191:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2192:../freeRTOS750/tasks.c **** 
2193:../freeRTOS750/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2194:../freeRTOS750/tasks.c **** 
2195:../freeRTOS750/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2196:../freeRTOS750/tasks.c **** 	{
2197:../freeRTOS750/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2198:../freeRTOS750/tasks.c **** 
2199:../freeRTOS750/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2200:../freeRTOS750/tasks.c **** 		{
2201:../freeRTOS750/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2202:../freeRTOS750/tasks.c **** 			eReturn = eAbortSleep;
2203:../freeRTOS750/tasks.c **** 		}
2204:../freeRTOS750/tasks.c **** 		else if( xYieldPending != pdFALSE )
2205:../freeRTOS750/tasks.c **** 		{
2206:../freeRTOS750/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2207:../freeRTOS750/tasks.c **** 			eReturn = eAbortSleep;
2208:../freeRTOS750/tasks.c **** 		}
2209:../freeRTOS750/tasks.c **** 		else
2210:../freeRTOS750/tasks.c **** 		{
2211:../freeRTOS750/tasks.c **** 			#if configUSE_TIMERS == 0
2212:../freeRTOS750/tasks.c **** 			{
2213:../freeRTOS750/tasks.c **** 				/* The idle task exists in addition to the application tasks. */
2214:../freeRTOS750/tasks.c **** 				const unsigned portBASE_TYPE uxNonApplicationTasks = 1;
2215:../freeRTOS750/tasks.c **** 
2216:../freeRTOS750/tasks.c **** 				/* If timers are not being used and all the tasks are in the
2217:../freeRTOS750/tasks.c **** 				suspended list (which might mean they have an infinite block
2218:../freeRTOS750/tasks.c **** 				time rather than actually being suspended) then it is safe to
2219:../freeRTOS750/tasks.c **** 				turn all clocks off and just wait for external interrupts. */
2220:../freeRTOS750/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicati
2221:../freeRTOS750/tasks.c **** 				{
2222:../freeRTOS750/tasks.c **** 					eReturn = eNoTasksWaitingTimeout;
2223:../freeRTOS750/tasks.c **** 				}
2224:../freeRTOS750/tasks.c **** 			}
2225:../freeRTOS750/tasks.c **** 			#endif /* configUSE_TIMERS */
2226:../freeRTOS750/tasks.c **** 		}
2227:../freeRTOS750/tasks.c **** 
2228:../freeRTOS750/tasks.c **** 		return eReturn;
2229:../freeRTOS750/tasks.c **** 	}
2230:../freeRTOS750/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2231:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2232:../freeRTOS750/tasks.c **** 
2233:../freeRTOS750/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
2234:../freeRTOS750/tasks.c **** {
2235:../freeRTOS750/tasks.c **** unsigned portBASE_TYPE x;
2236:../freeRTOS750/tasks.c **** 
2237:../freeRTOS750/tasks.c **** 	/* Store the task name in the TCB. */
2238:../freeRTOS750/tasks.c **** 	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++
2239:../freeRTOS750/tasks.c **** 	{
2240:../freeRTOS750/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
2241:../freeRTOS750/tasks.c **** 
2242:../freeRTOS750/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2243:../freeRTOS750/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
2244:../freeRTOS750/tasks.c **** 		string is not accessible (extremely unlikely). */
2245:../freeRTOS750/tasks.c **** 		if( pcName[ x ] == 0x00 )
2246:../freeRTOS750/tasks.c **** 		{
2247:../freeRTOS750/tasks.c **** 			break;
2248:../freeRTOS750/tasks.c **** 		}
2249:../freeRTOS750/tasks.c **** 	}
2250:../freeRTOS750/tasks.c **** 
2251:../freeRTOS750/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
2252:../freeRTOS750/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
2253:../freeRTOS750/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
2254:../freeRTOS750/tasks.c **** 
2255:../freeRTOS750/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2256:../freeRTOS750/tasks.c **** 	remove the privilege bit if one is present. */
2257:../freeRTOS750/tasks.c **** 	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
2258:../freeRTOS750/tasks.c **** 	{
2259:../freeRTOS750/tasks.c **** 		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
2260:../freeRTOS750/tasks.c **** 	}
2261:../freeRTOS750/tasks.c **** 
2262:../freeRTOS750/tasks.c **** 	pxTCB->uxPriority = uxPriority;
2263:../freeRTOS750/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2264:../freeRTOS750/tasks.c **** 	{
2265:../freeRTOS750/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
2266:../freeRTOS750/tasks.c **** 	}
2267:../freeRTOS750/tasks.c **** 	#endif /* configUSE_MUTEXES */
2268:../freeRTOS750/tasks.c **** 
2269:../freeRTOS750/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
2270:../freeRTOS750/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
2271:../freeRTOS750/tasks.c **** 
2272:../freeRTOS750/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2273:../freeRTOS750/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2274:../freeRTOS750/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
2275:../freeRTOS750/tasks.c **** 
2276:../freeRTOS750/tasks.c **** 	/* Event lists are always in priority order. */
2277:../freeRTOS750/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( por
2278:../freeRTOS750/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
2279:../freeRTOS750/tasks.c **** 
2280:../freeRTOS750/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2281:../freeRTOS750/tasks.c **** 	{
2282:../freeRTOS750/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2283:../freeRTOS750/tasks.c **** 	}
2284:../freeRTOS750/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2285:../freeRTOS750/tasks.c **** 
2286:../freeRTOS750/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2287:../freeRTOS750/tasks.c **** 	{
2288:../freeRTOS750/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2289:../freeRTOS750/tasks.c **** 	}
2290:../freeRTOS750/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2291:../freeRTOS750/tasks.c **** 
2292:../freeRTOS750/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2293:../freeRTOS750/tasks.c **** 	{
2294:../freeRTOS750/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2295:../freeRTOS750/tasks.c **** 	}
2296:../freeRTOS750/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2297:../freeRTOS750/tasks.c **** 
2298:../freeRTOS750/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2299:../freeRTOS750/tasks.c **** 	{
2300:../freeRTOS750/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2301:../freeRTOS750/tasks.c **** 	}
2302:../freeRTOS750/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2303:../freeRTOS750/tasks.c **** 	{
2304:../freeRTOS750/tasks.c **** 		( void ) xRegions;
2305:../freeRTOS750/tasks.c **** 		( void ) usStackDepth;
2306:../freeRTOS750/tasks.c **** 	}
2307:../freeRTOS750/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2308:../freeRTOS750/tasks.c **** 
2309:../freeRTOS750/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2310:../freeRTOS750/tasks.c **** 	{
2311:../freeRTOS750/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
2312:../freeRTOS750/tasks.c **** 		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2313:../freeRTOS750/tasks.c **** 	}
2314:../freeRTOS750/tasks.c **** 	#endif /* configUSE_NEWLIB_REENTRANT */
2315:../freeRTOS750/tasks.c **** }
2316:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2317:../freeRTOS750/tasks.c **** 
2318:../freeRTOS750/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2319:../freeRTOS750/tasks.c **** 
2320:../freeRTOS750/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2321:../freeRTOS750/tasks.c **** 	{
2322:../freeRTOS750/tasks.c **** 	tskTCB *pxTCB;
2323:../freeRTOS750/tasks.c **** 
2324:../freeRTOS750/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2325:../freeRTOS750/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2326:../freeRTOS750/tasks.c **** 
2327:../freeRTOS750/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2328:../freeRTOS750/tasks.c **** 	}
2329:../freeRTOS750/tasks.c **** 
2330:../freeRTOS750/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2331:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2332:../freeRTOS750/tasks.c **** 
2333:../freeRTOS750/tasks.c **** static void prvInitialiseTaskLists( void )
2334:../freeRTOS750/tasks.c **** {
2335:../freeRTOS750/tasks.c **** unsigned portBASE_TYPE uxPriority;
2336:../freeRTOS750/tasks.c **** 
2337:../freeRTOS750/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX
2338:../freeRTOS750/tasks.c **** 	{
2339:../freeRTOS750/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
2340:../freeRTOS750/tasks.c **** 	}
2341:../freeRTOS750/tasks.c **** 
2342:../freeRTOS750/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
2343:../freeRTOS750/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
2344:../freeRTOS750/tasks.c **** 	vListInitialise( &xPendingReadyList );
2345:../freeRTOS750/tasks.c **** 
2346:../freeRTOS750/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2347:../freeRTOS750/tasks.c **** 	{
2348:../freeRTOS750/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
2349:../freeRTOS750/tasks.c **** 	}
2350:../freeRTOS750/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
2351:../freeRTOS750/tasks.c **** 
2352:../freeRTOS750/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2353:../freeRTOS750/tasks.c **** 	{
2354:../freeRTOS750/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
2355:../freeRTOS750/tasks.c **** 	}
2356:../freeRTOS750/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2357:../freeRTOS750/tasks.c **** 
2358:../freeRTOS750/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2359:../freeRTOS750/tasks.c **** 	using list2. */
2360:../freeRTOS750/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
2361:../freeRTOS750/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
2362:../freeRTOS750/tasks.c **** }
2363:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2364:../freeRTOS750/tasks.c **** 
2365:../freeRTOS750/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2366:../freeRTOS750/tasks.c **** {
2367:../freeRTOS750/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2368:../freeRTOS750/tasks.c **** 	{
2369:../freeRTOS750/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2370:../freeRTOS750/tasks.c **** 
2371:../freeRTOS750/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2372:../freeRTOS750/tasks.c **** 		too often in the idle task. */
2373:../freeRTOS750/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2374:../freeRTOS750/tasks.c **** 		{
2375:../freeRTOS750/tasks.c **** 			vTaskSuspendAll();
2376:../freeRTOS750/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2377:../freeRTOS750/tasks.c **** 			( void ) xTaskResumeAll();
2378:../freeRTOS750/tasks.c **** 
2379:../freeRTOS750/tasks.c **** 			if( xListIsEmpty == pdFALSE )
2380:../freeRTOS750/tasks.c **** 			{
2381:../freeRTOS750/tasks.c **** 				tskTCB *pxTCB;
2382:../freeRTOS750/tasks.c **** 
2383:../freeRTOS750/tasks.c **** 				taskENTER_CRITICAL();
2384:../freeRTOS750/tasks.c **** 				{
2385:../freeRTOS750/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
2386:../freeRTOS750/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
2387:../freeRTOS750/tasks.c **** 					--uxCurrentNumberOfTasks;
2388:../freeRTOS750/tasks.c **** 					--uxTasksDeleted;
2389:../freeRTOS750/tasks.c **** 				}
2390:../freeRTOS750/tasks.c **** 				taskEXIT_CRITICAL();
2391:../freeRTOS750/tasks.c **** 
2392:../freeRTOS750/tasks.c **** 				prvDeleteTCB( pxTCB );
2393:../freeRTOS750/tasks.c **** 			}
2394:../freeRTOS750/tasks.c **** 		}
2395:../freeRTOS750/tasks.c **** 	}
2396:../freeRTOS750/tasks.c **** 	#endif /* vTaskDelete */
2397:../freeRTOS750/tasks.c **** }
2398:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2399:../freeRTOS750/tasks.c **** 
2400:../freeRTOS750/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2401:../freeRTOS750/tasks.c **** {
 130               	.LM0:
 131               	.LFBB1:
 132 0000 CF93      		push r28
 133 0002 DF93      		push r29
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 2 */
 137               	.L__stack_usage = 2
 138 0004 EC01      		movw r28,r24
2402:../freeRTOS750/tasks.c **** 	/* The list item will be inserted in wake time order. */
2403:../freeRTOS750/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 140               	.LM1:
 141 0006 E091 0000 		lds r30,pxCurrentTCB
 142 000a F091 0000 		lds r31,pxCurrentTCB+1
 143 000e 9383      		std Z+3,r25
 144 0010 8283      		std Z+2,r24
2404:../freeRTOS750/tasks.c **** 
2405:../freeRTOS750/tasks.c **** 	if( xTimeToWake < xTickCount )
 146               	.LM2:
 147 0012 8091 0000 		lds r24,xTickCount
 148 0016 9091 0000 		lds r25,xTickCount+1
 149               	.LBB4:
 150               	.LBB5:
2406:../freeRTOS750/tasks.c **** 	{
2407:../freeRTOS750/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2408:../freeRTOS750/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 152               	.LM3:
 153 001a 6091 0000 		lds r22,pxCurrentTCB
 154 001e 7091 0000 		lds r23,pxCurrentTCB+1
 155               	.LBE5:
 156               	.LBE4:
2405:../freeRTOS750/tasks.c **** 	if( xTimeToWake < xTickCount )
 158               	.LM4:
 159 0022 C817      		cp r28,r24
 160 0024 D907      		cpc r29,r25
 161 0026 00F4      		brsh .L2
 162               	.LBB8:
 163               	.LBB6:
 165               	.LM5:
 166 0028 8091 0000 		lds r24,pxOverflowDelayedTaskList
 167 002c 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 168 0030 6E5F      		subi r22,-2
 169 0032 7F4F      		sbci r23,-1
 170               	/* epilogue start */
 171               	.LBE6:
 172               	.LBE8:
2409:../freeRTOS750/tasks.c **** 	}
2410:../freeRTOS750/tasks.c **** 	else
2411:../freeRTOS750/tasks.c **** 	{
2412:../freeRTOS750/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2413:../freeRTOS750/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2414:../freeRTOS750/tasks.c **** 
2415:../freeRTOS750/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2416:../freeRTOS750/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2417:../freeRTOS750/tasks.c **** 		too. */
2418:../freeRTOS750/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
2419:../freeRTOS750/tasks.c **** 		{
2420:../freeRTOS750/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
2421:../freeRTOS750/tasks.c **** 		}
2422:../freeRTOS750/tasks.c **** 	}
2423:../freeRTOS750/tasks.c **** }
 174               	.LM6:
 175 0034 DF91      		pop r29
 176 0036 CF91      		pop r28
 177               	.LBB9:
 178               	.LBB7:
2408:../freeRTOS750/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 180               	.LM7:
 181 0038 0C94 0000 		jmp vListInsert
 182               	.L2:
 183               	.LBE7:
 184               	.LBE9:
2413:../freeRTOS750/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 186               	.LM8:
 187 003c 8091 0000 		lds r24,pxDelayedTaskList
 188 0040 9091 0000 		lds r25,pxDelayedTaskList+1
 189 0044 6E5F      		subi r22,-2
 190 0046 7F4F      		sbci r23,-1
 191 0048 0E94 0000 		call vListInsert
2418:../freeRTOS750/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 193               	.LM9:
 194 004c 8091 0000 		lds r24,xNextTaskUnblockTime
 195 0050 9091 0000 		lds r25,xNextTaskUnblockTime+1
 196 0054 C817      		cp r28,r24
 197 0056 D907      		cpc r29,r25
 198 0058 00F4      		brsh .L1
2420:../freeRTOS750/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 200               	.LM10:
 201 005a D093 0000 		sts xNextTaskUnblockTime+1,r29
 202 005e C093 0000 		sts xNextTaskUnblockTime,r28
 203               	.L1:
 204               	/* epilogue start */
 206               	.LM11:
 207 0062 DF91      		pop r29
 208 0064 CF91      		pop r28
 209 0066 0895      		ret
 211               	.Lscope1:
 213               		.stabd	78,0,0
 222               	.global	xTaskGenericCreate
 224               	xTaskGenericCreate:
 225               		.stabd	46,0,0
 479:../freeRTOS750/tasks.c **** {
 227               	.LM12:
 228               	.LFBB2:
 229 0068 3F92      		push r3
 230 006a 4F92      		push r4
 231 006c 5F92      		push r5
 232 006e 6F92      		push r6
 233 0070 7F92      		push r7
 234 0072 8F92      		push r8
 235 0074 9F92      		push r9
 236 0076 AF92      		push r10
 237 0078 BF92      		push r11
 238 007a CF92      		push r12
 239 007c DF92      		push r13
 240 007e EF92      		push r14
 241 0080 FF92      		push r15
 242 0082 0F93      		push r16
 243 0084 1F93      		push r17
 244 0086 CF93      		push r28
 245 0088 DF93      		push r29
 246               	/* prologue: function */
 247               	/* frame size = 0 */
 248               	/* stack size = 17 */
 249               	.L__stack_usage = 17
 250 008a 4C01      		movw r8,r24
 251 008c 162F      		mov r17,r22
 252 008e 372E      		mov r3,r23
 253 0090 5A01      		movw r10,r20
 254 0092 3901      		movw r6,r18
 255               	.LBB17:
 256               	.LBB18:
2424:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2425:../freeRTOS750/tasks.c **** 
2426:../freeRTOS750/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2427:../freeRTOS750/tasks.c **** {
2428:../freeRTOS750/tasks.c **** tskTCB *pxNewTCB;
2429:../freeRTOS750/tasks.c **** 
2430:../freeRTOS750/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2431:../freeRTOS750/tasks.c **** 	the implementation of the port malloc function. */
2432:../freeRTOS750/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 258               	.LM13:
 259 0094 81E2      		ldi r24,lo8(33)
 260 0096 90E0      		ldi r25,0
 261 0098 0E94 0000 		call pvPortMalloc
 262 009c EC01      		movw r28,r24
2433:../freeRTOS750/tasks.c **** 
2434:../freeRTOS750/tasks.c **** 	if( pxNewTCB != NULL )
 264               	.LM14:
 265 009e 0097      		sbiw r24,0
 266 00a0 01F4      		brne .+2
 267 00a2 00C0      		rjmp .L5
2435:../freeRTOS750/tasks.c **** 	{
2436:../freeRTOS750/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2437:../freeRTOS750/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2438:../freeRTOS750/tasks.c **** 		be deleted later if required. */
2439:../freeRTOS750/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * siz
 269               	.LM15:
 270 00a4 C114      		cp r12,__zero_reg__
 271 00a6 D104      		cpc r13,__zero_reg__
 272 00a8 01F4      		brne .L6
 273 00aa C501      		movw r24,r10
 274 00ac 0E94 0000 		call pvPortMalloc
 275 00b0 6C01      		movw r12,r24
 276               	.L6:
 277 00b2 D88E      		std Y+24,r13
 278 00b4 CF8A      		std Y+23,r12
2440:../freeRTOS750/tasks.c **** 
2441:../freeRTOS750/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 280               	.LM16:
 281 00b6 C114      		cp r12,__zero_reg__
 282 00b8 D104      		cpc r13,__zero_reg__
 283 00ba 01F4      		brne .L7
2442:../freeRTOS750/tasks.c **** 		{
2443:../freeRTOS750/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2444:../freeRTOS750/tasks.c **** 			vPortFree( pxNewTCB );
 285               	.LM17:
 286 00bc CE01      		movw r24,r28
 287 00be 0E94 0000 		call vPortFree
 288 00c2 00C0      		rjmp .L5
 289               	.L7:
2445:../freeRTOS750/tasks.c **** 			pxNewTCB = NULL;
2446:../freeRTOS750/tasks.c **** 		}
2447:../freeRTOS750/tasks.c **** 		else
2448:../freeRTOS750/tasks.c **** 		{
2449:../freeRTOS750/tasks.c **** 			/* Just to help debugging. */
2450:../freeRTOS750/tasks.c **** 			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof
 291               	.LM18:
 292 00c4 A501      		movw r20,r10
 293 00c6 65EA      		ldi r22,lo8(-91)
 294 00c8 70E0      		ldi r23,0
 295 00ca C601      		movw r24,r12
 296 00cc 0E94 0000 		call memset
 297               	.LBE18:
 298               	.LBE17:
 299               	.LBB19:
 514:../freeRTOS750/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 301               	.LM19:
 302 00d0 21E0      		ldi r18,1
 303 00d2 A21A      		sub r10,r18
 304 00d4 B108      		sbc r11,__zero_reg__
 305 00d6 4F88      		ldd r4,Y+23
 306 00d8 588C      		ldd r5,Y+24
 307 00da 4A0C      		add r4,r10
 308 00dc 5B1C      		adc r5,r11
 309 00de E12F      		mov r30,r17
 310 00e0 F32D      		mov r31,r3
 311 00e2 80E0      		ldi r24,0
 312 00e4 90E0      		ldi r25,0
 313               	.L9:
 478:../freeRTOS750/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 315               	.LM20:
 316 00e6 BF01      		movw r22,r30
 317               	.LBB20:
 318               	.LBB21:
2240:../freeRTOS750/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 320               	.LM21:
 321 00e8 4191      		ld r20,Z+
 478:../freeRTOS750/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 323               	.LM22:
 324 00ea 9E01      		movw r18,r28
 325 00ec 280F      		add r18,r24
 326 00ee 391F      		adc r19,r25
2240:../freeRTOS750/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 328               	.LM23:
 329 00f0 D901      		movw r26,r18
 330 00f2 5996      		adiw r26,25
 331 00f4 4C93      		st X,r20
2245:../freeRTOS750/tasks.c **** 		if( pcName[ x ] == 0x00 )
 333               	.LM24:
 334 00f6 DB01      		movw r26,r22
 335 00f8 2C91      		ld r18,X
 336 00fa 2223      		tst r18
 337 00fc 01F0      		breq .L8
 338 00fe 0196      		adiw r24,1
2238:../freeRTOS750/tasks.c **** 	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++
 340               	.LM25:
 341 0100 8830      		cpi r24,8
 342 0102 9105      		cpc r25,__zero_reg__
 343 0104 01F4      		brne .L9
 344               	.L8:
2253:../freeRTOS750/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
 346               	.LM26:
 347 0106 18A2      		std Y+32,__zero_reg__
 348 0108 102F      		mov r17,r16
 349 010a 0430      		cpi r16,lo8(4)
 350 010c 00F0      		brlo .L10
 351 010e 13E0      		ldi r17,lo8(3)
 352               	.L10:
2262:../freeRTOS750/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 354               	.LM27:
 355 0110 1E8B      		std Y+22,r17
2269:../freeRTOS750/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 357               	.LM28:
 358 0112 6E01      		movw r12,r28
 359 0114 B2E0      		ldi r27,2
 360 0116 CB0E      		add r12,r27
 361 0118 D11C      		adc r13,__zero_reg__
 362 011a C601      		movw r24,r12
 363 011c 0E94 0000 		call vListInitialiseItem
2270:../freeRTOS750/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 365               	.LM29:
 366 0120 CE01      		movw r24,r28
 367 0122 0C96      		adiw r24,12
 368 0124 0E94 0000 		call vListInitialiseItem
2274:../freeRTOS750/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 370               	.LM30:
 371 0128 D987      		std Y+9,r29
 372 012a C887      		std Y+8,r28
2277:../freeRTOS750/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( por
 374               	.LM31:
 375 012c 84E0      		ldi r24,lo8(4)
 376 012e 90E0      		ldi r25,0
 377 0130 811B      		sub r24,r17
 378 0132 9109      		sbc r25,__zero_reg__
 379 0134 9D87      		std Y+13,r25
 380 0136 8C87      		std Y+12,r24
2278:../freeRTOS750/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 382               	.LM32:
 383 0138 DB8B      		std Y+19,r29
 384 013a CA8B      		std Y+18,r28
 385               	.LBE21:
 386               	.LBE20:
 547:../freeRTOS750/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 388               	.LM33:
 389 013c A301      		movw r20,r6
 390 013e B401      		movw r22,r8
 391 0140 C201      		movw r24,r4
 392 0142 0E94 0000 		call pxPortInitialiseStack
 393 0146 9983      		std Y+1,r25
 394 0148 8883      		st Y,r24
 551:../freeRTOS750/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 396               	.LM34:
 397 014a E114      		cp r14,__zero_reg__
 398 014c F104      		cpc r15,__zero_reg__
 399 014e 01F0      		breq .L11
 556:../freeRTOS750/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 401               	.LM35:
 402 0150 F701      		movw r30,r14
 403 0152 D183      		std Z+1,r29
 404 0154 C083      		st Z,r28
 405               	.L11:
 561:../freeRTOS750/tasks.c **** 		taskENTER_CRITICAL();
 407               	.LM36:
 408               	/* #APP */
 409               	 ;  561 "../freeRTOS750/tasks.c" 1
 410 0156 0FB6      		in		__tmp_reg__, __SREG__
 411               	 ;  0 "" 2
 412               	 ;  561 "../freeRTOS750/tasks.c" 1
 413 0158 F894      		cli
 414               	 ;  0 "" 2
 415               	 ;  561 "../freeRTOS750/tasks.c" 1
 416 015a 0F92      		push	__tmp_reg__
 417               	 ;  0 "" 2
 563:../freeRTOS750/tasks.c **** 			uxCurrentNumberOfTasks++;
 419               	.LM37:
 420               	/* #NOAPP */
 421 015c 8091 0000 		lds r24,uxCurrentNumberOfTasks
 422 0160 8F5F      		subi r24,lo8(-(1))
 423 0162 8093 0000 		sts uxCurrentNumberOfTasks,r24
 564:../freeRTOS750/tasks.c **** 			if( pxCurrentTCB == NULL )
 425               	.LM38:
 426 0166 8091 0000 		lds r24,pxCurrentTCB
 427 016a 9091 0000 		lds r25,pxCurrentTCB+1
 428 016e 892B      		or r24,r25
 429 0170 01F4      		brne .L12
 568:../freeRTOS750/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 431               	.LM39:
 432 0172 D093 0000 		sts pxCurrentTCB+1,r29
 433 0176 C093 0000 		sts pxCurrentTCB,r28
 570:../freeRTOS750/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 435               	.LM40:
 436 017a 8091 0000 		lds r24,uxCurrentNumberOfTasks
 437 017e 8130      		cpi r24,lo8(1)
 438 0180 01F0      		breq .+2
 439 0182 00C0      		rjmp .L14
 440 0184 E12C      		mov r14,__zero_reg__
 441 0186 F12C      		mov r15,__zero_reg__
 442               	.LBB22:
 443               	.LBB23:
2339:../freeRTOS750/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 445               	.LM41:
 446 0188 19E0      		ldi r17,lo8(9)
 447               	.L13:
 448 018a 1E9D      		mul r17,r14
 449 018c C001      		movw r24,r0
 450 018e 1F9D      		mul r17,r15
 451 0190 900D      		add r25,r0
 452 0192 1124      		clr __zero_reg__
 453 0194 8050      		subi r24,lo8(-(pxReadyTasksLists))
 454 0196 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 455 0198 0E94 0000 		call vListInitialise
 456 019c FFEF      		ldi r31,-1
 457 019e EF1A      		sub r14,r31
 458 01a0 FF0A      		sbc r15,r31
2337:../freeRTOS750/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX
 460               	.LM42:
 461 01a2 24E0      		ldi r18,4
 462 01a4 E216      		cp r14,r18
 463 01a6 F104      		cpc r15,__zero_reg__
 464 01a8 01F4      		brne .L13
2342:../freeRTOS750/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 466               	.LM43:
 467 01aa 80E0      		ldi r24,lo8(xDelayedTaskList1)
 468 01ac 90E0      		ldi r25,hi8(xDelayedTaskList1)
 469 01ae 0E94 0000 		call vListInitialise
2343:../freeRTOS750/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 471               	.LM44:
 472 01b2 80E0      		ldi r24,lo8(xDelayedTaskList2)
 473 01b4 90E0      		ldi r25,hi8(xDelayedTaskList2)
 474 01b6 0E94 0000 		call vListInitialise
2344:../freeRTOS750/tasks.c **** 	vListInitialise( &xPendingReadyList );
 476               	.LM45:
 477 01ba 80E0      		ldi r24,lo8(xPendingReadyList)
 478 01bc 90E0      		ldi r25,hi8(xPendingReadyList)
 479 01be 0E94 0000 		call vListInitialise
2348:../freeRTOS750/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 481               	.LM46:
 482 01c2 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 483 01c4 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 484 01c6 0E94 0000 		call vListInitialise
2360:../freeRTOS750/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 486               	.LM47:
 487 01ca 80E0      		ldi r24,lo8(xDelayedTaskList1)
 488 01cc 90E0      		ldi r25,hi8(xDelayedTaskList1)
 489 01ce 9093 0000 		sts pxDelayedTaskList+1,r25
 490 01d2 8093 0000 		sts pxDelayedTaskList,r24
2361:../freeRTOS750/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 492               	.LM48:
 493 01d6 80E0      		ldi r24,lo8(xDelayedTaskList2)
 494 01d8 90E0      		ldi r25,hi8(xDelayedTaskList2)
 495 01da 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 496 01de 8093 0000 		sts pxOverflowDelayedTaskList,r24
 497 01e2 00C0      		rjmp .L14
 498               	.L12:
 499               	.LBE23:
 500               	.LBE22:
 583:../freeRTOS750/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 502               	.LM49:
 503 01e4 8091 0000 		lds r24,xSchedulerRunning
 504 01e8 8111      		cpse r24,__zero_reg__
 505 01ea 00C0      		rjmp .L14
 585:../freeRTOS750/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 507               	.LM50:
 508 01ec E091 0000 		lds r30,pxCurrentTCB
 509 01f0 F091 0000 		lds r31,pxCurrentTCB+1
 510 01f4 8689      		ldd r24,Z+22
 511 01f6 0817      		cp r16,r24
 512 01f8 00F0      		brlo .L14
 587:../freeRTOS750/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 514               	.LM51:
 515 01fa D093 0000 		sts pxCurrentTCB+1,r29
 516 01fe C093 0000 		sts pxCurrentTCB,r28
 517               	.L14:
 592:../freeRTOS750/tasks.c **** 			uxTaskNumber++;
 519               	.LM52:
 520 0202 8091 0000 		lds r24,uxTaskNumber
 521 0206 8F5F      		subi r24,lo8(-(1))
 522 0208 8093 0000 		sts uxTaskNumber,r24
 602:../freeRTOS750/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 524               	.LM53:
 525 020c 8E89      		ldd r24,Y+22
 526 020e 9091 0000 		lds r25,uxTopReadyPriority
 527 0212 9817      		cp r25,r24
 528 0214 00F4      		brsh .L16
 602:../freeRTOS750/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 530               	.LM54:
 531 0216 8093 0000 		sts uxTopReadyPriority,r24
 532               	.L16:
 602:../freeRTOS750/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 534               	.LM55:
 535 021a A9E0      		ldi r26,lo8(9)
 536 021c 8A9F      		mul r24,r26
 537 021e C001      		movw r24,r0
 538 0220 1124      		clr __zero_reg__
 539 0222 B601      		movw r22,r12
 540 0224 8050      		subi r24,lo8(-(pxReadyTasksLists))
 541 0226 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 542 0228 0E94 0000 		call vListInsertEnd
 607:../freeRTOS750/tasks.c **** 		taskEXIT_CRITICAL();
 544               	.LM56:
 545               	/* #APP */
 546               	 ;  607 "../freeRTOS750/tasks.c" 1
 547 022c 0F90      		pop		__tmp_reg__
 548               	 ;  0 "" 2
 549               	 ;  607 "../freeRTOS750/tasks.c" 1
 550 022e 0FBE      		out		__SREG__, __tmp_reg__
 551               	 ;  0 "" 2
 552               	/* #NOAPP */
 553               	.LBE19:
 617:../freeRTOS750/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 555               	.LM57:
 556 0230 8091 0000 		lds r24,xSchedulerRunning
 557 0234 8823      		tst r24
 558 0236 01F0      		breq .L20
 621:../freeRTOS750/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 560               	.LM58:
 561 0238 E091 0000 		lds r30,pxCurrentTCB
 562 023c F091 0000 		lds r31,pxCurrentTCB+1
 563 0240 8689      		ldd r24,Z+22
 564 0242 8017      		cp r24,r16
 565 0244 00F4      		brsh .L20
 623:../freeRTOS750/tasks.c **** 				portYIELD_WITHIN_API();
 567               	.LM59:
 568 0246 0E94 0000 		call vPortYield
 569               	.L20:
 604:../freeRTOS750/tasks.c **** 			xReturn = pdPASS;
 571               	.LM60:
 572 024a 81E0      		ldi r24,lo8(1)
 573 024c 00C0      		rjmp .L32
 574               	.L5:
 575               	.LBB24:
 611:../freeRTOS750/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 577               	.LM61:
 578 024e 8FEF      		ldi r24,lo8(-1)
 579               	.L32:
 580               	/* epilogue start */
 581               	.LBE24:
 629:../freeRTOS750/tasks.c **** }
 583               	.LM62:
 584 0250 DF91      		pop r29
 585 0252 CF91      		pop r28
 586 0254 1F91      		pop r17
 587 0256 0F91      		pop r16
 588 0258 FF90      		pop r15
 589 025a EF90      		pop r14
 590 025c DF90      		pop r13
 591 025e CF90      		pop r12
 592 0260 BF90      		pop r11
 593 0262 AF90      		pop r10
 594 0264 9F90      		pop r9
 595 0266 8F90      		pop r8
 596 0268 7F90      		pop r7
 597 026a 6F90      		pop r6
 598 026c 5F90      		pop r5
 599 026e 4F90      		pop r4
 600 0270 3F90      		pop r3
 601 0272 0895      		ret
 613               	.Lscope2:
 615               		.stabd	78,0,0
 618               	.global	vTaskDelete
 620               	vTaskDelete:
 621               		.stabd	46,0,0
 635:../freeRTOS750/tasks.c **** 	{
 623               	.LM63:
 624               	.LFBB3:
 625 0274 0F93      		push r16
 626 0276 1F93      		push r17
 627 0278 CF93      		push r28
 628 027a DF93      		push r29
 629               	/* prologue: function */
 630               	/* frame size = 0 */
 631               	/* stack size = 4 */
 632               	.L__stack_usage = 4
 638:../freeRTOS750/tasks.c **** 		taskENTER_CRITICAL();
 634               	.LM64:
 635               	/* #APP */
 636               	 ;  638 "../freeRTOS750/tasks.c" 1
 637 027c 0FB6      		in		__tmp_reg__, __SREG__
 638               	 ;  0 "" 2
 639               	 ;  638 "../freeRTOS750/tasks.c" 1
 640 027e F894      		cli
 641               	 ;  0 "" 2
 642               	 ;  638 "../freeRTOS750/tasks.c" 1
 643 0280 0F92      		push	__tmp_reg__
 644               	 ;  0 "" 2
 641:../freeRTOS750/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 646               	.LM65:
 647               	/* #NOAPP */
 648 0282 0097      		sbiw r24,0
 649 0284 01F4      		brne .L37
 641:../freeRTOS750/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 651               	.LM66:
 652 0286 C091 0000 		lds r28,pxCurrentTCB
 653 028a D091 0000 		lds r29,pxCurrentTCB+1
 654 028e 00C0      		rjmp .L34
 655               	.L37:
 641:../freeRTOS750/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 657               	.LM67:
 658 0290 EC01      		movw r28,r24
 659               	.L34:
 647:../freeRTOS750/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 661               	.LM68:
 662 0292 8E01      		movw r16,r28
 663 0294 0E5F      		subi r16,-2
 664 0296 1F4F      		sbci r17,-1
 665 0298 C801      		movw r24,r16
 666 029a 0E94 0000 		call uxListRemove
 653:../freeRTOS750/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 668               	.LM69:
 669 029e 8C89      		ldd r24,Y+20
 670 02a0 9D89      		ldd r25,Y+21
 671 02a2 892B      		or r24,r25
 672 02a4 01F0      		breq .L35
 655:../freeRTOS750/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 674               	.LM70:
 675 02a6 CE01      		movw r24,r28
 676 02a8 0C96      		adiw r24,12
 677 02aa 0E94 0000 		call uxListRemove
 678               	.L35:
 658:../freeRTOS750/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 680               	.LM71:
 681 02ae B801      		movw r22,r16
 682 02b0 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 683 02b2 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 684 02b4 0E94 0000 		call vListInsertEnd
 663:../freeRTOS750/tasks.c **** 			++uxTasksDeleted;
 686               	.LM72:
 687 02b8 8091 0000 		lds r24,uxTasksDeleted
 688 02bc 8F5F      		subi r24,lo8(-(1))
 689 02be 8093 0000 		sts uxTasksDeleted,r24
 667:../freeRTOS750/tasks.c **** 			uxTaskNumber++;
 691               	.LM73:
 692 02c2 8091 0000 		lds r24,uxTaskNumber
 693 02c6 8F5F      		subi r24,lo8(-(1))
 694 02c8 8093 0000 		sts uxTaskNumber,r24
 671:../freeRTOS750/tasks.c **** 		taskEXIT_CRITICAL();
 696               	.LM74:
 697               	/* #APP */
 698               	 ;  671 "../freeRTOS750/tasks.c" 1
 699 02cc 0F90      		pop		__tmp_reg__
 700               	 ;  0 "" 2
 701               	 ;  671 "../freeRTOS750/tasks.c" 1
 702 02ce 0FBE      		out		__SREG__, __tmp_reg__
 703               	 ;  0 "" 2
 674:../freeRTOS750/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 705               	.LM75:
 706               	/* #NOAPP */
 707 02d0 8091 0000 		lds r24,xSchedulerRunning
 708 02d4 8823      		tst r24
 709 02d6 01F0      		breq .L33
 676:../freeRTOS750/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 711               	.LM76:
 712 02d8 8091 0000 		lds r24,pxCurrentTCB
 713 02dc 9091 0000 		lds r25,pxCurrentTCB+1
 714 02e0 C817      		cp r28,r24
 715 02e2 D907      		cpc r29,r25
 716 02e4 01F4      		brne .L33
 678:../freeRTOS750/tasks.c **** 				portYIELD_WITHIN_API();
 718               	.LM77:
 719 02e6 0E94 0000 		call vPortYield
 720               	.L33:
 721               	/* epilogue start */
 681:../freeRTOS750/tasks.c **** 	}
 723               	.LM78:
 724 02ea DF91      		pop r29
 725 02ec CF91      		pop r28
 726 02ee 1F91      		pop r17
 727 02f0 0F91      		pop r16
 728 02f2 0895      		ret
 733               	.Lscope3:
 735               		.stabd	78,0,0
 736               		.section	.rodata.str1.1,"aMS",@progbits,1
 737               	.LC0:
 738 0000 4944 4C45 		.string	"IDLE"
 738      00
 739               		.text
 741               	.global	vTaskStartScheduler
 743               	vTaskStartScheduler:
 744               		.stabd	46,0,0
1221:../freeRTOS750/tasks.c **** {
 746               	.LM79:
 747               	.LFBB4:
 748 02f4 AF92      		push r10
 749 02f6 BF92      		push r11
 750 02f8 CF92      		push r12
 751 02fa DF92      		push r13
 752 02fc EF92      		push r14
 753 02fe FF92      		push r15
 754 0300 0F93      		push r16
 755               	/* prologue: function */
 756               	/* frame size = 0 */
 757               	/* stack size = 7 */
 758               	.L__stack_usage = 7
1234:../freeRTOS750/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 760               	.LM80:
 761 0302 A12C      		mov r10,__zero_reg__
 762 0304 B12C      		mov r11,__zero_reg__
 763 0306 C12C      		mov r12,__zero_reg__
 764 0308 D12C      		mov r13,__zero_reg__
 765 030a E12C      		mov r14,__zero_reg__
 766 030c F12C      		mov r15,__zero_reg__
 767 030e 00E0      		ldi r16,0
 768 0310 20E0      		ldi r18,0
 769 0312 30E0      		ldi r19,0
 770 0314 45E5      		ldi r20,lo8(85)
 771 0316 50E0      		ldi r21,0
 772 0318 60E0      		ldi r22,lo8(.LC0)
 773 031a 70E0      		ldi r23,hi8(.LC0)
 774 031c 80E0      		ldi r24,lo8(gs(prvIdleTask))
 775 031e 90E0      		ldi r25,hi8(gs(prvIdleTask))
 776 0320 0E94 0000 		call xTaskGenericCreate
1247:../freeRTOS750/tasks.c **** 	if( xReturn == pdPASS )
 778               	.LM81:
 779 0324 8130      		cpi r24,lo8(1)
 780 0326 01F4      		brne .L44
1257:../freeRTOS750/tasks.c **** 		portDISABLE_INTERRUPTS();
 782               	.LM82:
 783               	/* #APP */
 784               	 ;  1257 "../freeRTOS750/tasks.c" 1
 785 0328 F894      		cli
 786               	 ;  0 "" 2
1259:../freeRTOS750/tasks.c **** 		xSchedulerRunning = pdTRUE;
 788               	.LM83:
 789               	/* #NOAPP */
 790 032a 8093 0000 		sts xSchedulerRunning,r24
1260:../freeRTOS750/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 792               	.LM84:
 793 032e 1092 0000 		sts xTickCount+1,__zero_reg__
 794 0332 1092 0000 		sts xTickCount,__zero_reg__
 795               	/* epilogue start */
1286:../freeRTOS750/tasks.c **** }
 797               	.LM85:
 798 0336 0F91      		pop r16
 799 0338 FF90      		pop r15
 800 033a EF90      		pop r14
 801 033c DF90      		pop r13
 802 033e CF90      		pop r12
 803 0340 BF90      		pop r11
 804 0342 AF90      		pop r10
1269:../freeRTOS750/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 806               	.LM86:
 807 0344 0C94 0000 		jmp xPortStartScheduler
 808               	.L44:
 809               	/* epilogue start */
1286:../freeRTOS750/tasks.c **** }
 811               	.LM87:
 812 0348 0F91      		pop r16
 813 034a FF90      		pop r15
 814 034c EF90      		pop r14
 815 034e DF90      		pop r13
 816 0350 CF90      		pop r12
 817 0352 BF90      		pop r11
 818 0354 AF90      		pop r10
 819 0356 0895      		ret
 821               	.Lscope4:
 823               		.stabd	78,0,0
 825               	.global	vTaskEndScheduler
 827               	vTaskEndScheduler:
 828               		.stabd	46,0,0
1290:../freeRTOS750/tasks.c **** {
 830               	.LM88:
 831               	.LFBB5:
 832               	/* prologue: function */
 833               	/* frame size = 0 */
 834               	/* stack size = 0 */
 835               	.L__stack_usage = 0
1294:../freeRTOS750/tasks.c **** 	portDISABLE_INTERRUPTS();
 837               	.LM89:
 838               	/* #APP */
 839               	 ;  1294 "../freeRTOS750/tasks.c" 1
 840 0358 F894      		cli
 841               	 ;  0 "" 2
1295:../freeRTOS750/tasks.c **** 	xSchedulerRunning = pdFALSE;
 843               	.LM90:
 844               	/* #NOAPP */
 845 035a 1092 0000 		sts xSchedulerRunning,__zero_reg__
1296:../freeRTOS750/tasks.c **** 	vPortEndScheduler();
 847               	.LM91:
 848 035e 0C94 0000 		jmp vPortEndScheduler
 850               	.Lscope5:
 852               		.stabd	78,0,0
 854               	.global	vTaskSuspendAll
 856               	vTaskSuspendAll:
 857               		.stabd	46,0,0
1301:../freeRTOS750/tasks.c **** {
 859               	.LM92:
 860               	.LFBB6:
 861               	/* prologue: function */
 862               	/* frame size = 0 */
 863               	/* stack size = 0 */
 864               	.L__stack_usage = 0
1304:../freeRTOS750/tasks.c **** 	++uxSchedulerSuspended;
 866               	.LM93:
 867 0362 8091 0000 		lds r24,uxSchedulerSuspended
 868 0366 8F5F      		subi r24,lo8(-(1))
 869 0368 8093 0000 		sts uxSchedulerSuspended,r24
 870 036c 0895      		ret
 872               	.Lscope6:
 874               		.stabd	78,0,0
 876               	.global	xTaskGetTickCount
 878               	xTaskGetTickCount:
 879               		.stabd	46,0,0
1407:../freeRTOS750/tasks.c **** {
 881               	.LM94:
 882               	.LFBB7:
 883               	/* prologue: function */
 884               	/* frame size = 0 */
 885               	/* stack size = 0 */
 886               	.L__stack_usage = 0
1411:../freeRTOS750/tasks.c **** 	taskENTER_CRITICAL();
 888               	.LM95:
 889               	/* #APP */
 890               	 ;  1411 "../freeRTOS750/tasks.c" 1
 891 036e 0FB6      		in		__tmp_reg__, __SREG__
 892               	 ;  0 "" 2
 893               	 ;  1411 "../freeRTOS750/tasks.c" 1
 894 0370 F894      		cli
 895               	 ;  0 "" 2
 896               	 ;  1411 "../freeRTOS750/tasks.c" 1
 897 0372 0F92      		push	__tmp_reg__
 898               	 ;  0 "" 2
1413:../freeRTOS750/tasks.c **** 		xTicks = xTickCount;
 900               	.LM96:
 901               	/* #NOAPP */
 902 0374 2091 0000 		lds r18,xTickCount
 903 0378 3091 0000 		lds r19,xTickCount+1
1415:../freeRTOS750/tasks.c **** 	taskEXIT_CRITICAL();
 905               	.LM97:
 906               	/* #APP */
 907               	 ;  1415 "../freeRTOS750/tasks.c" 1
 908 037c 0F90      		pop		__tmp_reg__
 909               	 ;  0 "" 2
 910               	 ;  1415 "../freeRTOS750/tasks.c" 1
 911 037e 0FBE      		out		__SREG__, __tmp_reg__
 912               	 ;  0 "" 2
1418:../freeRTOS750/tasks.c **** }
 914               	.LM98:
 915               	/* #NOAPP */
 916 0380 C901      		movw r24,r18
 917 0382 0895      		ret
 922               	.Lscope7:
 924               		.stabd	78,0,0
 926               	.global	xTaskGetTickCountFromISR
 928               	xTaskGetTickCountFromISR:
 929               		.stabd	46,0,0
1422:../freeRTOS750/tasks.c **** {
 931               	.LM99:
 932               	.LFBB8:
 933               	/* prologue: function */
 934               	/* frame size = 0 */
 935               	/* stack size = 0 */
 936               	.L__stack_usage = 0
1443:../freeRTOS750/tasks.c **** 	xReturn = xTickCount;
 938               	.LM100:
 939 0384 2091 0000 		lds r18,xTickCount
 940 0388 3091 0000 		lds r19,xTickCount+1
1447:../freeRTOS750/tasks.c **** }
 942               	.LM101:
 943 038c C901      		movw r24,r18
 944 038e 0895      		ret
 949               	.Lscope8:
 951               		.stabd	78,0,0
 953               	.global	uxTaskGetNumberOfTasks
 955               	uxTaskGetNumberOfTasks:
 956               		.stabd	46,0,0
1451:../freeRTOS750/tasks.c **** {
 958               	.LM102:
 959               	.LFBB9:
 960               	/* prologue: function */
 961               	/* frame size = 0 */
 962               	/* stack size = 0 */
 963               	.L__stack_usage = 0
1454:../freeRTOS750/tasks.c **** 	return uxCurrentNumberOfTasks;
 965               	.LM103:
 966 0390 8091 0000 		lds r24,uxCurrentNumberOfTasks
1455:../freeRTOS750/tasks.c **** }
 968               	.LM104:
 969 0394 0895      		ret
 971               	.Lscope9:
 973               		.stabd	78,0,0
 975               	.global	xTaskIncrementTick
 977               	xTaskIncrementTick:
 978               		.stabd	46,0,0
1572:../freeRTOS750/tasks.c **** {
 980               	.LM105:
 981               	.LFBB10:
 982 0396 CF92      		push r12
 983 0398 DF92      		push r13
 984 039a EF92      		push r14
 985 039c FF92      		push r15
 986 039e 0F93      		push r16
 987 03a0 1F93      		push r17
 988 03a2 CF93      		push r28
 989 03a4 DF93      		push r29
 990               	/* prologue: function */
 991               	/* frame size = 0 */
 992               	/* stack size = 8 */
 993               	.L__stack_usage = 8
1581:../freeRTOS750/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 995               	.LM106:
 996 03a6 8091 0000 		lds r24,uxSchedulerSuspended
 997 03aa 8111      		cpse r24,__zero_reg__
 998 03ac 00C0      		rjmp .L52
1585:../freeRTOS750/tasks.c **** 		++xTickCount;
 1000               	.LM107:
 1001 03ae 8091 0000 		lds r24,xTickCount
 1002 03b2 9091 0000 		lds r25,xTickCount+1
 1003 03b6 0196      		adiw r24,1
 1004 03b8 9093 0000 		sts xTickCount+1,r25
 1005 03bc 8093 0000 		sts xTickCount,r24
 1006               	.LBB25:
1590:../freeRTOS750/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
 1008               	.LM108:
 1009 03c0 0091 0000 		lds r16,xTickCount
 1010 03c4 1091 0000 		lds r17,xTickCount+1
1592:../freeRTOS750/tasks.c **** 			if( xConstTickCount == ( portTickType ) 0U )
 1012               	.LM109:
 1013 03c8 0115      		cp r16,__zero_reg__
 1014 03ca 1105      		cpc r17,__zero_reg__
 1015 03cc 01F4      		brne .L53
 1016               	.LBB26:
1594:../freeRTOS750/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 1018               	.LM110:
 1019 03ce 8091 0000 		lds r24,pxDelayedTaskList
 1020 03d2 9091 0000 		lds r25,pxDelayedTaskList+1
 1021 03d6 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1022 03da 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1023 03de 3093 0000 		sts pxDelayedTaskList+1,r19
 1024 03e2 2093 0000 		sts pxDelayedTaskList,r18
 1025 03e6 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1026 03ea 8093 0000 		sts pxOverflowDelayedTaskList,r24
 1027 03ee 8091 0000 		lds r24,xNumOfOverflows
 1028 03f2 8F5F      		subi r24,lo8(-(1))
 1029 03f4 8093 0000 		sts xNumOfOverflows,r24
 1030 03f8 E091 0000 		lds r30,pxDelayedTaskList
 1031 03fc F091 0000 		lds r31,pxDelayedTaskList+1
 1032 0400 8081      		ld r24,Z
 1033 0402 8111      		cpse r24,__zero_reg__
 1034 0404 00C0      		rjmp .L54
1594:../freeRTOS750/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 1036               	.LM111:
 1037 0406 8FEF      		ldi r24,lo8(-1)
 1038 0408 9FEF      		ldi r25,lo8(-1)
 1039 040a 00C0      		rjmp .L71
 1040               	.L54:
1594:../freeRTOS750/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 1042               	.LM112:
 1043 040c E091 0000 		lds r30,pxDelayedTaskList
 1044 0410 F091 0000 		lds r31,pxDelayedTaskList+1
 1045 0414 0580      		ldd __tmp_reg__,Z+5
 1046 0416 F681      		ldd r31,Z+6
 1047 0418 E02D      		mov r30,__tmp_reg__
 1048 041a 0680      		ldd __tmp_reg__,Z+6
 1049 041c F781      		ldd r31,Z+7
 1050 041e E02D      		mov r30,__tmp_reg__
 1051 0420 8281      		ldd r24,Z+2
 1052 0422 9381      		ldd r25,Z+3
 1053               	.L71:
 1054 0424 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1055 0428 8093 0000 		sts xNextTaskUnblockTime,r24
 1056               	.L53:
 1057               	.LBE26:
1601:../freeRTOS750/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
 1059               	.LM113:
 1060 042c 8091 0000 		lds r24,xNextTaskUnblockTime
 1061 0430 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1062 0434 D12C      		mov r13,__zero_reg__
 1063 0436 0817      		cp r16,r24
 1064 0438 1907      		cpc r17,r25
 1065 043a 00F4      		brsh .L64
 1066 043c 00C0      		rjmp .L56
 1067               	.L65:
1657:../freeRTOS750/tasks.c **** 								xSwitchRequired = pdTRUE;
 1069               	.LM114:
 1070 043e DD24      		clr r13
 1071 0440 D394      		inc r13
 1072 0442 00C0      		rjmp .L70
 1073               	.L64:
1645:../freeRTOS750/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1075               	.LM115:
 1076 0444 89E0      		ldi r24,lo8(9)
 1077 0446 C82E      		mov r12,r24
 1078               	.L70:
1605:../freeRTOS750/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1080               	.LM116:
 1081 0448 E091 0000 		lds r30,pxDelayedTaskList
 1082 044c F091 0000 		lds r31,pxDelayedTaskList+1
 1083 0450 8081      		ld r24,Z
 1084 0452 8111      		cpse r24,__zero_reg__
 1085 0454 00C0      		rjmp .L57
1611:../freeRTOS750/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
 1087               	.LM117:
 1088 0456 8FEF      		ldi r24,lo8(-1)
 1089 0458 9FEF      		ldi r25,lo8(-1)
 1090 045a 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1091 045e 8093 0000 		sts xNextTaskUnblockTime,r24
1612:../freeRTOS750/tasks.c **** 						break;
 1093               	.LM118:
 1094 0462 00C0      		rjmp .L56
 1095               	.L57:
1620:../freeRTOS750/tasks.c **** 						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1097               	.LM119:
 1098 0464 E091 0000 		lds r30,pxDelayedTaskList
 1099 0468 F091 0000 		lds r31,pxDelayedTaskList+1
 1100 046c 0580      		ldd __tmp_reg__,Z+5
 1101 046e F681      		ldd r31,Z+6
 1102 0470 E02D      		mov r30,__tmp_reg__
 1103 0472 C681      		ldd r28,Z+6
 1104 0474 D781      		ldd r29,Z+7
1621:../freeRTOS750/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1106               	.LM120:
 1107 0476 2A81      		ldd r18,Y+2
 1108 0478 3B81      		ldd r19,Y+3
1623:../freeRTOS750/tasks.c **** 						if( xConstTickCount < xItemValue )
 1110               	.LM121:
 1111 047a 0217      		cp r16,r18
 1112 047c 1307      		cpc r17,r19
 1113 047e 00F4      		brsh .L58
1629:../freeRTOS750/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
 1115               	.LM122:
 1116 0480 3093 0000 		sts xNextTaskUnblockTime+1,r19
 1117 0484 2093 0000 		sts xNextTaskUnblockTime,r18
1630:../freeRTOS750/tasks.c **** 							break;
 1119               	.LM123:
 1120 0488 00C0      		rjmp .L56
 1121               	.L58:
1634:../freeRTOS750/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1123               	.LM124:
 1124 048a 7E01      		movw r14,r28
 1125 048c 82E0      		ldi r24,2
 1126 048e E80E      		add r14,r24
 1127 0490 F11C      		adc r15,__zero_reg__
 1128 0492 C701      		movw r24,r14
 1129 0494 0E94 0000 		call uxListRemove
1638:../freeRTOS750/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1131               	.LM125:
 1132 0498 2C89      		ldd r18,Y+20
 1133 049a 3D89      		ldd r19,Y+21
 1134 049c 232B      		or r18,r19
 1135 049e 01F0      		breq .L59
1640:../freeRTOS750/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1137               	.LM126:
 1138 04a0 CE01      		movw r24,r28
 1139 04a2 0C96      		adiw r24,12
 1140 04a4 0E94 0000 		call uxListRemove
 1141               	.L59:
1645:../freeRTOS750/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1143               	.LM127:
 1144 04a8 2E89      		ldd r18,Y+22
 1145 04aa 8091 0000 		lds r24,uxTopReadyPriority
 1146 04ae 8217      		cp r24,r18
 1147 04b0 00F4      		brsh .L60
1645:../freeRTOS750/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1149               	.LM128:
 1150 04b2 2093 0000 		sts uxTopReadyPriority,r18
 1151               	.L60:
1645:../freeRTOS750/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1153               	.LM129:
 1154 04b6 C29E      		mul r12,r18
 1155 04b8 C001      		movw r24,r0
 1156 04ba 1124      		clr __zero_reg__
 1157 04bc B701      		movw r22,r14
 1158 04be 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1159 04c0 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1160 04c2 0E94 0000 		call vListInsertEnd
1655:../freeRTOS750/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1162               	.LM130:
 1163 04c6 E091 0000 		lds r30,pxCurrentTCB
 1164 04ca F091 0000 		lds r31,pxCurrentTCB+1
 1165 04ce 9E89      		ldd r25,Y+22
 1166 04d0 8689      		ldd r24,Z+22
 1167 04d2 9817      		cp r25,r24
 1168 04d4 00F0      		brlo .+2
 1169 04d6 00C0      		rjmp .L65
 1170 04d8 00C0      		rjmp .L70
 1171               	.L56:
 1172               	.LBE25:
1671:../freeRTOS750/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned p
 1174               	.LM131:
 1175 04da E091 0000 		lds r30,pxCurrentTCB
 1176 04de F091 0000 		lds r31,pxCurrentTCB+1
 1177 04e2 E689      		ldd r30,Z+22
 1178 04e4 89E0      		ldi r24,lo8(9)
 1179 04e6 E89F      		mul r30,r24
 1180 04e8 F001      		movw r30,r0
 1181 04ea 1124      		clr __zero_reg__
 1182 04ec E050      		subi r30,lo8(-(pxReadyTasksLists))
 1183 04ee F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1184 04f0 8081      		ld r24,Z
 1185 04f2 8230      		cpi r24,lo8(2)
 1186 04f4 00F4      		brsh .L66
 1187 04f6 00C0      		rjmp .L63
 1188               	.L52:
1680:../freeRTOS750/tasks.c **** 		++uxPendedTicks;
 1190               	.LM132:
 1191 04f8 8091 0000 		lds r24,uxPendedTicks
 1192 04fc 8F5F      		subi r24,lo8(-(1))
 1193 04fe 8093 0000 		sts uxPendedTicks,r24
1575:../freeRTOS750/tasks.c **** portBASE_TYPE xSwitchRequired = pdFALSE;
 1195               	.LM133:
 1196 0502 D12C      		mov r13,__zero_reg__
 1197 0504 00C0      		rjmp .L63
 1198               	.L66:
1673:../freeRTOS750/tasks.c **** 				xSwitchRequired = pdTRUE;
 1200               	.LM134:
 1201 0506 DD24      		clr r13
 1202 0508 D394      		inc r13
 1203               	.L63:
1703:../freeRTOS750/tasks.c **** }
 1205               	.LM135:
 1206 050a 8D2D      		mov r24,r13
 1207               	/* epilogue start */
 1208 050c DF91      		pop r29
 1209 050e CF91      		pop r28
 1210 0510 1F91      		pop r17
 1211 0512 0F91      		pop r16
 1212 0514 FF90      		pop r15
 1213 0516 EF90      		pop r14
 1214 0518 DF90      		pop r13
 1215 051a CF90      		pop r12
 1216 051c 0895      		ret
 1228               	.Lscope10:
 1230               		.stabd	78,0,0
 1232               	.global	xTaskResumeAll
 1234               	xTaskResumeAll:
 1235               		.stabd	46,0,0
1337:../freeRTOS750/tasks.c **** {
 1237               	.LM136:
 1238               	.LFBB11:
 1239 051e EF92      		push r14
 1240 0520 FF92      		push r15
 1241 0522 0F93      		push r16
 1242 0524 1F93      		push r17
 1243 0526 CF93      		push r28
 1244 0528 DF93      		push r29
 1245               	/* prologue: function */
 1246               	/* frame size = 0 */
 1247               	/* stack size = 6 */
 1248               	.L__stack_usage = 6
1351:../freeRTOS750/tasks.c **** 	taskENTER_CRITICAL();
 1250               	.LM137:
 1251               	/* #APP */
 1252               	 ;  1351 "../freeRTOS750/tasks.c" 1
 1253 052a 0FB6      		in		__tmp_reg__, __SREG__
 1254               	 ;  0 "" 2
 1255               	 ;  1351 "../freeRTOS750/tasks.c" 1
 1256 052c F894      		cli
 1257               	 ;  0 "" 2
 1258               	 ;  1351 "../freeRTOS750/tasks.c" 1
 1259 052e 0F92      		push	__tmp_reg__
 1260               	 ;  0 "" 2
1353:../freeRTOS750/tasks.c **** 		--uxSchedulerSuspended;
 1262               	.LM138:
 1263               	/* #NOAPP */
 1264 0530 8091 0000 		lds r24,uxSchedulerSuspended
 1265 0534 8150      		subi r24,lo8(-(-1))
 1266 0536 8093 0000 		sts uxSchedulerSuspended,r24
1355:../freeRTOS750/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1268               	.LM139:
 1269 053a 8091 0000 		lds r24,uxSchedulerSuspended
 1270 053e 8823      		tst r24
 1271 0540 01F0      		breq .L73
 1272               	.L76:
1339:../freeRTOS750/tasks.c **** portBASE_TYPE xAlreadyYielded = pdFALSE;
 1274               	.LM140:
 1275 0542 80E0      		ldi r24,0
 1276 0544 00C0      		rjmp .L74
 1277               	.L73:
1357:../freeRTOS750/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1279               	.LM141:
 1280 0546 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1281 054a 8111      		cpse r24,__zero_reg__
 1282 054c 00C0      		rjmp .L85
 1283 054e 00C0      		rjmp .L76
 1284               	.L79:
1363:../freeRTOS750/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 1286               	.LM142:
 1287 0550 E091 0000 		lds r30,xPendingReadyList+5
 1288 0554 F091 0000 		lds r31,xPendingReadyList+5+1
 1289 0558 C681      		ldd r28,Z+6
 1290 055a D781      		ldd r29,Z+7
1364:../freeRTOS750/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1292               	.LM143:
 1293 055c CE01      		movw r24,r28
 1294 055e 0C96      		adiw r24,12
 1295 0560 0E94 0000 		call uxListRemove
1365:../freeRTOS750/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1297               	.LM144:
 1298 0564 8E01      		movw r16,r28
 1299 0566 0E5F      		subi r16,-2
 1300 0568 1F4F      		sbci r17,-1
 1301 056a C801      		movw r24,r16
 1302 056c 0E94 0000 		call uxListRemove
1366:../freeRTOS750/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1304               	.LM145:
 1305 0570 8E89      		ldd r24,Y+22
 1306 0572 9091 0000 		lds r25,uxTopReadyPriority
 1307 0576 9817      		cp r25,r24
 1308 0578 00F4      		brsh .L77
1366:../freeRTOS750/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1310               	.LM146:
 1311 057a 8093 0000 		sts uxTopReadyPriority,r24
 1312               	.L77:
1366:../freeRTOS750/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1314               	.LM147:
 1315 057e E89E      		mul r14,r24
 1316 0580 C001      		movw r24,r0
 1317 0582 1124      		clr __zero_reg__
 1318 0584 B801      		movw r22,r16
 1319 0586 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1320 0588 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1321 058a 0E94 0000 		call vListInsertEnd
1370:../freeRTOS750/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1323               	.LM148:
 1324 058e E091 0000 		lds r30,pxCurrentTCB
 1325 0592 F091 0000 		lds r31,pxCurrentTCB+1
 1326 0596 9E89      		ldd r25,Y+22
 1327 0598 8689      		ldd r24,Z+22
 1328 059a 9817      		cp r25,r24
 1329 059c 00F0      		brlo .L94
1372:../freeRTOS750/tasks.c **** 						xYieldRequired = pdTRUE;
 1331               	.LM149:
 1332 059e FF24      		clr r15
 1333 05a0 F394      		inc r15
 1334 05a2 00C0      		rjmp .L94
 1335               	.L85:
1357:../freeRTOS750/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1337               	.LM150:
 1338 05a4 F12C      		mov r15,__zero_reg__
1366:../freeRTOS750/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1340               	.LM151:
 1341 05a6 99E0      		ldi r25,lo8(9)
 1342 05a8 E92E      		mov r14,r25
 1343               	.L94:
1361:../freeRTOS750/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1345               	.LM152:
 1346 05aa 8091 0000 		lds r24,xPendingReadyList
 1347 05ae 8111      		cpse r24,__zero_reg__
 1348 05b0 00C0      		rjmp .L79
1379:../freeRTOS750/tasks.c **** 				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 1350               	.LM153:
 1351 05b2 8091 0000 		lds r24,uxPendedTicks
 1352 05b6 8823      		tst r24
 1353 05b8 01F0      		breq .L80
 1354 05ba 00C0      		rjmp .L95
 1355               	.L83:
1383:../freeRTOS750/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
 1357               	.LM154:
 1358 05bc 0E94 0000 		call xTaskIncrementTick
 1359 05c0 8823      		tst r24
 1360 05c2 01F0      		breq .L82
1385:../freeRTOS750/tasks.c **** 							xYieldRequired = pdTRUE;
 1362               	.LM155:
 1363 05c4 FF24      		clr r15
 1364 05c6 F394      		inc r15
 1365               	.L82:
1387:../freeRTOS750/tasks.c **** 						--uxPendedTicks;
 1367               	.LM156:
 1368 05c8 8091 0000 		lds r24,uxPendedTicks
 1369 05cc 8150      		subi r24,lo8(-(-1))
 1370 05ce 8093 0000 		sts uxPendedTicks,r24
 1371               	.L95:
1381:../freeRTOS750/tasks.c **** 					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 1373               	.LM157:
 1374 05d2 8091 0000 		lds r24,uxPendedTicks
 1375 05d6 8111      		cpse r24,__zero_reg__
 1376 05d8 00C0      		rjmp .L83
 1377               	.L80:
1391:../freeRTOS750/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xYieldPending == pdTRUE ) )
 1379               	.LM158:
 1380 05da 81E0      		ldi r24,lo8(1)
 1381 05dc F816      		cp r15,r24
 1382 05de 01F0      		breq .L84
1391:../freeRTOS750/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xYieldPending == pdTRUE ) )
 1384               	.LM159:
 1385 05e0 8091 0000 		lds r24,xYieldPending
 1386 05e4 8130      		cpi r24,lo8(1)
 1387 05e6 01F0      		breq .+2
 1388 05e8 00C0      		rjmp .L76
 1389               	.L84:
1394:../freeRTOS750/tasks.c **** 					xYieldPending = pdFALSE;
 1391               	.LM160:
 1392 05ea 1092 0000 		sts xYieldPending,__zero_reg__
1395:../freeRTOS750/tasks.c **** 					portYIELD_WITHIN_API();
 1394               	.LM161:
 1395 05ee 0E94 0000 		call vPortYield
1393:../freeRTOS750/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1397               	.LM162:
 1398 05f2 81E0      		ldi r24,lo8(1)
 1399               	.L74:
1400:../freeRTOS750/tasks.c **** 	taskEXIT_CRITICAL();
 1401               	.LM163:
 1402               	/* #APP */
 1403               	 ;  1400 "../freeRTOS750/tasks.c" 1
 1404 05f4 0F90      		pop		__tmp_reg__
 1405               	 ;  0 "" 2
 1406               	 ;  1400 "../freeRTOS750/tasks.c" 1
 1407 05f6 0FBE      		out		__SREG__, __tmp_reg__
 1408               	 ;  0 "" 2
 1409               	/* epilogue start */
1403:../freeRTOS750/tasks.c **** }
 1411               	.LM164:
 1412               	/* #NOAPP */
 1413 05f8 DF91      		pop r29
 1414 05fa CF91      		pop r28
 1415 05fc 1F91      		pop r17
 1416 05fe 0F91      		pop r16
 1417 0600 FF90      		pop r15
 1418 0602 EF90      		pop r14
 1419 0604 0895      		ret
 1426               	.Lscope11:
 1428               		.stabd	78,0,0
 1432               	prvIdleTask:
 1433               		.stabd	46,0,0
2103:../freeRTOS750/tasks.c **** {
 1435               	.LM165:
 1436               	.LFBB12:
 1437               	/* prologue: function */
 1438               	/* frame size = 0 */
 1439               	/* stack size = 0 */
 1440               	.L__stack_usage = 0
 1441 0606 00C0      		rjmp .L106
 1442               	.L99:
 1443               	.LBB34:
 1444               	.LBB35:
2375:../freeRTOS750/tasks.c **** 			vTaskSuspendAll();
 1446               	.LM166:
 1447 0608 0E94 0000 		call vTaskSuspendAll
2376:../freeRTOS750/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 1449               	.LM167:
 1450 060c C091 0000 		lds r28,xTasksWaitingTermination
2377:../freeRTOS750/tasks.c **** 			( void ) xTaskResumeAll();
 1452               	.LM168:
 1453 0610 0E94 0000 		call xTaskResumeAll
2379:../freeRTOS750/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 1455               	.LM169:
 1456 0614 CC23      		tst r28
 1457 0616 01F0      		breq .L106
 1458               	.LBB36:
2383:../freeRTOS750/tasks.c **** 				taskENTER_CRITICAL();
 1460               	.LM170:
 1461               	/* #APP */
 1462               	 ;  2383 "../freeRTOS750/tasks.c" 1
 1463 0618 0FB6      		in		__tmp_reg__, __SREG__
 1464               	 ;  0 "" 2
 1465               	 ;  2383 "../freeRTOS750/tasks.c" 1
 1466 061a F894      		cli
 1467               	 ;  0 "" 2
 1468               	 ;  2383 "../freeRTOS750/tasks.c" 1
 1469 061c 0F92      		push	__tmp_reg__
 1470               	 ;  0 "" 2
2385:../freeRTOS750/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 1472               	.LM171:
 1473               	/* #NOAPP */
 1474 061e E091 0000 		lds r30,xTasksWaitingTermination+5
 1475 0622 F091 0000 		lds r31,xTasksWaitingTermination+5+1
 1476 0626 C681      		ldd r28,Z+6
 1477 0628 D781      		ldd r29,Z+7
2386:../freeRTOS750/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1479               	.LM172:
 1480 062a CE01      		movw r24,r28
 1481 062c 0296      		adiw r24,2
 1482 062e 0E94 0000 		call uxListRemove
2387:../freeRTOS750/tasks.c **** 					--uxCurrentNumberOfTasks;
 1484               	.LM173:
 1485 0632 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1486 0636 8150      		subi r24,lo8(-(-1))
 1487 0638 8093 0000 		sts uxCurrentNumberOfTasks,r24
2388:../freeRTOS750/tasks.c **** 					--uxTasksDeleted;
 1489               	.LM174:
 1490 063c 8091 0000 		lds r24,uxTasksDeleted
 1491 0640 8150      		subi r24,lo8(-(-1))
 1492 0642 8093 0000 		sts uxTasksDeleted,r24
2390:../freeRTOS750/tasks.c **** 				taskEXIT_CRITICAL();
 1494               	.LM175:
 1495               	/* #APP */
 1496               	 ;  2390 "../freeRTOS750/tasks.c" 1
 1497 0646 0F90      		pop		__tmp_reg__
 1498               	 ;  0 "" 2
 1499               	 ;  2390 "../freeRTOS750/tasks.c" 1
 1500 0648 0FBE      		out		__SREG__, __tmp_reg__
 1501               	 ;  0 "" 2
 1502               	/* #NOAPP */
 1503               	.LBB37:
 1504               	.LBB38:
2451:../freeRTOS750/tasks.c **** 		}
2452:../freeRTOS750/tasks.c **** 	}
2453:../freeRTOS750/tasks.c **** 
2454:../freeRTOS750/tasks.c **** 	return pxNewTCB;
2455:../freeRTOS750/tasks.c **** }
2456:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2457:../freeRTOS750/tasks.c **** 
2458:../freeRTOS750/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2459:../freeRTOS750/tasks.c **** 
2460:../freeRTOS750/tasks.c **** 	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xLi
2461:../freeRTOS750/tasks.c **** 	{
2462:../freeRTOS750/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2463:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxTask = 0;
2464:../freeRTOS750/tasks.c **** 
2465:../freeRTOS750/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( unsigned portBASE_TYPE ) 0 )
2466:../freeRTOS750/tasks.c **** 		{
2467:../freeRTOS750/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2468:../freeRTOS750/tasks.c **** 
2469:../freeRTOS750/tasks.c **** 			/* Populate an xTaskStatusType structure within the
2470:../freeRTOS750/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
2471:../freeRTOS750/tasks.c **** 			pxList.  See the definition of xTaskStatusType in task.h for the
2472:../freeRTOS750/tasks.c **** 			meaning of each xTaskStatusType structure member. */
2473:../freeRTOS750/tasks.c **** 			do
2474:../freeRTOS750/tasks.c **** 			{
2475:../freeRTOS750/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2476:../freeRTOS750/tasks.c **** 
2477:../freeRTOS750/tasks.c **** 				pxTaskStatusArray[ uxTask ].xHandle = ( xTaskHandle ) pxNextTCB;
2478:../freeRTOS750/tasks.c **** 				pxTaskStatusArray[ uxTask ].pcTaskName = ( const signed char * ) &( pxNextTCB->pcTaskName [ 0 ]
2479:../freeRTOS750/tasks.c **** 				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
2480:../freeRTOS750/tasks.c **** 				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
2481:../freeRTOS750/tasks.c **** 				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
2482:../freeRTOS750/tasks.c **** 
2483:../freeRTOS750/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
2484:../freeRTOS750/tasks.c **** 				{
2485:../freeRTOS750/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
2486:../freeRTOS750/tasks.c **** 				}
2487:../freeRTOS750/tasks.c **** 				#else
2488:../freeRTOS750/tasks.c **** 				{
2489:../freeRTOS750/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2490:../freeRTOS750/tasks.c **** 				}
2491:../freeRTOS750/tasks.c **** 				#endif
2492:../freeRTOS750/tasks.c **** 
2493:../freeRTOS750/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1 )
2494:../freeRTOS750/tasks.c **** 				{
2495:../freeRTOS750/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
2496:../freeRTOS750/tasks.c **** 				}
2497:../freeRTOS750/tasks.c **** 				#else
2498:../freeRTOS750/tasks.c **** 				{
2499:../freeRTOS750/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
2500:../freeRTOS750/tasks.c **** 				}
2501:../freeRTOS750/tasks.c **** 				#endif
2502:../freeRTOS750/tasks.c **** 
2503:../freeRTOS750/tasks.c **** 				#if ( portSTACK_GROWTH > 0 )
2504:../freeRTOS750/tasks.c **** 				{
2505:../freeRTOS750/tasks.c **** 					ppxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned cha
2506:../freeRTOS750/tasks.c **** 				}
2507:../freeRTOS750/tasks.c **** 				#else
2508:../freeRTOS750/tasks.c **** 				{
2509:../freeRTOS750/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned char
2510:../freeRTOS750/tasks.c **** 				}
2511:../freeRTOS750/tasks.c **** 				#endif
2512:../freeRTOS750/tasks.c **** 
2513:../freeRTOS750/tasks.c **** 				uxTask++;
2514:../freeRTOS750/tasks.c **** 
2515:../freeRTOS750/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2516:../freeRTOS750/tasks.c **** 		}
2517:../freeRTOS750/tasks.c **** 
2518:../freeRTOS750/tasks.c **** 		return uxTask;
2519:../freeRTOS750/tasks.c **** 	}
2520:../freeRTOS750/tasks.c **** 
2521:../freeRTOS750/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2522:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2523:../freeRTOS750/tasks.c **** 
2524:../freeRTOS750/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2525:../freeRTOS750/tasks.c **** 
2526:../freeRTOS750/tasks.c **** 	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2527:../freeRTOS750/tasks.c **** 	{
2528:../freeRTOS750/tasks.c **** 	unsigned short usCount = 0U;
2529:../freeRTOS750/tasks.c **** 
2530:../freeRTOS750/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2531:../freeRTOS750/tasks.c **** 		{
2532:../freeRTOS750/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2533:../freeRTOS750/tasks.c **** 			usCount++;
2534:../freeRTOS750/tasks.c **** 		}
2535:../freeRTOS750/tasks.c **** 
2536:../freeRTOS750/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2537:../freeRTOS750/tasks.c **** 
2538:../freeRTOS750/tasks.c **** 		return usCount;
2539:../freeRTOS750/tasks.c **** 	}
2540:../freeRTOS750/tasks.c **** 
2541:../freeRTOS750/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
2542:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2543:../freeRTOS750/tasks.c **** 
2544:../freeRTOS750/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2545:../freeRTOS750/tasks.c **** 
2546:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2547:../freeRTOS750/tasks.c **** 	{
2548:../freeRTOS750/tasks.c **** 	tskTCB *pxTCB;
2549:../freeRTOS750/tasks.c **** 	unsigned char *pcEndOfStack;
2550:../freeRTOS750/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2551:../freeRTOS750/tasks.c **** 
2552:../freeRTOS750/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2553:../freeRTOS750/tasks.c **** 
2554:../freeRTOS750/tasks.c **** 		#if portSTACK_GROWTH < 0
2555:../freeRTOS750/tasks.c **** 		{
2556:../freeRTOS750/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2557:../freeRTOS750/tasks.c **** 		}
2558:../freeRTOS750/tasks.c **** 		#else
2559:../freeRTOS750/tasks.c **** 		{
2560:../freeRTOS750/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2561:../freeRTOS750/tasks.c **** 		}
2562:../freeRTOS750/tasks.c **** 		#endif
2563:../freeRTOS750/tasks.c **** 
2564:../freeRTOS750/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) prvTaskCheckFreeStackSpace( pcEndOfStack );
2565:../freeRTOS750/tasks.c **** 
2566:../freeRTOS750/tasks.c **** 		return uxReturn;
2567:../freeRTOS750/tasks.c **** 	}
2568:../freeRTOS750/tasks.c **** 
2569:../freeRTOS750/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
2570:../freeRTOS750/tasks.c **** /*-----------------------------------------------------------*/
2571:../freeRTOS750/tasks.c **** 
2572:../freeRTOS750/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2573:../freeRTOS750/tasks.c **** 
2574:../freeRTOS750/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2575:../freeRTOS750/tasks.c **** 	{
2576:../freeRTOS750/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2577:../freeRTOS750/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
2578:../freeRTOS750/tasks.c **** 		want to allocate and clean RAM statically. */
2579:../freeRTOS750/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2580:../freeRTOS750/tasks.c **** 
2581:../freeRTOS750/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2582:../freeRTOS750/tasks.c **** 		the task to free any memory allocated at the application level. */
2583:../freeRTOS750/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 1506               	.LM176:
 1507 064a 8F89      		ldd r24,Y+23
 1508 064c 988D      		ldd r25,Y+24
 1509 064e 0E94 0000 		call vPortFree
2584:../freeRTOS750/tasks.c **** 		vPortFree( pxTCB );
 1511               	.LM177:
 1512 0652 CE01      		movw r24,r28
 1513 0654 0E94 0000 		call vPortFree
 1514               	.L106:
 1515               	.LBE38:
 1516               	.LBE37:
 1517               	.LBE36:
2373:../freeRTOS750/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 1519               	.LM178:
 1520 0658 8091 0000 		lds r24,uxTasksDeleted
 1521 065c 8111      		cpse r24,__zero_reg__
 1522 065e 00C0      		rjmp .L99
 1523               	.LBE35:
 1524               	.LBE34:
2133:../freeRTOS750/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 1526               	.LM179:
 1527 0660 8091 0000 		lds r24,pxReadyTasksLists
 1528 0664 8230      		cpi r24,lo8(2)
 1529 0666 00F0      		brlo .L100
2135:../freeRTOS750/tasks.c **** 				taskYIELD();
 1531               	.LM180:
 1532 0668 0E94 0000 		call vPortYield
 1533               	.L100:
 1534               	.LBB39:
2149:../freeRTOS750/tasks.c **** 			vApplicationIdleHook();
 1536               	.LM181:
 1537 066c 0E94 0000 		call vApplicationIdleHook
 1538               	.LBE39:
2189:../freeRTOS750/tasks.c **** 	}
 1540               	.LM182:
 1541 0670 00C0      		rjmp .L106
 1546               	.Lscope12:
 1548               		.stabd	78,0,0
 1551               	.global	vTaskDelay
 1553               	vTaskDelay:
 1554               		.stabd	46,0,0
 765:../freeRTOS750/tasks.c **** 	{
 1556               	.LM183:
 1557               	.LFBB13:
 1558 0672 0F93      		push r16
 1559 0674 1F93      		push r17
 1560 0676 CF93      		push r28
 1561 0678 DF93      		push r29
 1562               	/* prologue: function */
 1563               	/* frame size = 0 */
 1564               	/* stack size = 4 */
 1565               	.L__stack_usage = 4
 1566 067a 8C01      		movw r16,r24
 770:../freeRTOS750/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 1568               	.LM184:
 1569 067c 0097      		sbiw r24,0
 1570 067e 01F4      		brne .L108
 1571               	.L110:
 807:../freeRTOS750/tasks.c **** 			portYIELD_WITHIN_API();
 1573               	.LM185:
 1574 0680 0E94 0000 		call vPortYield
 1575 0684 00C0      		rjmp .L107
 1576               	.L108:
 772:../freeRTOS750/tasks.c **** 			vTaskSuspendAll();
 1578               	.LM186:
 1579 0686 0E94 0000 		call vTaskSuspendAll
 786:../freeRTOS750/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1581               	.LM187:
 1582 068a C091 0000 		lds r28,xTickCount
 1583 068e D091 0000 		lds r29,xTickCount+1
 1584 0692 C00F      		add r28,r16
 1585 0694 D11F      		adc r29,r17
 791:../freeRTOS750/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 1587               	.LM188:
 1588 0696 8091 0000 		lds r24,pxCurrentTCB
 1589 069a 9091 0000 		lds r25,pxCurrentTCB+1
 1590 069e 0296      		adiw r24,2
 1591 06a0 0E94 0000 		call uxListRemove
 798:../freeRTOS750/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1593               	.LM189:
 1594 06a4 CE01      		movw r24,r28
 1595 06a6 0E94 0000 		call prvAddCurrentTaskToDelayedList
 800:../freeRTOS750/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 1597               	.LM190:
 1598 06aa 0E94 0000 		call xTaskResumeAll
 805:../freeRTOS750/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1600               	.LM191:
 1601 06ae 8823      		tst r24
 1602 06b0 01F0      		breq .L110
 1603               	.L107:
 1604               	/* epilogue start */
 809:../freeRTOS750/tasks.c **** 	}
 1606               	.LM192:
 1607 06b2 DF91      		pop r29
 1608 06b4 CF91      		pop r28
 1609 06b6 1F91      		pop r17
 1610 06b8 0F91      		pop r16
 1611 06ba 0895      		ret
 1616               	.Lscope13:
 1618               		.stabd	78,0,0
 1622               	.global	vTaskDelayUntil
 1624               	vTaskDelayUntil:
 1625               		.stabd	46,0,0
 689:../freeRTOS750/tasks.c **** 	{
 1627               	.LM193:
 1628               	.LFBB14:
 1629 06bc 0F93      		push r16
 1630 06be 1F93      		push r17
 1631 06c0 CF93      		push r28
 1632 06c2 DF93      		push r29
 1633               	/* prologue: function */
 1634               	/* frame size = 0 */
 1635               	/* stack size = 4 */
 1636               	.L__stack_usage = 4
 1637 06c4 8C01      		movw r16,r24
 1638 06c6 EB01      		movw r28,r22
 696:../freeRTOS750/tasks.c **** 		vTaskSuspendAll();
 1640               	.LM194:
 1641 06c8 0E94 0000 		call vTaskSuspendAll
 1642               	.LBB40:
 700:../freeRTOS750/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
 1644               	.LM195:
 1645 06cc 4091 0000 		lds r20,xTickCount
 1646 06d0 5091 0000 		lds r21,xTickCount+1
 703:../freeRTOS750/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1648               	.LM196:
 1649 06d4 F801      		movw r30,r16
 1650 06d6 2081      		ld r18,Z
 1651 06d8 3181      		ldd r19,Z+1
 1652 06da C20F      		add r28,r18
 1653 06dc D31F      		adc r29,r19
 705:../freeRTOS750/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 1655               	.LM197:
 1656 06de 4217      		cp r20,r18
 1657 06e0 5307      		cpc r21,r19
 1658 06e2 00F4      		brsh .L115
 712:../freeRTOS750/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 1660               	.LM198:
 1661 06e4 C217      		cp r28,r18
 1662 06e6 D307      		cpc r29,r19
 1663 06e8 00F4      		brsh .L121
 712:../freeRTOS750/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 1665               	.LM199:
 1666 06ea 81E0      		ldi r24,lo8(1)
 1667 06ec 00C0      		rjmp .L128
 1668               	.L115:
 724:../freeRTOS750/tasks.c **** 					xShouldDelay = pdTRUE;
 1670               	.LM200:
 1671 06ee 81E0      		ldi r24,lo8(1)
 722:../freeRTOS750/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 1673               	.LM201:
 1674 06f0 C217      		cp r28,r18
 1675 06f2 D307      		cpc r29,r19
 1676 06f4 00F0      		brlo .L116
 1677               	.L128:
 722:../freeRTOS750/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 1679               	.LM202:
 1680 06f6 4C17      		cp r20,r28
 1681 06f8 5D07      		cpc r21,r29
 1682 06fa 00F0      		brlo .L116
 1683               	.L121:
 691:../freeRTOS750/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 1685               	.LM203:
 1686 06fc 80E0      		ldi r24,0
 1687               	.L116:
 729:../freeRTOS750/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 1689               	.LM204:
 1690 06fe F801      		movw r30,r16
 1691 0700 D183      		std Z+1,r29
 1692 0702 C083      		st Z,r28
 731:../freeRTOS750/tasks.c **** 			if( xShouldDelay != pdFALSE )
 1694               	.LM205:
 1695 0704 8823      		tst r24
 1696 0706 01F0      		breq .L119
 738:../freeRTOS750/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 1698               	.LM206:
 1699 0708 8091 0000 		lds r24,pxCurrentTCB
 1700 070c 9091 0000 		lds r25,pxCurrentTCB+1
 1701 0710 0296      		adiw r24,2
 1702 0712 0E94 0000 		call uxListRemove
 746:../freeRTOS750/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1704               	.LM207:
 1705 0716 CE01      		movw r24,r28
 1706 0718 0E94 0000 		call prvAddCurrentTaskToDelayedList
 1707               	.L119:
 1708               	.LBE40:
 749:../freeRTOS750/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 1710               	.LM208:
 1711 071c 0E94 0000 		call xTaskResumeAll
 753:../freeRTOS750/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1713               	.LM209:
 1714 0720 8111      		cpse r24,__zero_reg__
 1715 0722 00C0      		rjmp .L114
 755:../freeRTOS750/tasks.c **** 			portYIELD_WITHIN_API();
 1717               	.LM210:
 1718 0724 0E94 0000 		call vPortYield
 1719               	.L114:
 1720               	/* epilogue start */
 757:../freeRTOS750/tasks.c **** 	}
 1722               	.LM211:
 1723 0728 DF91      		pop r29
 1724 072a CF91      		pop r28
 1725 072c 1F91      		pop r17
 1726 072e 0F91      		pop r16
 1727 0730 0895      		ret
 1736               	.Lscope14:
 1738               		.stabd	78,0,0
 1740               	.global	vTaskSwitchContext
 1742               	vTaskSwitchContext:
 1743               		.stabd	46,0,0
1794:../freeRTOS750/tasks.c **** {
 1745               	.LM212:
 1746               	.LFBB15:
 1747               	/* prologue: function */
 1748               	/* frame size = 0 */
 1749               	/* stack size = 0 */
 1750               	.L__stack_usage = 0
1795:../freeRTOS750/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 1752               	.LM213:
 1753 0732 8091 0000 		lds r24,uxSchedulerSuspended
 1754 0736 8823      		tst r24
 1755 0738 01F0      		breq .L130
1799:../freeRTOS750/tasks.c **** 		xYieldPending = pdTRUE;
 1757               	.LM214:
 1758 073a 81E0      		ldi r24,lo8(1)
 1759 073c 8093 0000 		sts xYieldPending,r24
 1760 0740 0895      		ret
 1761               	.L132:
1831:../freeRTOS750/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1763               	.LM215:
 1764 0742 8091 0000 		lds r24,uxTopReadyPriority
 1765 0746 8150      		subi r24,lo8(-(-1))
 1766 0748 8093 0000 		sts uxTopReadyPriority,r24
 1767 074c 00C0      		rjmp .L136
 1768               	.L130:
1831:../freeRTOS750/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1770               	.LM216:
 1771 074e 99E0      		ldi r25,lo8(9)
 1772               	.L136:
 1773 0750 E091 0000 		lds r30,uxTopReadyPriority
 1774 0754 9E9F      		mul r25,r30
 1775 0756 F001      		movw r30,r0
 1776 0758 1124      		clr __zero_reg__
 1777 075a E050      		subi r30,lo8(-(pxReadyTasksLists))
 1778 075c F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1779 075e 8081      		ld r24,Z
 1780 0760 8823      		tst r24
 1781 0762 01F0      		breq .L132
 1782               	.LBB41:
1831:../freeRTOS750/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1784               	.LM217:
 1785 0764 E091 0000 		lds r30,uxTopReadyPriority
 1786 0768 89E0      		ldi r24,lo8(9)
 1787 076a E89F      		mul r30,r24
 1788 076c F001      		movw r30,r0
 1789 076e 1124      		clr __zero_reg__
 1790 0770 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1791 0772 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1792 0774 A181      		ldd r26,Z+1
 1793 0776 B281      		ldd r27,Z+2
 1794 0778 1296      		adiw r26,2
 1795 077a 0D90      		ld __tmp_reg__,X+
 1796 077c BC91      		ld r27,X
 1797 077e A02D      		mov r26,__tmp_reg__
 1798 0780 B283      		std Z+2,r27
 1799 0782 A183      		std Z+1,r26
 1800 0784 CF01      		movw r24,r30
 1801 0786 0396      		adiw r24,3
 1802 0788 A817      		cp r26,r24
 1803 078a B907      		cpc r27,r25
 1804 078c 01F4      		brne .L133
1831:../freeRTOS750/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1806               	.LM218:
 1807 078e 1296      		adiw r26,2
 1808 0790 8D91      		ld r24,X+
 1809 0792 9C91      		ld r25,X
 1810 0794 1397      		sbiw r26,2+1
 1811 0796 9283      		std Z+2,r25
 1812 0798 8183      		std Z+1,r24
 1813               	.L133:
1831:../freeRTOS750/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1815               	.LM219:
 1816 079a 0180      		ldd __tmp_reg__,Z+1
 1817 079c F281      		ldd r31,Z+2
 1818 079e E02D      		mov r30,__tmp_reg__
 1819 07a0 8681      		ldd r24,Z+6
 1820 07a2 9781      		ldd r25,Z+7
 1821 07a4 9093 0000 		sts pxCurrentTCB+1,r25
 1822 07a8 8093 0000 		sts pxCurrentTCB,r24
 1823 07ac 0895      		ret
 1824               	.LBE41:
 1829               	.Lscope15:
 1831               		.stabd	78,0,0
 1835               	.global	vTaskPlaceOnEventList
 1837               	vTaskPlaceOnEventList:
 1838               		.stabd	46,0,0
1847:../freeRTOS750/tasks.c **** {
 1840               	.LM220:
 1841               	.LFBB16:
 1842 07ae CF93      		push r28
 1843 07b0 DF93      		push r29
 1844               	/* prologue: function */
 1845               	/* frame size = 0 */
 1846               	/* stack size = 2 */
 1847               	.L__stack_usage = 2
 1848 07b2 EB01      		movw r28,r22
1858:../freeRTOS750/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 1850               	.LM221:
 1851 07b4 6091 0000 		lds r22,pxCurrentTCB
 1852 07b8 7091 0000 		lds r23,pxCurrentTCB+1
 1853 07bc 645F      		subi r22,-12
 1854 07be 7F4F      		sbci r23,-1
 1855 07c0 0E94 0000 		call vListInsert
1863:../freeRTOS750/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 1857               	.LM222:
 1858 07c4 8091 0000 		lds r24,pxCurrentTCB
 1859 07c8 9091 0000 		lds r25,pxCurrentTCB+1
 1860 07cc 0296      		adiw r24,2
 1861 07ce 0E94 0000 		call uxListRemove
1891:../freeRTOS750/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 1863               	.LM223:
 1864 07d2 8091 0000 		lds r24,xTickCount
 1865 07d6 9091 0000 		lds r25,xTickCount+1
1892:../freeRTOS750/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 1867               	.LM224:
 1868 07da 8C0F      		add r24,r28
 1869 07dc 9D1F      		adc r25,r29
 1870               	/* epilogue start */
1895:../freeRTOS750/tasks.c **** }
 1872               	.LM225:
 1873 07de DF91      		pop r29
 1874 07e0 CF91      		pop r28
1892:../freeRTOS750/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 1876               	.LM226:
 1877 07e2 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 1879               	.Lscope16:
 1881               		.stabd	78,0,0
 1884               	.global	xTaskRemoveFromEventList
 1886               	xTaskRemoveFromEventList:
 1887               		.stabd	46,0,0
1940:../freeRTOS750/tasks.c **** {
 1889               	.LM227:
 1890               	.LFBB17:
 1891 07e6 0F93      		push r16
 1892 07e8 1F93      		push r17
 1893 07ea CF93      		push r28
 1894 07ec DF93      		push r29
 1895               	/* prologue: function */
 1896               	/* frame size = 0 */
 1897               	/* stack size = 4 */
 1898               	.L__stack_usage = 4
1957:../freeRTOS750/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 1900               	.LM228:
 1901 07ee DC01      		movw r26,r24
 1902 07f0 1596      		adiw r26,5
 1903 07f2 ED91      		ld r30,X+
 1904 07f4 FC91      		ld r31,X
 1905 07f6 1697      		sbiw r26,5+1
 1906 07f8 C681      		ldd r28,Z+6
 1907 07fa D781      		ldd r29,Z+7
1959:../freeRTOS750/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 1909               	.LM229:
 1910 07fc 8E01      		movw r16,r28
 1911 07fe 045F      		subi r16,-12
 1912 0800 1F4F      		sbci r17,-1
 1913 0802 C801      		movw r24,r16
 1914 0804 0E94 0000 		call uxListRemove
1961:../freeRTOS750/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1916               	.LM230:
 1917 0808 8091 0000 		lds r24,uxSchedulerSuspended
 1918 080c 8111      		cpse r24,__zero_reg__
 1919 080e 00C0      		rjmp .L139
1963:../freeRTOS750/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 1921               	.LM231:
 1922 0810 8E01      		movw r16,r28
 1923 0812 0E5F      		subi r16,-2
 1924 0814 1F4F      		sbci r17,-1
 1925 0816 C801      		movw r24,r16
 1926 0818 0E94 0000 		call uxListRemove
1964:../freeRTOS750/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 1928               	.LM232:
 1929 081c 8E89      		ldd r24,Y+22
 1930 081e 9091 0000 		lds r25,uxTopReadyPriority
 1931 0822 9817      		cp r25,r24
 1932 0824 00F4      		brsh .L140
1964:../freeRTOS750/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 1934               	.LM233:
 1935 0826 8093 0000 		sts uxTopReadyPriority,r24
 1936               	.L140:
1964:../freeRTOS750/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 1938               	.LM234:
 1939 082a B9E0      		ldi r27,lo8(9)
 1940 082c 8B9F      		mul r24,r27
 1941 082e C001      		movw r24,r0
 1942 0830 1124      		clr __zero_reg__
 1943 0832 B801      		movw r22,r16
 1944 0834 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1945 0836 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1946 0838 00C0      		rjmp .L143
 1947               	.L139:
1970:../freeRTOS750/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 1949               	.LM235:
 1950 083a B801      		movw r22,r16
 1951 083c 80E0      		ldi r24,lo8(xPendingReadyList)
 1952 083e 90E0      		ldi r25,hi8(xPendingReadyList)
 1953               	.L143:
 1954 0840 0E94 0000 		call vListInsertEnd
1973:../freeRTOS750/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1956               	.LM236:
 1957 0844 E091 0000 		lds r30,pxCurrentTCB
 1958 0848 F091 0000 		lds r31,pxCurrentTCB+1
 1959 084c 81E0      		ldi r24,lo8(1)
 1960 084e 2E89      		ldd r18,Y+22
 1961 0850 9689      		ldd r25,Z+22
 1962 0852 2917      		cp r18,r25
 1963 0854 00F4      		brsh .L142
 1964 0856 80E0      		ldi r24,0
 1965               	.L142:
 1966               	/* epilogue start */
1987:../freeRTOS750/tasks.c **** }
 1968               	.LM237:
 1969 0858 DF91      		pop r29
 1970 085a CF91      		pop r28
 1971 085c 1F91      		pop r17
 1972 085e 0F91      		pop r16
 1973 0860 0895      		ret
 1978               	.Lscope17:
 1980               		.stabd	78,0,0
 1983               	.global	vTaskSetTimeOutState
 1985               	vTaskSetTimeOutState:
 1986               		.stabd	46,0,0
1991:../freeRTOS750/tasks.c **** {
 1988               	.LM238:
 1989               	.LFBB18:
 1990               	/* prologue: function */
 1991               	/* frame size = 0 */
 1992               	/* stack size = 0 */
 1993               	.L__stack_usage = 0
1993:../freeRTOS750/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 1995               	.LM239:
 1996 0862 2091 0000 		lds r18,xNumOfOverflows
 1997 0866 FC01      		movw r30,r24
 1998 0868 2083      		st Z,r18
1994:../freeRTOS750/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2000               	.LM240:
 2001 086a 2091 0000 		lds r18,xTickCount
 2002 086e 3091 0000 		lds r19,xTickCount+1
 2003 0872 3283      		std Z+2,r19
 2004 0874 2183      		std Z+1,r18
 2005 0876 0895      		ret
 2007               	.Lscope18:
 2009               		.stabd	78,0,0
 2013               	.global	xTaskCheckForTimeOut
 2015               	xTaskCheckForTimeOut:
 2016               		.stabd	46,0,0
1999:../freeRTOS750/tasks.c **** {
 2018               	.LM241:
 2019               	.LFBB19:
 2020               	/* prologue: function */
 2021               	/* frame size = 0 */
 2022               	/* stack size = 0 */
 2023               	.L__stack_usage = 0
2005:../freeRTOS750/tasks.c **** 	taskENTER_CRITICAL();
 2025               	.LM242:
 2026               	/* #APP */
 2027               	 ;  2005 "../freeRTOS750/tasks.c" 1
 2028 0878 0FB6      		in		__tmp_reg__, __SREG__
 2029               	 ;  0 "" 2
 2030               	 ;  2005 "../freeRTOS750/tasks.c" 1
 2031 087a F894      		cli
 2032               	 ;  0 "" 2
 2033               	 ;  2005 "../freeRTOS750/tasks.c" 1
 2034 087c 0F92      		push	__tmp_reg__
 2035               	 ;  0 "" 2
 2036               	/* #NOAPP */
 2037               	.LBB42:
2008:../freeRTOS750/tasks.c **** 		const portTickType xConstTickCount = xTickCount;
 2039               	.LM243:
 2040 087e 4091 0000 		lds r20,xTickCount
 2041 0882 5091 0000 		lds r21,xTickCount+1
2021:../freeRTOS750/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 2043               	.LM244:
 2044 0886 F091 0000 		lds r31,xNumOfOverflows
 2045 088a DC01      		movw r26,r24
 2046 088c EC91      		ld r30,X
 2047 088e 1196      		adiw r26,1
 2048 0890 2D91      		ld r18,X+
 2049 0892 3C91      		ld r19,X
 2050 0894 1297      		sbiw r26,1+1
 2051 0896 FE17      		cp r31,r30
 2052 0898 01F0      		breq .L146
2021:../freeRTOS750/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 2054               	.LM245:
 2055 089a 4217      		cp r20,r18
 2056 089c 5307      		cpc r21,r19
 2057 089e 00F4      		brsh .L149
 2058               	.L146:
2029:../freeRTOS750/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 2060               	.LM246:
 2061 08a0 DB01      		movw r26,r22
 2062 08a2 ED91      		ld r30,X+
 2063 08a4 FC91      		ld r31,X
 2064 08a6 DA01      		movw r26,r20
 2065 08a8 A21B      		sub r26,r18
 2066 08aa B30B      		sbc r27,r19
 2067 08ac AE17      		cp r26,r30
 2068 08ae BF07      		cpc r27,r31
 2069 08b0 00F4      		brsh .L149
2032:../freeRTOS750/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 2071               	.LM247:
 2072 08b2 241B      		sub r18,r20
 2073 08b4 350B      		sbc r19,r21
 2074 08b6 2E0F      		add r18,r30
 2075 08b8 3F1F      		adc r19,r31
 2076 08ba FB01      		movw r30,r22
 2077 08bc 3183      		std Z+1,r19
 2078 08be 2083      		st Z,r18
2033:../freeRTOS750/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2080               	.LM248:
 2081 08c0 0E94 0000 		call vTaskSetTimeOutState
2034:../freeRTOS750/tasks.c **** 			xReturn = pdFALSE;
 2083               	.LM249:
 2084 08c4 80E0      		ldi r24,0
 2085 08c6 00C0      		rjmp .L147
 2086               	.L149:
2027:../freeRTOS750/tasks.c **** 			xReturn = pdTRUE;
 2088               	.LM250:
 2089 08c8 81E0      		ldi r24,lo8(1)
 2090               	.L147:
 2091               	.LBE42:
2041:../freeRTOS750/tasks.c **** 	taskEXIT_CRITICAL();
 2093               	.LM251:
 2094               	/* #APP */
 2095               	 ;  2041 "../freeRTOS750/tasks.c" 1
 2096 08ca 0F90      		pop		__tmp_reg__
 2097               	 ;  0 "" 2
 2098               	 ;  2041 "../freeRTOS750/tasks.c" 1
 2099 08cc 0FBE      		out		__SREG__, __tmp_reg__
 2100               	 ;  0 "" 2
2044:../freeRTOS750/tasks.c **** }
 2102               	.LM252:
 2103               	/* #NOAPP */
 2104 08ce 0895      		ret
 2112               	.Lscope19:
 2114               		.stabd	78,0,0
 2116               	.global	vTaskMissedYield
 2118               	vTaskMissedYield:
 2119               		.stabd	46,0,0
2048:../freeRTOS750/tasks.c **** {
 2121               	.LM253:
 2122               	.LFBB20:
 2123               	/* prologue: function */
 2124               	/* frame size = 0 */
 2125               	/* stack size = 0 */
 2126               	.L__stack_usage = 0
2049:../freeRTOS750/tasks.c **** 	xYieldPending = pdTRUE;
 2128               	.LM254:
 2129 08d0 81E0      		ldi r24,lo8(1)
 2130 08d2 8093 0000 		sts xYieldPending,r24
 2131 08d6 0895      		ret
 2133               	.Lscope20:
 2135               		.stabd	78,0,0
 2136               		.data
 2139               	xNextTaskUnblockTime:
 2140 0000 FFFF      		.word	-1
 2141               		.local	xNumOfOverflows
 2142               		.comm	xNumOfOverflows,1,1
 2143               		.local	xYieldPending
 2144               		.comm	xYieldPending,1,1
 2145               		.local	uxPendedTicks
 2146               		.comm	uxPendedTicks,1,1
 2147               		.local	uxSchedulerSuspended
 2148               		.comm	uxSchedulerSuspended,1,1
 2149               		.local	xSchedulerRunning
 2150               		.comm	xSchedulerRunning,1,1
 2151               		.local	uxTopReadyPriority
 2152               		.comm	uxTopReadyPriority,1,1
 2153               		.local	xTickCount
 2154               		.comm	xTickCount,2,1
 2155               		.local	uxCurrentNumberOfTasks
 2156               		.comm	uxCurrentNumberOfTasks,1,1
 2157               		.local	uxTasksDeleted
 2158               		.comm	uxTasksDeleted,1,1
 2159               		.local	pxOverflowDelayedTaskList
 2160               		.comm	pxOverflowDelayedTaskList,2,1
 2161               		.local	pxDelayedTaskList
 2162               		.comm	pxDelayedTaskList,2,1
 2163               	.global	pxCurrentTCB
 2164               		.section .bss
 2167               	pxCurrentTCB:
 2168 0000 0000      		.zero	2
 2169               		.local	uxTaskNumber
 2170               		.comm	uxTaskNumber,1,1
 2171               		.local	pxReadyTasksLists
 2172               		.comm	pxReadyTasksLists,36,1
 2173               		.local	xDelayedTaskList1
 2174               		.comm	xDelayedTaskList1,9,1
 2175               		.local	xDelayedTaskList2
 2176               		.comm	xDelayedTaskList2,9,1
 2177               		.local	xPendingReadyList
 2178               		.comm	xPendingReadyList,9,1
 2179               		.local	xTasksWaitingTermination
 2180               		.comm	xTasksWaitingTermination,9,1
 2200               		.text
 2202               	.Letext0:
 2203               		.ident	"GCC: (GNU) 4.7.2"
 2204               	.global __do_copy_data
 2205               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccsqhmTR.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccsqhmTR.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccsqhmTR.s:4      *ABS*:0000003f __SREG__
     /tmp/ccsqhmTR.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccsqhmTR.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccsqhmTR.s:127    .text:00000000 prvAddCurrentTaskToDelayedList
     /tmp/ccsqhmTR.s:2167   .bss:00000000 pxCurrentTCB
     /tmp/ccsqhmTR.s:2152   .bss:00000008 xTickCount
     /tmp/ccsqhmTR.s:2158   .bss:0000000c pxOverflowDelayedTaskList
     /tmp/ccsqhmTR.s:2160   .bss:0000000e pxDelayedTaskList
     /tmp/ccsqhmTR.s:2139   .data:00000000 xNextTaskUnblockTime
     /tmp/ccsqhmTR.s:224    .text:00000068 xTaskGenericCreate
     /tmp/ccsqhmTR.s:2154   .bss:0000000a uxCurrentNumberOfTasks
     /tmp/ccsqhmTR.s:2170   .bss:00000011 pxReadyTasksLists
     /tmp/ccsqhmTR.s:2172   .bss:00000035 xDelayedTaskList1
     /tmp/ccsqhmTR.s:2174   .bss:0000003e xDelayedTaskList2
     /tmp/ccsqhmTR.s:2176   .bss:00000047 xPendingReadyList
     /tmp/ccsqhmTR.s:2178   .bss:00000050 xTasksWaitingTermination
     /tmp/ccsqhmTR.s:2148   .bss:00000006 xSchedulerRunning
     /tmp/ccsqhmTR.s:2162   .bss:00000010 uxTaskNumber
     /tmp/ccsqhmTR.s:2150   .bss:00000007 uxTopReadyPriority
     /tmp/ccsqhmTR.s:620    .text:00000274 vTaskDelete
     /tmp/ccsqhmTR.s:2156   .bss:0000000b uxTasksDeleted
     /tmp/ccsqhmTR.s:743    .text:000002f4 vTaskStartScheduler
     /tmp/ccsqhmTR.s:1432   .text:00000606 prvIdleTask
     /tmp/ccsqhmTR.s:827    .text:00000358 vTaskEndScheduler
     /tmp/ccsqhmTR.s:856    .text:00000362 vTaskSuspendAll
     /tmp/ccsqhmTR.s:2146   .bss:00000005 uxSchedulerSuspended
     /tmp/ccsqhmTR.s:878    .text:0000036e xTaskGetTickCount
     /tmp/ccsqhmTR.s:928    .text:00000384 xTaskGetTickCountFromISR
     /tmp/ccsqhmTR.s:955    .text:00000390 uxTaskGetNumberOfTasks
     /tmp/ccsqhmTR.s:977    .text:00000396 xTaskIncrementTick
                             .bss:00000002 xNumOfOverflows
     /tmp/ccsqhmTR.s:2144   .bss:00000004 uxPendedTicks
     /tmp/ccsqhmTR.s:1234   .text:0000051e xTaskResumeAll
     /tmp/ccsqhmTR.s:2142   .bss:00000003 xYieldPending
     /tmp/ccsqhmTR.s:1553   .text:00000672 vTaskDelay
     /tmp/ccsqhmTR.s:1624   .text:000006bc vTaskDelayUntil
     /tmp/ccsqhmTR.s:1742   .text:00000732 vTaskSwitchContext
     /tmp/ccsqhmTR.s:1837   .text:000007ae vTaskPlaceOnEventList
     /tmp/ccsqhmTR.s:1886   .text:000007e6 xTaskRemoveFromEventList
     /tmp/ccsqhmTR.s:1985   .text:00000862 vTaskSetTimeOutState
     /tmp/ccsqhmTR.s:2015   .text:00000878 xTaskCheckForTimeOut
     /tmp/ccsqhmTR.s:2118   .text:000008d0 vTaskMissedYield

UNDEFINED SYMBOLS
vListInsert
pvPortMalloc
vPortFree
memset
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vListInsertEnd
vPortYield
uxListRemove
xPortStartScheduler
vPortEndScheduler
vApplicationIdleHook
__do_copy_data
__do_clear_bss
