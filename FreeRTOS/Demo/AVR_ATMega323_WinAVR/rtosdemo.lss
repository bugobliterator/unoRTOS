
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004a  00800100  000022d2  00002366  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000022d2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000067b  0080014a  0080014a  000023b0  2**0
                  ALLOC
  3 .stab         0000753c  00000000  00000000  000023b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002fd2  00000000  00000000  000098ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000c8be  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 cc 0e 	jmp	0x1d98	; 0x1d98 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e2 ed       	ldi	r30, 0xD2	; 210
      7c:	f2 e2       	ldi	r31, 0x22	; 34
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	aa 34       	cpi	r26, 0x4A	; 74
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	17 e0       	ldi	r17, 0x07	; 7
      8c:	aa e4       	ldi	r26, 0x4A	; 74
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a5 3c       	cpi	r26, 0xC5	; 197
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 cc 10 	call	0x2198	; 0x2198 <main>
      9e:	0c 94 67 11 	jmp	0x22ce	; 0x22ce <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vTask1>:

void vTask1( void *pvParameters );
void vTask2( void *pvParameters );
void vApplicationIdleHook( void );
void vTask1( void *pvParameters )
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <vTask1+0x6>
      ac:	00 d0       	rcall	.+0      	; 0xae <vTask1+0x8>
      ae:	cd b7       	in	r28, 0x3d	; 61
      b0:	de b7       	in	r29, 0x3e	; 62
	/* As per most tasks, this task is implemented in an infinite loop. */
	for( ;; )
	{
		/* Print out the name of this task. */
		//vPrintString( pcTaskName );
		for( ul = 0; ul < 10000; ul++ )
      b2:	19 82       	std	Y+1, r1	; 0x01
      b4:	1a 82       	std	Y+2, r1	; 0x02
      b6:	1b 82       	std	Y+3, r1	; 0x03
      b8:	1c 82       	std	Y+4, r1	; 0x04
      ba:	0b c0       	rjmp	.+22     	; 0xd2 <vTask1+0x2c>
      bc:	89 81       	ldd	r24, Y+1	; 0x01
      be:	9a 81       	ldd	r25, Y+2	; 0x02
      c0:	ab 81       	ldd	r26, Y+3	; 0x03
      c2:	bc 81       	ldd	r27, Y+4	; 0x04
      c4:	01 96       	adiw	r24, 0x01	; 1
      c6:	a1 1d       	adc	r26, r1
      c8:	b1 1d       	adc	r27, r1
      ca:	89 83       	std	Y+1, r24	; 0x01
      cc:	9a 83       	std	Y+2, r25	; 0x02
      ce:	ab 83       	std	Y+3, r26	; 0x03
      d0:	bc 83       	std	Y+4, r27	; 0x04
      d2:	89 81       	ldd	r24, Y+1	; 0x01
      d4:	9a 81       	ldd	r25, Y+2	; 0x02
      d6:	ab 81       	ldd	r26, Y+3	; 0x03
      d8:	bc 81       	ldd	r27, Y+4	; 0x04
      da:	80 31       	cpi	r24, 0x10	; 16
      dc:	97 42       	sbci	r25, 0x27	; 39
      de:	a1 05       	cpc	r26, r1
      e0:	b1 05       	cpc	r27, r1
      e2:	60 f3       	brcs	.-40     	; 0xbc <vTask1+0x16>
      e4:	e6 cf       	rjmp	.-52     	; 0xb2 <vTask1+0xc>

000000e6 <vTask2>:
		}

	}
}
void vTask2( void *pvParameters )
{
      e6:	cf 93       	push	r28
      e8:	df 93       	push	r29
      ea:	00 d0       	rcall	.+0      	; 0xec <vTask2+0x6>
      ec:	00 d0       	rcall	.+0      	; 0xee <vTask2+0x8>
      ee:	cd b7       	in	r28, 0x3d	; 61
      f0:	de b7       	in	r29, 0x3e	; 62
	const char *pcTaskName = "Task 2 is running\n";
	volatile unsigned long ul,i;
	DDRB = 0xFF;
      f2:	8f ef       	ldi	r24, 0xFF	; 255
      f4:	84 b9       	out	0x04, r24	; 4
		/* Define pull-ups and set outputs high */
		/* Define directions for port pins */
			
			PORTB = 0x00;
			for(i=0;i<10000;i++);
			PORTB = 0xFF;
      f6:	2f ef       	ldi	r18, 0xFF	; 255
	for( ;; )
	{
		/* Define pull-ups and set outputs high */
		/* Define directions for port pins */
			
			PORTB = 0x00;
      f8:	15 b8       	out	0x05, r1	; 5
			for(i=0;i<10000;i++);
      fa:	19 82       	std	Y+1, r1	; 0x01
      fc:	1a 82       	std	Y+2, r1	; 0x02
      fe:	1b 82       	std	Y+3, r1	; 0x03
     100:	1c 82       	std	Y+4, r1	; 0x04
     102:	0b c0       	rjmp	.+22     	; 0x11a <vTask2+0x34>
     104:	89 81       	ldd	r24, Y+1	; 0x01
     106:	9a 81       	ldd	r25, Y+2	; 0x02
     108:	ab 81       	ldd	r26, Y+3	; 0x03
     10a:	bc 81       	ldd	r27, Y+4	; 0x04
     10c:	01 96       	adiw	r24, 0x01	; 1
     10e:	a1 1d       	adc	r26, r1
     110:	b1 1d       	adc	r27, r1
     112:	89 83       	std	Y+1, r24	; 0x01
     114:	9a 83       	std	Y+2, r25	; 0x02
     116:	ab 83       	std	Y+3, r26	; 0x03
     118:	bc 83       	std	Y+4, r27	; 0x04
     11a:	89 81       	ldd	r24, Y+1	; 0x01
     11c:	9a 81       	ldd	r25, Y+2	; 0x02
     11e:	ab 81       	ldd	r26, Y+3	; 0x03
     120:	bc 81       	ldd	r27, Y+4	; 0x04
     122:	80 31       	cpi	r24, 0x10	; 16
     124:	97 42       	sbci	r25, 0x27	; 39
     126:	a1 05       	cpc	r26, r1
     128:	b1 05       	cpc	r27, r1
     12a:	60 f3       	brcs	.-40     	; 0x104 <vTask2+0x1e>
			PORTB = 0xFF;
     12c:	25 b9       	out	0x05, r18	; 5
			for(i=0;i<10000;i++);
     12e:	19 82       	std	Y+1, r1	; 0x01
     130:	1a 82       	std	Y+2, r1	; 0x02
     132:	1b 82       	std	Y+3, r1	; 0x03
     134:	1c 82       	std	Y+4, r1	; 0x04
     136:	0b c0       	rjmp	.+22     	; 0x14e <vTask2+0x68>
     138:	89 81       	ldd	r24, Y+1	; 0x01
     13a:	9a 81       	ldd	r25, Y+2	; 0x02
     13c:	ab 81       	ldd	r26, Y+3	; 0x03
     13e:	bc 81       	ldd	r27, Y+4	; 0x04
     140:	01 96       	adiw	r24, 0x01	; 1
     142:	a1 1d       	adc	r26, r1
     144:	b1 1d       	adc	r27, r1
     146:	89 83       	std	Y+1, r24	; 0x01
     148:	9a 83       	std	Y+2, r25	; 0x02
     14a:	ab 83       	std	Y+3, r26	; 0x03
     14c:	bc 83       	std	Y+4, r27	; 0x04
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	9a 81       	ldd	r25, Y+2	; 0x02
     152:	ab 81       	ldd	r26, Y+3	; 0x03
     154:	bc 81       	ldd	r27, Y+4	; 0x04
     156:	80 31       	cpi	r24, 0x10	; 16
     158:	97 42       	sbci	r25, 0x27	; 39
     15a:	a1 05       	cpc	r26, r1
     15c:	b1 05       	cpc	r27, r1
     15e:	60 f3       	brcs	.-40     	; 0x138 <vTask2+0x52>
     160:	cb cf       	rjmp	.-106    	; 0xf8 <vTask2+0x12>

00000162 <vApplicationIdleHook>:
	}
}
void vApplicationIdleHook( void )
{
	vCoRoutineSchedule();
     162:	0c 94 01 0c 	jmp	0x1802	; 0x1802 <vCoRoutineSchedule>

00000166 <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     166:	8f ef       	ldi	r24, 0xFF	; 255
     168:	80 93 00 01 	sts	0x0100, r24

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstALL_BITS_OUTPUT;
     16c:	84 b9       	out	0x04, r24	; 4
	PORTB = ucCurrentOutputValue;
     16e:	80 91 00 01 	lds	r24, 0x0100
     172:	85 b9       	out	0x05, r24	; 5
     174:	08 95       	ret

00000176 <vParTestSetLED>:
}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     176:	cf 93       	push	r28
     178:	df 93       	push	r29
     17a:	00 d0       	rcall	.+0      	; 0x17c <vParTestSetLED+0x6>
     17c:	cd b7       	in	r28, 0x3d	; 61
     17e:	de b7       	in	r29, 0x3e	; 62
unsigned char ucBit = ( unsigned char ) 1;

	if( uxLED <= partstMAX_OUTPUT_LED )
     180:	88 30       	cpi	r24, 0x08	; 8
     182:	08 f5       	brcc	.+66     	; 0x1c6 <vParTestSetLED+0x50>
	{
		ucBit <<= uxLED;	
     184:	21 e0       	ldi	r18, 0x01	; 1
     186:	30 e0       	ldi	r19, 0x00	; 0
     188:	01 c0       	rjmp	.+2      	; 0x18c <vParTestSetLED+0x16>
     18a:	22 0f       	add	r18, r18
     18c:	8a 95       	dec	r24
     18e:	ea f7       	brpl	.-6      	; 0x18a <vParTestSetLED+0x14>

		vTaskSuspendAll();
     190:	29 83       	std	Y+1, r18	; 0x01
     192:	6a 83       	std	Y+2, r22	; 0x02
     194:	0e 94 31 04 	call	0x862	; 0x862 <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
     198:	6a 81       	ldd	r22, Y+2	; 0x02
     19a:	29 81       	ldd	r18, Y+1	; 0x01
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     19c:	80 91 00 01 	lds	r24, 0x0100
	{
		ucBit <<= uxLED;	

		vTaskSuspendAll();
		{
			if( xValue == pdTRUE )
     1a0:	61 30       	cpi	r22, 0x01	; 1
     1a2:	29 f4       	brne	.+10     	; 0x1ae <vParTestSetLED+0x38>
			{
				ucBit ^= ( unsigned char ) 0xff;
     1a4:	20 95       	com	r18
				ucCurrentOutputValue &= ucBit;
     1a6:	28 23       	and	r18, r24
     1a8:	20 93 00 01 	sts	0x0100, r18
     1ac:	03 c0       	rjmp	.+6      	; 0x1b4 <vParTestSetLED+0x3e>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     1ae:	82 2b       	or	r24, r18
     1b0:	80 93 00 01 	sts	0x0100, r24
			}

			PORTB = ucCurrentOutputValue;
     1b4:	80 91 00 01 	lds	r24, 0x0100
     1b8:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();
	}
}
     1ba:	0f 90       	pop	r0
     1bc:	0f 90       	pop	r0
     1be:	df 91       	pop	r29
     1c0:	cf 91       	pop	r28
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();
     1c2:	0c 94 15 05 	jmp	0xa2a	; 0xa2a <xTaskResumeAll>
	}
}
     1c6:	0f 90       	pop	r0
     1c8:	0f 90       	pop	r0
     1ca:	df 91       	pop	r29
     1cc:	cf 91       	pop	r28
     1ce:	08 95       	ret

000001d0 <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     1d0:	cf 93       	push	r28
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
     1d2:	88 30       	cpi	r24, 0x08	; 8
     1d4:	f8 f4       	brcc	.+62     	; 0x214 <vParTestToggleLED+0x44>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     1d6:	21 e0       	ldi	r18, 0x01	; 1
     1d8:	30 e0       	ldi	r19, 0x00	; 0
     1da:	01 c0       	rjmp	.+2      	; 0x1de <vParTestToggleLED+0xe>
     1dc:	22 0f       	add	r18, r18
     1de:	8a 95       	dec	r24
     1e0:	ea f7       	brpl	.-6      	; 0x1dc <vParTestToggleLED+0xc>
     1e2:	c2 2f       	mov	r28, r18

		vTaskSuspendAll();
     1e4:	0e 94 31 04 	call	0x862	; 0x862 <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
     1e8:	80 91 00 01 	lds	r24, 0x0100
     1ec:	8c 23       	and	r24, r28
     1ee:	39 f0       	breq	.+14     	; 0x1fe <vParTestToggleLED+0x2e>
			{
				ucCurrentOutputValue &= ~ucBit;
     1f0:	80 91 00 01 	lds	r24, 0x0100
     1f4:	c0 95       	com	r28
     1f6:	c8 23       	and	r28, r24
     1f8:	c0 93 00 01 	sts	0x0100, r28
     1fc:	05 c0       	rjmp	.+10     	; 0x208 <vParTestToggleLED+0x38>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     1fe:	80 91 00 01 	lds	r24, 0x0100
     202:	8c 2b       	or	r24, r28
     204:	80 93 00 01 	sts	0x0100, r24
			}

			PORTB = ucCurrentOutputValue;
     208:	80 91 00 01 	lds	r24, 0x0100
     20c:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();			
	}
}
     20e:	cf 91       	pop	r28
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();			
     210:	0c 94 15 05 	jmp	0xa2a	; 0xa2a <xTaskResumeAll>
	}
}
     214:	cf 91       	pop	r28
     216:	08 95       	ret

00000218 <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);		
     218:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     21a:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     21c:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     21e:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     220:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     222:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     224:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     226:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     228:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     22a:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     22c:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     22e:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     230:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     232:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     234:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     236:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     238:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     23a:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     23c:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     23e:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     240:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     242:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     244:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     246:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     248:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     24a:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     24c:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     24e:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     250:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     252:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     254:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     256:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     258:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     25a:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     25c:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     25e:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     260:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     262:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     264:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     266:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     268:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     26a:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     26c:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     26e:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     270:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     272:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     274:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     276:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	6"			);
     27a:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     27c:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     27e:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	7"			);
     282:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     284:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     286:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	8"			);
     28a:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     28c:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     28e:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	9"			);
     292:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     294:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     296:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	10"			);
     29a:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     29c:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     29e:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	11"			);
     2a2:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     2a4:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     2a6:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	12"			);
     2aa:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     2ac:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     2ae:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	13"			);
     2b2:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     2b4:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     2b6:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	14"			);
     2ba:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     2bc:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     2be:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	15"			);
     2c2:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     2c4:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     2c6:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	16"			);
     2ca:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     2cc:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     2ce:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	17"			);
     2d2:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     2d4:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     2d6:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	18"			);
     2da:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     2dc:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     2de:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	19"			);
     2e2:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     2e4:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     2e6:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	20"			);
     2ea:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     2ec:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     2ee:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	21"			);
     2f2:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     2f4:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     2f6:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	22"			);
     2fa:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     2fc:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     2fe:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	23"			);
     302:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     304:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     306:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	24"			);
     30a:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     30c:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     30e:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	25"			);
     312:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     314:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     316:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	26"			);
     31a:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     31c:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     31e:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	27"			);
     322:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     324:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     326:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	28"			);
     32a:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     32c:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     32e:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	29"			);
     332:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     334:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     336:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	30"			);
     33a:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     33c:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     33e:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	31"			);
     342:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     344:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     346:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	32"			);
     34a:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     34c:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     34e:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	33"			);
     352:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     354:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     356:	00 92 4a 01 	sts	0x014A, r0
     35a:	5e cf       	rjmp	.-324    	; 0x218 <prvRegisterCheck1>

0000035c <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);		
     35c:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     35e:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     360:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     362:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     364:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     366:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     368:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     36a:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     36c:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     36e:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     370:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     372:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     374:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     376:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     378:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     37a:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     37c:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     37e:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     380:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     382:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     384:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     386:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     388:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     38a:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     38c:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     38e:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     390:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     392:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     394:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     396:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     398:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     39a:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     39c:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     39e:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     3a0:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     3a2:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     3a4:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     3a6:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     3a8:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     3aa:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     3ac:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     3ae:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     3b0:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     3b2:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     3b4:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     3b6:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     3b8:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     3ba:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	2"			);
     3be:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     3c0:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     3c2:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	3"			);
     3c6:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     3c8:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     3ca:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	4"			);
     3ce:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     3d0:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     3d2:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	5"			);
     3d6:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     3d8:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     3da:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	6"			);
     3de:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     3e0:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     3e2:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	7"			);
     3e6:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     3e8:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     3ea:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	8"			);
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     3f0:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     3f2:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	9"			);
     3f6:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     3f8:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     3fa:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	10"			);
     3fe:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     400:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     402:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	11"			);
     406:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     408:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     40a:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	12"			);
     40e:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     410:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     412:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	13"			);
     416:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     418:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     41a:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	14"			);
     41e:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     420:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     422:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	15"			);
     426:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     428:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     42a:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	16"			);
     42e:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     430:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     432:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	17"			);
     436:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     438:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     43a:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	18"			);
     43e:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     440:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     442:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	19"			);
     446:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     448:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     44a:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	20"			);
     44e:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     450:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     452:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	21"			);
     456:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     458:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     45a:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	22"			);
     45e:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     460:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     462:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	23"			);
     466:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     468:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     46a:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	24"			);
     46e:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     470:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     472:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	25"			);
     476:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     478:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     47a:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	26"			);
     47e:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     480:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     482:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	27"			);
     486:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     488:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     48a:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	28"			);
     48e:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     490:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     492:	00 92 4a 01 	sts	0x014A, r0
		asm(	"LDI	r31,	29"			);
     496:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     498:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     49a:	00 92 4a 01 	sts	0x014A, r0
     49e:	5e cf       	rjmp	.-324    	; 0x35c <prvRegisterCheck2>

000004a0 <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     4a0:	af 92       	push	r10
     4a2:	bf 92       	push	r11
     4a4:	cf 92       	push	r12
     4a6:	df 92       	push	r13
     4a8:	ef 92       	push	r14
     4aa:	ff 92       	push	r15
     4ac:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, ( signed char * ) "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     4ae:	a1 2c       	mov	r10, r1
     4b0:	b1 2c       	mov	r11, r1
     4b2:	c1 2c       	mov	r12, r1
     4b4:	d1 2c       	mov	r13, r1
     4b6:	e1 2c       	mov	r14, r1
     4b8:	f1 2c       	mov	r15, r1
     4ba:	00 e0       	ldi	r16, 0x00	; 0
     4bc:	20 e0       	ldi	r18, 0x00	; 0
     4be:	30 e0       	ldi	r19, 0x00	; 0
     4c0:	45 e5       	ldi	r20, 0x55	; 85
     4c2:	50 e0       	ldi	r21, 0x00	; 0
     4c4:	62 e2       	ldi	r22, 0x22	; 34
     4c6:	71 e0       	ldi	r23, 0x01	; 1
     4c8:	8c e0       	ldi	r24, 0x0C	; 12
     4ca:	91 e0       	ldi	r25, 0x01	; 1
     4cc:	0e 94 b4 02 	call	0x568	; 0x568 <xTaskGenericCreate>
	xTaskCreate( prvRegisterCheck2, ( signed char * ) "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );		
     4d0:	20 e0       	ldi	r18, 0x00	; 0
     4d2:	30 e0       	ldi	r19, 0x00	; 0
     4d4:	45 e5       	ldi	r20, 0x55	; 85
     4d6:	50 e0       	ldi	r21, 0x00	; 0
     4d8:	67 e2       	ldi	r22, 0x27	; 39
     4da:	71 e0       	ldi	r23, 0x01	; 1
     4dc:	8e ea       	ldi	r24, 0xAE	; 174
     4de:	91 e0       	ldi	r25, 0x01	; 1
     4e0:	0e 94 b4 02 	call	0x568	; 0x568 <xTaskGenericCreate>
}
     4e4:	0f 91       	pop	r16
     4e6:	ff 90       	pop	r15
     4e8:	ef 90       	pop	r14
     4ea:	df 90       	pop	r13
     4ec:	cf 90       	pop	r12
     4ee:	bf 90       	pop	r11
     4f0:	af 90       	pop	r10
     4f2:	08 95       	ret

000004f4 <xAreRegTestTasksStillRunning>:
{
portBASE_TYPE xReturn;

	/* If a register was found to contain an unexpected value then the
	xRegTestError variable would have been set to a non zero value. */
	if( xRegTestError == pdFALSE )
     4f4:	81 e0       	ldi	r24, 0x01	; 1
     4f6:	90 91 4a 01 	lds	r25, 0x014A
     4fa:	91 11       	cpse	r25, r1
     4fc:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}
	
	return xReturn;
}
     4fe:	08 95       	ret

00000500 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
     500:	cf 93       	push	r28
     502:	df 93       	push	r29
     504:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     506:	e0 91 4b 01 	lds	r30, 0x014B
     50a:	f0 91 4c 01 	lds	r31, 0x014C
     50e:	93 83       	std	Z+3, r25	; 0x03
     510:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     512:	80 91 53 01 	lds	r24, 0x0153
     516:	90 91 54 01 	lds	r25, 0x0154
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     51a:	60 91 4b 01 	lds	r22, 0x014B
     51e:	70 91 4c 01 	lds	r23, 0x014C
static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
     522:	c8 17       	cp	r28, r24
     524:	d9 07       	cpc	r29, r25
     526:	50 f4       	brcc	.+20     	; 0x53c <prvAddCurrentTaskToDelayedList+0x3c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     528:	80 91 57 01 	lds	r24, 0x0157
     52c:	90 91 58 01 	lds	r25, 0x0158
     530:	6e 5f       	subi	r22, 0xFE	; 254
     532:	7f 4f       	sbci	r23, 0xFF	; 255
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
     534:	df 91       	pop	r29
     536:	cf 91       	pop	r28
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     538:	0c 94 ef 0a 	jmp	0x15de	; 0x15de <vListInsert>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     53c:	80 91 59 01 	lds	r24, 0x0159
     540:	90 91 5a 01 	lds	r25, 0x015A
     544:	6e 5f       	subi	r22, 0xFE	; 254
     546:	7f 4f       	sbci	r23, 0xFF	; 255
     548:	0e 94 ef 0a 	call	0x15de	; 0x15de <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     54c:	80 91 01 01 	lds	r24, 0x0101
     550:	90 91 02 01 	lds	r25, 0x0102
     554:	c8 17       	cp	r28, r24
     556:	d9 07       	cpc	r29, r25
     558:	20 f4       	brcc	.+8      	; 0x562 <prvAddCurrentTaskToDelayedList+0x62>
		{
			xNextTaskUnblockTime = xTimeToWake;
     55a:	d0 93 02 01 	sts	0x0102, r29
     55e:	c0 93 01 01 	sts	0x0101, r28
		}
	}
}
     562:	df 91       	pop	r29
     564:	cf 91       	pop	r28
     566:	08 95       	ret

00000568 <xTaskGenericCreate>:
	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     568:	3f 92       	push	r3
     56a:	4f 92       	push	r4
     56c:	5f 92       	push	r5
     56e:	6f 92       	push	r6
     570:	7f 92       	push	r7
     572:	8f 92       	push	r8
     574:	9f 92       	push	r9
     576:	af 92       	push	r10
     578:	bf 92       	push	r11
     57a:	cf 92       	push	r12
     57c:	df 92       	push	r13
     57e:	ef 92       	push	r14
     580:	ff 92       	push	r15
     582:	0f 93       	push	r16
     584:	1f 93       	push	r17
     586:	cf 93       	push	r28
     588:	df 93       	push	r29
     58a:	4c 01       	movw	r8, r24
     58c:	16 2f       	mov	r17, r22
     58e:	37 2e       	mov	r3, r23
     590:	5a 01       	movw	r10, r20
     592:	39 01       	movw	r6, r18
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
     594:	81 e2       	ldi	r24, 0x21	; 33
     596:	90 e0       	ldi	r25, 0x00	; 0
     598:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <pvPortMalloc>
     59c:	ec 01       	movw	r28, r24

	if( pxNewTCB != NULL )
     59e:	00 97       	sbiw	r24, 0x00	; 0
     5a0:	09 f4       	brne	.+2      	; 0x5a4 <xTaskGenericCreate+0x3c>
     5a2:	d5 c0       	rjmp	.+426    	; 0x74e <xTaskGenericCreate+0x1e6>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     5a4:	c1 14       	cp	r12, r1
     5a6:	d1 04       	cpc	r13, r1
     5a8:	21 f4       	brne	.+8      	; 0x5b2 <xTaskGenericCreate+0x4a>
     5aa:	c5 01       	movw	r24, r10
     5ac:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <pvPortMalloc>
     5b0:	6c 01       	movw	r12, r24
     5b2:	d8 8e       	std	Y+24, r13	; 0x18
     5b4:	cf 8a       	std	Y+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
     5b6:	c1 14       	cp	r12, r1
     5b8:	d1 04       	cpc	r13, r1
     5ba:	21 f4       	brne	.+8      	; 0x5c4 <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
     5bc:	ce 01       	movw	r24, r28
     5be:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <vPortFree>
     5c2:	c5 c0       	rjmp	.+394    	; 0x74e <xTaskGenericCreate+0x1e6>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
     5c4:	a5 01       	movw	r20, r10
     5c6:	65 ea       	ldi	r22, 0xA5	; 165
     5c8:	70 e0       	ldi	r23, 0x00	; 0
     5ca:	c6 01       	movw	r24, r12
     5cc:	0e 94 60 11 	call	0x22c0	; 0x22c0 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     5d0:	21 e0       	ldi	r18, 0x01	; 1
     5d2:	a2 1a       	sub	r10, r18
     5d4:	b1 08       	sbc	r11, r1
     5d6:	4f 88       	ldd	r4, Y+23	; 0x17
     5d8:	58 8c       	ldd	r5, Y+24	; 0x18
     5da:	4a 0c       	add	r4, r10
     5dc:	5b 1c       	adc	r5, r11
     5de:	e1 2f       	mov	r30, r17
     5e0:	f3 2d       	mov	r31, r3
     5e2:	80 e0       	ldi	r24, 0x00	; 0
     5e4:	90 e0       	ldi	r25, 0x00	; 0

	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
     5e6:	bf 01       	movw	r22, r30
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     5e8:	41 91       	ld	r20, Z+

	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
     5ea:	9e 01       	movw	r18, r28
     5ec:	28 0f       	add	r18, r24
     5ee:	39 1f       	adc	r19, r25
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     5f0:	d9 01       	movw	r26, r18
     5f2:	59 96       	adiw	r26, 0x19	; 25
     5f4:	4c 93       	st	X, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     5f6:	db 01       	movw	r26, r22
     5f8:	2c 91       	ld	r18, X
     5fa:	22 23       	and	r18, r18
     5fc:	21 f0       	breq	.+8      	; 0x606 <xTaskGenericCreate+0x9e>
     5fe:	01 96       	adiw	r24, 0x01	; 1
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
     600:	88 30       	cpi	r24, 0x08	; 8
     602:	91 05       	cpc	r25, r1
     604:	81 f7       	brne	.-32     	; 0x5e6 <xTaskGenericCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
     606:	18 a2       	std	Y+32, r1	; 0x20
     608:	10 2f       	mov	r17, r16
     60a:	04 30       	cpi	r16, 0x04	; 4
     60c:	08 f0       	brcs	.+2      	; 0x610 <xTaskGenericCreate+0xa8>
     60e:	13 e0       	ldi	r17, 0x03	; 3
	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
	{
		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
     610:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     612:	6e 01       	movw	r12, r28
     614:	b2 e0       	ldi	r27, 0x02	; 2
     616:	cb 0e       	add	r12, r27
     618:	d1 1c       	adc	r13, r1
     61a:	c6 01       	movw	r24, r12
     61c:	0e 94 ca 0a 	call	0x1594	; 0x1594 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     620:	ce 01       	movw	r24, r28
     622:	0c 96       	adiw	r24, 0x0c	; 12
     624:	0e 94 ca 0a 	call	0x1594	; 0x1594 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     628:	d9 87       	std	Y+9, r29	; 0x09
     62a:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     62c:	84 e0       	ldi	r24, 0x04	; 4
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	81 1b       	sub	r24, r17
     632:	91 09       	sbc	r25, r1
     634:	9d 87       	std	Y+13, r25	; 0x0d
     636:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     638:	db 8b       	std	Y+19, r29	; 0x13
     63a:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     63c:	a3 01       	movw	r20, r6
     63e:	b4 01       	movw	r22, r8
     640:	c2 01       	movw	r24, r4
     642:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <pxPortInitialiseStack>
     646:	99 83       	std	Y+1, r25	; 0x01
     648:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     64a:	e1 14       	cp	r14, r1
     64c:	f1 04       	cpc	r15, r1
     64e:	19 f0       	breq	.+6      	; 0x656 <xTaskGenericCreate+0xee>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     650:	f7 01       	movw	r30, r14
     652:	d1 83       	std	Z+1, r29	; 0x01
     654:	c0 83       	st	Z, r28
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     656:	0f b6       	in	r0, 0x3f	; 63
     658:	f8 94       	cli
     65a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     65c:	80 91 55 01 	lds	r24, 0x0155
     660:	8f 5f       	subi	r24, 0xFF	; 255
     662:	80 93 55 01 	sts	0x0155, r24
			if( pxCurrentTCB == NULL )
     666:	80 91 4b 01 	lds	r24, 0x014B
     66a:	90 91 4c 01 	lds	r25, 0x014C
     66e:	89 2b       	or	r24, r25
     670:	c9 f5       	brne	.+114    	; 0x6e4 <xTaskGenericCreate+0x17c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     672:	d0 93 4c 01 	sts	0x014C, r29
     676:	c0 93 4b 01 	sts	0x014B, r28

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     67a:	80 91 55 01 	lds	r24, 0x0155
     67e:	81 30       	cpi	r24, 0x01	; 1
     680:	09 f0       	breq	.+2      	; 0x684 <xTaskGenericCreate+0x11c>
     682:	3f c0       	rjmp	.+126    	; 0x702 <xTaskGenericCreate+0x19a>
     684:	e1 2c       	mov	r14, r1
     686:	f1 2c       	mov	r15, r1
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     688:	19 e0       	ldi	r17, 0x09	; 9
     68a:	1e 9d       	mul	r17, r14
     68c:	c0 01       	movw	r24, r0
     68e:	1f 9d       	mul	r17, r15
     690:	90 0d       	add	r25, r0
     692:	11 24       	eor	r1, r1
     694:	84 5a       	subi	r24, 0xA4	; 164
     696:	9e 4f       	sbci	r25, 0xFE	; 254
     698:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>
     69c:	ff ef       	ldi	r31, 0xFF	; 255
     69e:	ef 1a       	sub	r14, r31
     6a0:	ff 0a       	sbc	r15, r31

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
     6a2:	24 e0       	ldi	r18, 0x04	; 4
     6a4:	e2 16       	cp	r14, r18
     6a6:	f1 04       	cpc	r15, r1
     6a8:	81 f7       	brne	.-32     	; 0x68a <xTaskGenericCreate+0x122>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
     6aa:	80 e8       	ldi	r24, 0x80	; 128
     6ac:	91 e0       	ldi	r25, 0x01	; 1
     6ae:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     6b2:	89 e8       	ldi	r24, 0x89	; 137
     6b4:	91 e0       	ldi	r25, 0x01	; 1
     6b6:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     6ba:	82 e9       	ldi	r24, 0x92	; 146
     6bc:	91 e0       	ldi	r25, 0x01	; 1
     6be:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     6c2:	8b e9       	ldi	r24, 0x9B	; 155
     6c4:	91 e0       	ldi	r25, 0x01	; 1
     6c6:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     6ca:	80 e8       	ldi	r24, 0x80	; 128
     6cc:	91 e0       	ldi	r25, 0x01	; 1
     6ce:	90 93 5a 01 	sts	0x015A, r25
     6d2:	80 93 59 01 	sts	0x0159, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     6d6:	89 e8       	ldi	r24, 0x89	; 137
     6d8:	91 e0       	ldi	r25, 0x01	; 1
     6da:	90 93 58 01 	sts	0x0158, r25
     6de:	80 93 57 01 	sts	0x0157, r24
     6e2:	0f c0       	rjmp	.+30     	; 0x702 <xTaskGenericCreate+0x19a>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     6e4:	80 91 51 01 	lds	r24, 0x0151
     6e8:	81 11       	cpse	r24, r1
     6ea:	0b c0       	rjmp	.+22     	; 0x702 <xTaskGenericCreate+0x19a>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     6ec:	e0 91 4b 01 	lds	r30, 0x014B
     6f0:	f0 91 4c 01 	lds	r31, 0x014C
     6f4:	86 89       	ldd	r24, Z+22	; 0x16
     6f6:	08 17       	cp	r16, r24
     6f8:	20 f0       	brcs	.+8      	; 0x702 <xTaskGenericCreate+0x19a>
					{
						pxCurrentTCB = pxNewTCB;
     6fa:	d0 93 4c 01 	sts	0x014C, r29
     6fe:	c0 93 4b 01 	sts	0x014B, r28
					}
				}
			}

			uxTaskNumber++;
     702:	80 91 5b 01 	lds	r24, 0x015B
     706:	8f 5f       	subi	r24, 0xFF	; 255
     708:	80 93 5b 01 	sts	0x015B, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     70c:	8e 89       	ldd	r24, Y+22	; 0x16
     70e:	90 91 52 01 	lds	r25, 0x0152
     712:	98 17       	cp	r25, r24
     714:	10 f4       	brcc	.+4      	; 0x71a <xTaskGenericCreate+0x1b2>
     716:	80 93 52 01 	sts	0x0152, r24
     71a:	a9 e0       	ldi	r26, 0x09	; 9
     71c:	8a 9f       	mul	r24, r26
     71e:	c0 01       	movw	r24, r0
     720:	11 24       	eor	r1, r1
     722:	b6 01       	movw	r22, r12
     724:	84 5a       	subi	r24, 0xA4	; 164
     726:	9e 4f       	sbci	r25, 0xFE	; 254
     728:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     72c:	0f 90       	pop	r0
     72e:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     730:	80 91 51 01 	lds	r24, 0x0151
     734:	88 23       	and	r24, r24
     736:	49 f0       	breq	.+18     	; 0x74a <xTaskGenericCreate+0x1e2>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     738:	e0 91 4b 01 	lds	r30, 0x014B
     73c:	f0 91 4c 01 	lds	r31, 0x014C
     740:	86 89       	ldd	r24, Z+22	; 0x16
     742:	80 17       	cp	r24, r16
     744:	10 f4       	brcc	.+4      	; 0x74a <xTaskGenericCreate+0x1e2>
			{
				taskYIELD_IF_USING_PREEMPTION();
     746:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
     74a:	81 e0       	ldi	r24, 0x01	; 1
     74c:	01 c0       	rjmp	.+2      	; 0x750 <xTaskGenericCreate+0x1e8>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     74e:	8f ef       	ldi	r24, 0xFF	; 255
			}
		}
	}

	return xReturn;
}
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	1f 91       	pop	r17
     756:	0f 91       	pop	r16
     758:	ff 90       	pop	r15
     75a:	ef 90       	pop	r14
     75c:	df 90       	pop	r13
     75e:	cf 90       	pop	r12
     760:	bf 90       	pop	r11
     762:	af 90       	pop	r10
     764:	9f 90       	pop	r9
     766:	8f 90       	pop	r8
     768:	7f 90       	pop	r7
     76a:	6f 90       	pop	r6
     76c:	5f 90       	pop	r5
     76e:	4f 90       	pop	r4
     770:	3f 90       	pop	r3
     772:	08 95       	ret

00000774 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
     774:	0f 93       	push	r16
     776:	1f 93       	push	r17
     778:	cf 93       	push	r28
     77a:	df 93       	push	r29
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     77c:	0f b6       	in	r0, 0x3f	; 63
     77e:	f8 94       	cli
     780:	0f 92       	push	r0
		{
			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     782:	00 97       	sbiw	r24, 0x00	; 0
     784:	29 f4       	brne	.+10     	; 0x790 <vTaskDelete+0x1c>
     786:	c0 91 4b 01 	lds	r28, 0x014B
     78a:	d0 91 4c 01 	lds	r29, 0x014C
     78e:	01 c0       	rjmp	.+2      	; 0x792 <vTaskDelete+0x1e>
     790:	ec 01       	movw	r28, r24

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
     792:	8e 01       	movw	r16, r28
     794:	0e 5f       	subi	r16, 0xFE	; 254
     796:	1f 4f       	sbci	r17, 0xFF	; 255
     798:	c8 01       	movw	r24, r16
     79a:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     79e:	8c 89       	ldd	r24, Y+20	; 0x14
     7a0:	9d 89       	ldd	r25, Y+21	; 0x15
     7a2:	89 2b       	or	r24, r25
     7a4:	21 f0       	breq	.+8      	; 0x7ae <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     7a6:	ce 01       	movw	r24, r28
     7a8:	0c 96       	adiw	r24, 0x0c	; 12
     7aa:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
     7ae:	b8 01       	movw	r22, r16
     7b0:	8b e9       	ldi	r24, 0x9B	; 155
     7b2:	91 e0       	ldi	r25, 0x01	; 1
     7b4:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
     7b8:	80 91 56 01 	lds	r24, 0x0156
     7bc:	8f 5f       	subi	r24, 0xFF	; 255
     7be:	80 93 56 01 	sts	0x0156, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
     7c2:	80 91 5b 01 	lds	r24, 0x015B
     7c6:	8f 5f       	subi	r24, 0xFF	; 255
     7c8:	80 93 5b 01 	sts	0x015B, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     7cc:	0f 90       	pop	r0
     7ce:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
     7d0:	80 91 51 01 	lds	r24, 0x0151
     7d4:	88 23       	and	r24, r24
     7d6:	49 f0       	breq	.+18     	; 0x7ea <vTaskDelete+0x76>
		{
			if( pxTCB == pxCurrentTCB )
     7d8:	80 91 4b 01 	lds	r24, 0x014B
     7dc:	90 91 4c 01 	lds	r25, 0x014C
     7e0:	c8 17       	cp	r28, r24
     7e2:	d9 07       	cpc	r29, r25
     7e4:	11 f4       	brne	.+4      	; 0x7ea <vTaskDelete+0x76>
			{
				portYIELD_WITHIN_API();
     7e6:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>
			}
		}
	}
     7ea:	df 91       	pop	r29
     7ec:	cf 91       	pop	r28
     7ee:	1f 91       	pop	r17
     7f0:	0f 91       	pop	r16
     7f2:	08 95       	ret

000007f4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     7f4:	af 92       	push	r10
     7f6:	bf 92       	push	r11
     7f8:	cf 92       	push	r12
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     802:	a1 2c       	mov	r10, r1
     804:	b1 2c       	mov	r11, r1
     806:	c1 2c       	mov	r12, r1
     808:	d1 2c       	mov	r13, r1
     80a:	e1 2c       	mov	r14, r1
     80c:	f1 2c       	mov	r15, r1
     80e:	00 e0       	ldi	r16, 0x00	; 0
     810:	20 e0       	ldi	r18, 0x00	; 0
     812:	30 e0       	ldi	r19, 0x00	; 0
     814:	45 e5       	ldi	r20, 0x55	; 85
     816:	50 e0       	ldi	r21, 0x00	; 0
     818:	6c e2       	ldi	r22, 0x2C	; 44
     81a:	71 e0       	ldi	r23, 0x01	; 1
     81c:	87 e8       	ldi	r24, 0x87	; 135
     81e:	95 e0       	ldi	r25, 0x05	; 5
     820:	0e 94 b4 02 	call	0x568	; 0x568 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     824:	81 30       	cpi	r24, 0x01	; 1
     826:	81 f4       	brne	.+32     	; 0x848 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     828:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     82a:	80 93 51 01 	sts	0x0151, r24
		xTickCount = ( portTickType ) 0U;
     82e:	10 92 54 01 	sts	0x0154, r1
     832:	10 92 53 01 	sts	0x0153, r1
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     836:	0f 91       	pop	r16
     838:	ff 90       	pop	r15
     83a:	ef 90       	pop	r14
     83c:	df 90       	pop	r13
     83e:	cf 90       	pop	r12
     840:	bf 90       	pop	r11
     842:	af 90       	pop	r10
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     844:	0c 94 dc 0d 	jmp	0x1bb8	; 0x1bb8 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     848:	0f 91       	pop	r16
     84a:	ff 90       	pop	r15
     84c:	ef 90       	pop	r14
     84e:	df 90       	pop	r13
     850:	cf 90       	pop	r12
     852:	bf 90       	pop	r11
     854:	af 90       	pop	r10
     856:	08 95       	ret

00000858 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     858:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     85a:	10 92 51 01 	sts	0x0151, r1
	vPortEndScheduler();
     85e:	0c 94 16 0e 	jmp	0x1c2c	; 0x1c2c <vPortEndScheduler>

00000862 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     862:	80 91 50 01 	lds	r24, 0x0150
     866:	8f 5f       	subi	r24, 0xFF	; 255
     868:	80 93 50 01 	sts	0x0150, r24
     86c:	08 95       	ret

0000086e <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     86e:	0f b6       	in	r0, 0x3f	; 63
     870:	f8 94       	cli
     872:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     874:	20 91 53 01 	lds	r18, 0x0153
     878:	30 91 54 01 	lds	r19, 0x0154
	}
	taskEXIT_CRITICAL();
     87c:	0f 90       	pop	r0
     87e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     880:	c9 01       	movw	r24, r18
     882:	08 95       	ret

00000884 <xTaskGetTickCountFromISR>:
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
     884:	20 91 53 01 	lds	r18, 0x0153
     888:	30 91 54 01 	lds	r19, 0x0154
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     88c:	c9 01       	movw	r24, r18
     88e:	08 95       	ret

00000890 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     890:	80 91 55 01 	lds	r24, 0x0155
}
     894:	08 95       	ret

00000896 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

portBASE_TYPE xTaskIncrementTick( void )
{
     896:	cf 92       	push	r12
     898:	df 92       	push	r13
     89a:	ef 92       	push	r14
     89c:	ff 92       	push	r15
     89e:	0f 93       	push	r16
     8a0:	1f 93       	push	r17
     8a2:	cf 93       	push	r28
     8a4:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     8a6:	80 91 50 01 	lds	r24, 0x0150
     8aa:	81 11       	cpse	r24, r1
     8ac:	a5 c0       	rjmp	.+330    	; 0x9f8 <__stack+0xf9>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     8ae:	80 91 53 01 	lds	r24, 0x0153
     8b2:	90 91 54 01 	lds	r25, 0x0154
     8b6:	01 96       	adiw	r24, 0x01	; 1
     8b8:	90 93 54 01 	sts	0x0154, r25
     8bc:	80 93 53 01 	sts	0x0153, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
     8c0:	00 91 53 01 	lds	r16, 0x0153
     8c4:	10 91 54 01 	lds	r17, 0x0154

			if( xConstTickCount == ( portTickType ) 0U )
     8c8:	01 15       	cp	r16, r1
     8ca:	11 05       	cpc	r17, r1
     8cc:	79 f5       	brne	.+94     	; 0x92c <__stack+0x2d>
			{
				taskSWITCH_DELAYED_LISTS();
     8ce:	80 91 59 01 	lds	r24, 0x0159
     8d2:	90 91 5a 01 	lds	r25, 0x015A
     8d6:	20 91 57 01 	lds	r18, 0x0157
     8da:	30 91 58 01 	lds	r19, 0x0158
     8de:	30 93 5a 01 	sts	0x015A, r19
     8e2:	20 93 59 01 	sts	0x0159, r18
     8e6:	90 93 58 01 	sts	0x0158, r25
     8ea:	80 93 57 01 	sts	0x0157, r24
     8ee:	80 91 4d 01 	lds	r24, 0x014D
     8f2:	8f 5f       	subi	r24, 0xFF	; 255
     8f4:	80 93 4d 01 	sts	0x014D, r24
     8f8:	e0 91 59 01 	lds	r30, 0x0159
     8fc:	f0 91 5a 01 	lds	r31, 0x015A
     900:	80 81       	ld	r24, Z
     902:	81 11       	cpse	r24, r1
     904:	03 c0       	rjmp	.+6      	; 0x90c <__stack+0xd>
     906:	8f ef       	ldi	r24, 0xFF	; 255
     908:	9f ef       	ldi	r25, 0xFF	; 255
     90a:	0c c0       	rjmp	.+24     	; 0x924 <__stack+0x25>
     90c:	e0 91 59 01 	lds	r30, 0x0159
     910:	f0 91 5a 01 	lds	r31, 0x015A
     914:	05 80       	ldd	r0, Z+5	; 0x05
     916:	f6 81       	ldd	r31, Z+6	; 0x06
     918:	e0 2d       	mov	r30, r0
     91a:	06 80       	ldd	r0, Z+6	; 0x06
     91c:	f7 81       	ldd	r31, Z+7	; 0x07
     91e:	e0 2d       	mov	r30, r0
     920:	82 81       	ldd	r24, Z+2	; 0x02
     922:	93 81       	ldd	r25, Z+3	; 0x03
     924:	90 93 02 01 	sts	0x0102, r25
     928:	80 93 01 01 	sts	0x0101, r24

			/* See if this tick has made a timeout expire.  Tasks are stored in the
			queue in the order of their wake time - meaning once one tasks has been
			found whose block time has not expired there is no need not look any
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     92c:	80 91 01 01 	lds	r24, 0x0101
     930:	90 91 02 01 	lds	r25, 0x0102
     934:	d1 2c       	mov	r13, r1
     936:	08 17       	cp	r16, r24
     938:	19 07       	cpc	r17, r25
     93a:	20 f4       	brcc	.+8      	; 0x944 <__stack+0x45>
     93c:	4e c0       	rjmp	.+156    	; 0x9da <__stack+0xdb>
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     93e:	dd 24       	eor	r13, r13
     940:	d3 94       	inc	r13
     942:	02 c0       	rjmp	.+4      	; 0x948 <__stack+0x49>
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     944:	89 e0       	ldi	r24, 0x09	; 9
     946:	c8 2e       	mov	r12, r24
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     948:	e0 91 59 01 	lds	r30, 0x0159
     94c:	f0 91 5a 01 	lds	r31, 0x015A
     950:	80 81       	ld	r24, Z
     952:	81 11       	cpse	r24, r1
     954:	07 c0       	rjmp	.+14     	; 0x964 <__stack+0x65>
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     956:	8f ef       	ldi	r24, 0xFF	; 255
     958:	9f ef       	ldi	r25, 0xFF	; 255
     95a:	90 93 02 01 	sts	0x0102, r25
     95e:	80 93 01 01 	sts	0x0101, r24
						break;
     962:	3b c0       	rjmp	.+118    	; 0x9da <__stack+0xdb>
					{
						/* The delayed list is not empty, get the value of the item
						at the head of the delayed list.  This is the time at which
						the task at the head of the delayed list must be removed
						from the Blocked state. */
						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     964:	e0 91 59 01 	lds	r30, 0x0159
     968:	f0 91 5a 01 	lds	r31, 0x015A
     96c:	05 80       	ldd	r0, Z+5	; 0x05
     96e:	f6 81       	ldd	r31, Z+6	; 0x06
     970:	e0 2d       	mov	r30, r0
     972:	c6 81       	ldd	r28, Z+6	; 0x06
     974:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     976:	2a 81       	ldd	r18, Y+2	; 0x02
     978:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     97a:	02 17       	cp	r16, r18
     97c:	13 07       	cpc	r17, r19
     97e:	28 f4       	brcc	.+10     	; 0x98a <__stack+0x8b>
						{
							/* It is not time to unblock this item yet, but the item
							value is the time at which the task at the head of the
							blocked list must be removed from the Blocked state -
							so record the item value in xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     980:	30 93 02 01 	sts	0x0102, r19
     984:	20 93 01 01 	sts	0x0101, r18
							break;
     988:	28 c0       	rjmp	.+80     	; 0x9da <__stack+0xdb>
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     98a:	7e 01       	movw	r14, r28
     98c:	82 e0       	ldi	r24, 0x02	; 2
     98e:	e8 0e       	add	r14, r24
     990:	f1 1c       	adc	r15, r1
     992:	c7 01       	movw	r24, r14
     994:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>

						/* Is the task waiting on an event also?  If so remove it
						from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     998:	2c 89       	ldd	r18, Y+20	; 0x14
     99a:	3d 89       	ldd	r19, Y+21	; 0x15
     99c:	23 2b       	or	r18, r19
     99e:	21 f0       	breq	.+8      	; 0x9a8 <__stack+0xa9>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     9a0:	ce 01       	movw	r24, r28
     9a2:	0c 96       	adiw	r24, 0x0c	; 12
     9a4:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     9a8:	2e 89       	ldd	r18, Y+22	; 0x16
     9aa:	80 91 52 01 	lds	r24, 0x0152
     9ae:	82 17       	cp	r24, r18
     9b0:	10 f4       	brcc	.+4      	; 0x9b6 <__stack+0xb7>
     9b2:	20 93 52 01 	sts	0x0152, r18
     9b6:	c2 9e       	mul	r12, r18
     9b8:	c0 01       	movw	r24, r0
     9ba:	11 24       	eor	r1, r1
     9bc:	b7 01       	movw	r22, r14
     9be:	84 5a       	subi	r24, 0xA4	; 164
     9c0:	9e 4f       	sbci	r25, 0xFE	; 254
     9c2:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should only
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     9c6:	e0 91 4b 01 	lds	r30, 0x014B
     9ca:	f0 91 4c 01 	lds	r31, 0x014C
     9ce:	9e 89       	ldd	r25, Y+22	; 0x16
     9d0:	86 89       	ldd	r24, Z+22	; 0x16
     9d2:	98 17       	cp	r25, r24
     9d4:	08 f0       	brcs	.+2      	; 0x9d8 <__stack+0xd9>
     9d6:	b3 cf       	rjmp	.-154    	; 0x93e <__stack+0x3f>
     9d8:	b7 cf       	rjmp	.-146    	; 0x948 <__stack+0x49>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
     9da:	e0 91 4b 01 	lds	r30, 0x014B
     9de:	f0 91 4c 01 	lds	r31, 0x014C
     9e2:	e6 89       	ldd	r30, Z+22	; 0x16
     9e4:	89 e0       	ldi	r24, 0x09	; 9
     9e6:	e8 9f       	mul	r30, r24
     9e8:	f0 01       	movw	r30, r0
     9ea:	11 24       	eor	r1, r1
     9ec:	e4 5a       	subi	r30, 0xA4	; 164
     9ee:	fe 4f       	sbci	r31, 0xFE	; 254
     9f0:	80 81       	ld	r24, Z
     9f2:	82 30       	cpi	r24, 0x02	; 2
     9f4:	40 f4       	brcc	.+16     	; 0xa06 <__stack+0x107>
     9f6:	09 c0       	rjmp	.+18     	; 0xa0a <__stack+0x10b>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     9f8:	80 91 4f 01 	lds	r24, 0x014F
     9fc:	8f 5f       	subi	r24, 0xFF	; 255
     9fe:	80 93 4f 01 	sts	0x014F, r24

portBASE_TYPE xTaskIncrementTick( void )
{
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
     a02:	d1 2c       	mov	r13, r1
     a04:	02 c0       	rjmp	.+4      	; 0xa0a <__stack+0x10b>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
			{
				xSwitchRequired = pdTRUE;
     a06:	dd 24       	eor	r13, r13
     a08:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     a0a:	80 91 4e 01 	lds	r24, 0x014E
     a0e:	88 23       	and	r24, r24
     a10:	11 f0       	breq	.+4      	; 0xa16 <__stack+0x117>
		{
			xSwitchRequired = pdTRUE;
     a12:	dd 24       	eor	r13, r13
     a14:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     a16:	8d 2d       	mov	r24, r13
     a18:	df 91       	pop	r29
     a1a:	cf 91       	pop	r28
     a1c:	1f 91       	pop	r17
     a1e:	0f 91       	pop	r16
     a20:	ff 90       	pop	r15
     a22:	ef 90       	pop	r14
     a24:	df 90       	pop	r13
     a26:	cf 90       	pop	r12
     a28:	08 95       	ret

00000a2a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     a2a:	ef 92       	push	r14
     a2c:	ff 92       	push	r15
     a2e:	0f 93       	push	r16
     a30:	1f 93       	push	r17
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     a36:	0f b6       	in	r0, 0x3f	; 63
     a38:	f8 94       	cli
     a3a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     a3c:	80 91 50 01 	lds	r24, 0x0150
     a40:	81 50       	subi	r24, 0x01	; 1
     a42:	80 93 50 01 	sts	0x0150, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     a46:	80 91 50 01 	lds	r24, 0x0150
     a4a:	88 23       	and	r24, r24
     a4c:	11 f0       	breq	.+4      	; 0xa52 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;
     a4e:	80 e0       	ldi	r24, 0x00	; 0
     a50:	55 c0       	rjmp	.+170    	; 0xafc <xTaskResumeAll+0xd2>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     a52:	80 91 55 01 	lds	r24, 0x0155
     a56:	81 11       	cpse	r24, r1
     a58:	2b c0       	rjmp	.+86     	; 0xab0 <xTaskResumeAll+0x86>
     a5a:	f9 cf       	rjmp	.-14     	; 0xa4e <xTaskResumeAll+0x24>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     a5c:	e0 91 97 01 	lds	r30, 0x0197
     a60:	f0 91 98 01 	lds	r31, 0x0198
     a64:	c6 81       	ldd	r28, Z+6	; 0x06
     a66:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     a68:	ce 01       	movw	r24, r28
     a6a:	0c 96       	adiw	r24, 0x0c	; 12
     a6c:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     a70:	8e 01       	movw	r16, r28
     a72:	0e 5f       	subi	r16, 0xFE	; 254
     a74:	1f 4f       	sbci	r17, 0xFF	; 255
     a76:	c8 01       	movw	r24, r16
     a78:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     a7c:	8e 89       	ldd	r24, Y+22	; 0x16
     a7e:	90 91 52 01 	lds	r25, 0x0152
     a82:	98 17       	cp	r25, r24
     a84:	10 f4       	brcc	.+4      	; 0xa8a <xTaskResumeAll+0x60>
     a86:	80 93 52 01 	sts	0x0152, r24
     a8a:	f8 9e       	mul	r15, r24
     a8c:	c0 01       	movw	r24, r0
     a8e:	11 24       	eor	r1, r1
     a90:	b8 01       	movw	r22, r16
     a92:	84 5a       	subi	r24, 0xA4	; 164
     a94:	9e 4f       	sbci	r25, 0xFE	; 254
     a96:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     a9a:	e0 91 4b 01 	lds	r30, 0x014B
     a9e:	f0 91 4c 01 	lds	r31, 0x014C
     aa2:	9e 89       	ldd	r25, Y+22	; 0x16
     aa4:	86 89       	ldd	r24, Z+22	; 0x16
     aa6:	98 17       	cp	r25, r24
     aa8:	38 f0       	brcs	.+14     	; 0xab8 <xTaskResumeAll+0x8e>
					{
						xYieldPending = pdTRUE;
     aaa:	e0 92 4e 01 	sts	0x014E, r14
     aae:	04 c0       	rjmp	.+8      	; 0xab8 <xTaskResumeAll+0x8e>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
     ab0:	99 e0       	ldi	r25, 0x09	; 9
     ab2:	f9 2e       	mov	r15, r25

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     ab4:	ee 24       	eor	r14, r14
     ab6:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     ab8:	80 91 92 01 	lds	r24, 0x0192
     abc:	81 11       	cpse	r24, r1
     abe:	ce cf       	rjmp	.-100    	; 0xa5c <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
     ac0:	80 91 4f 01 	lds	r24, 0x014F
     ac4:	81 11       	cpse	r24, r1
     ac6:	11 c0       	rjmp	.+34     	; 0xaea <xTaskResumeAll+0xc0>
						}
						--uxPendedTicks;
					}
				}

				if( xYieldPending == pdTRUE )
     ac8:	80 91 4e 01 	lds	r24, 0x014E
     acc:	81 30       	cpi	r24, 0x01	; 1
     ace:	09 f0       	breq	.+2      	; 0xad2 <xTaskResumeAll+0xa8>
     ad0:	be cf       	rjmp	.-132    	; 0xa4e <xTaskResumeAll+0x24>
     ad2:	11 c0       	rjmp	.+34     	; 0xaf6 <xTaskResumeAll+0xcc>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     ad4:	0e 94 4b 04 	call	0x896	; 0x896 <xTaskIncrementTick>
     ad8:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     ada:	c0 93 4e 01 	sts	0x014E, r28
						}
						--uxPendedTicks;
     ade:	80 91 4f 01 	lds	r24, 0x014F
     ae2:	81 50       	subi	r24, 0x01	; 1
     ae4:	80 93 4f 01 	sts	0x014F, r24
     ae8:	01 c0       	rjmp	.+2      	; 0xaec <xTaskResumeAll+0xc2>
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     aea:	c1 e0       	ldi	r28, 0x01	; 1
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
     aec:	80 91 4f 01 	lds	r24, 0x014F
     af0:	81 11       	cpse	r24, r1
     af2:	f0 cf       	rjmp	.-32     	; 0xad4 <xTaskResumeAll+0xaa>
     af4:	e9 cf       	rjmp	.-46     	; 0xac8 <xTaskResumeAll+0x9e>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     af6:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     afa:	81 e0       	ldi	r24, 0x01	; 1
					taskYIELD_IF_USING_PREEMPTION();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     afc:	0f 90       	pop	r0
     afe:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     b00:	df 91       	pop	r29
     b02:	cf 91       	pop	r28
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	ff 90       	pop	r15
     b0a:	ef 90       	pop	r14
     b0c:	08 95       	ret

00000b0e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
     b0e:	28 c0       	rjmp	.+80     	; 0xb60 <prvIdleTask+0x52>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
     b10:	0e 94 31 04 	call	0x862	; 0x862 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     b14:	c0 91 9b 01 	lds	r28, 0x019B
			( void ) xTaskResumeAll();
     b18:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     b1c:	cc 23       	and	r28, r28
     b1e:	01 f1       	breq	.+64     	; 0xb60 <prvIdleTask+0x52>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
     b20:	0f b6       	in	r0, 0x3f	; 63
     b22:	f8 94       	cli
     b24:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     b26:	e0 91 a0 01 	lds	r30, 0x01A0
     b2a:	f0 91 a1 01 	lds	r31, 0x01A1
     b2e:	c6 81       	ldd	r28, Z+6	; 0x06
     b30:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     b32:	ce 01       	movw	r24, r28
     b34:	02 96       	adiw	r24, 0x02	; 2
     b36:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
					--uxCurrentNumberOfTasks;
     b3a:	80 91 55 01 	lds	r24, 0x0155
     b3e:	81 50       	subi	r24, 0x01	; 1
     b40:	80 93 55 01 	sts	0x0155, r24
					--uxTasksDeleted;
     b44:	80 91 56 01 	lds	r24, 0x0156
     b48:	81 50       	subi	r24, 0x01	; 1
     b4a:	80 93 56 01 	sts	0x0156, r24
				}
				taskEXIT_CRITICAL();
     b4e:	0f 90       	pop	r0
     b50:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
     b52:	8f 89       	ldd	r24, Y+23	; 0x17
     b54:	98 8d       	ldd	r25, Y+24	; 0x18
     b56:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <vPortFree>
		vPortFree( pxTCB );
     b5a:	ce 01       	movw	r24, r28
     b5c:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <vPortFree>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
     b60:	80 91 56 01 	lds	r24, 0x0156
     b64:	81 11       	cpse	r24, r1
     b66:	d4 cf       	rjmp	.-88     	; 0xb10 <prvIdleTask+0x2>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
     b68:	80 91 5c 01 	lds	r24, 0x015C
     b6c:	82 30       	cpi	r24, 0x02	; 2
     b6e:	10 f0       	brcs	.+4      	; 0xb74 <prvIdleTask+0x66>
			{
				taskYIELD();
     b70:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     b74:	0e 94 b1 00 	call	0x162	; 0x162 <vApplicationIdleHook>
				}
				( void ) xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     b78:	f3 cf       	rjmp	.-26     	; 0xb60 <prvIdleTask+0x52>

00000b7a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     b7a:	0f 93       	push	r16
     b7c:	1f 93       	push	r17
     b7e:	cf 93       	push	r28
     b80:	df 93       	push	r29
     b82:	8c 01       	movw	r16, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     b84:	00 97       	sbiw	r24, 0x00	; 0
     b86:	19 f4       	brne	.+6      	; 0xb8e <vTaskDelay+0x14>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     b88:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>
     b8c:	16 c0       	rjmp	.+44     	; 0xbba <vTaskDelay+0x40>
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
		{
			vTaskSuspendAll();
     b8e:	0e 94 31 04 	call	0x862	; 0x862 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     b92:	c0 91 53 01 	lds	r28, 0x0153
     b96:	d0 91 54 01 	lds	r29, 0x0154
     b9a:	c0 0f       	add	r28, r16
     b9c:	d1 1f       	adc	r29, r17

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
     b9e:	80 91 4b 01 	lds	r24, 0x014B
     ba2:	90 91 4c 01 	lds	r25, 0x014C
     ba6:	02 96       	adiw	r24, 0x02	; 2
     ba8:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     bac:	ce 01       	movw	r24, r28
     bae:	0e 94 80 02 	call	0x500	; 0x500 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     bb2:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     bb6:	88 23       	and	r24, r24
     bb8:	39 f3       	breq	.-50     	; 0xb88 <vTaskDelay+0xe>
		{
			portYIELD_WITHIN_API();
		}
	}
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	1f 91       	pop	r17
     bc0:	0f 91       	pop	r16
     bc2:	08 95       	ret

00000bc4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     bc4:	0f 93       	push	r16
     bc6:	1f 93       	push	r17
     bc8:	cf 93       	push	r28
     bca:	df 93       	push	r29
     bcc:	8c 01       	movw	r16, r24
     bce:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     bd0:	0e 94 31 04 	call	0x862	; 0x862 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
     bd4:	40 91 53 01 	lds	r20, 0x0153
     bd8:	50 91 54 01 	lds	r21, 0x0154

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     bdc:	f8 01       	movw	r30, r16
     bde:	20 81       	ld	r18, Z
     be0:	31 81       	ldd	r19, Z+1	; 0x01
     be2:	c2 0f       	add	r28, r18
     be4:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
     be6:	42 17       	cp	r20, r18
     be8:	53 07       	cpc	r21, r19
     bea:	28 f4       	brcc	.+10     	; 0xbf6 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     bec:	c2 17       	cp	r28, r18
     bee:	d3 07       	cpc	r29, r19
     bf0:	48 f4       	brcc	.+18     	; 0xc04 <vTaskDelayUntil+0x40>
     bf2:	81 e0       	ldi	r24, 0x01	; 1
     bf4:	04 c0       	rjmp	.+8      	; 0xbfe <vTaskDelayUntil+0x3a>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     bf6:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     bf8:	c2 17       	cp	r28, r18
     bfa:	d3 07       	cpc	r29, r19
     bfc:	20 f0       	brcs	.+8      	; 0xc06 <vTaskDelayUntil+0x42>
     bfe:	4c 17       	cp	r20, r28
     c00:	5d 07       	cpc	r21, r29
     c02:	08 f0       	brcs	.+2      	; 0xc06 <vTaskDelayUntil+0x42>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
     c04:	80 e0       	ldi	r24, 0x00	; 0
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     c06:	f8 01       	movw	r30, r16
     c08:	d1 83       	std	Z+1, r29	; 0x01
     c0a:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
     c0c:	88 23       	and	r24, r24
     c0e:	51 f0       	breq	.+20     	; 0xc24 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
     c10:	80 91 4b 01 	lds	r24, 0x014B
     c14:	90 91 4c 01 	lds	r25, 0x014C
     c18:	02 96       	adiw	r24, 0x02	; 2
     c1a:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     c1e:	ce 01       	movw	r24, r28
     c20:	0e 94 80 02 	call	0x500	; 0x500 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     c24:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     c28:	81 11       	cpse	r24, r1
     c2a:	02 c0       	rjmp	.+4      	; 0xc30 <vTaskDelayUntil+0x6c>
		{
			portYIELD_WITHIN_API();
     c2c:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>
		}
	}
     c30:	df 91       	pop	r29
     c32:	cf 91       	pop	r28
     c34:	1f 91       	pop	r17
     c36:	0f 91       	pop	r16
     c38:	08 95       	ret

00000c3a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     c3a:	80 91 50 01 	lds	r24, 0x0150
     c3e:	88 23       	and	r24, r24
     c40:	21 f0       	breq	.+8      	; 0xc4a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     c42:	81 e0       	ldi	r24, 0x01	; 1
     c44:	80 93 4e 01 	sts	0x014E, r24
     c48:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     c4a:	10 92 4e 01 	sts	0x014E, r1
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
     c4e:	99 e0       	ldi	r25, 0x09	; 9
     c50:	05 c0       	rjmp	.+10     	; 0xc5c <vTaskSwitchContext+0x22>
     c52:	80 91 52 01 	lds	r24, 0x0152
     c56:	81 50       	subi	r24, 0x01	; 1
     c58:	80 93 52 01 	sts	0x0152, r24
     c5c:	e0 91 52 01 	lds	r30, 0x0152
     c60:	9e 9f       	mul	r25, r30
     c62:	f0 01       	movw	r30, r0
     c64:	11 24       	eor	r1, r1
     c66:	e4 5a       	subi	r30, 0xA4	; 164
     c68:	fe 4f       	sbci	r31, 0xFE	; 254
     c6a:	80 81       	ld	r24, Z
     c6c:	88 23       	and	r24, r24
     c6e:	89 f3       	breq	.-30     	; 0xc52 <vTaskSwitchContext+0x18>
     c70:	e0 91 52 01 	lds	r30, 0x0152
     c74:	89 e0       	ldi	r24, 0x09	; 9
     c76:	e8 9f       	mul	r30, r24
     c78:	f0 01       	movw	r30, r0
     c7a:	11 24       	eor	r1, r1
     c7c:	e4 5a       	subi	r30, 0xA4	; 164
     c7e:	fe 4f       	sbci	r31, 0xFE	; 254
     c80:	a1 81       	ldd	r26, Z+1	; 0x01
     c82:	b2 81       	ldd	r27, Z+2	; 0x02
     c84:	12 96       	adiw	r26, 0x02	; 2
     c86:	0d 90       	ld	r0, X+
     c88:	bc 91       	ld	r27, X
     c8a:	a0 2d       	mov	r26, r0
     c8c:	b2 83       	std	Z+2, r27	; 0x02
     c8e:	a1 83       	std	Z+1, r26	; 0x01
     c90:	cf 01       	movw	r24, r30
     c92:	03 96       	adiw	r24, 0x03	; 3
     c94:	a8 17       	cp	r26, r24
     c96:	b9 07       	cpc	r27, r25
     c98:	31 f4       	brne	.+12     	; 0xca6 <vTaskSwitchContext+0x6c>
     c9a:	12 96       	adiw	r26, 0x02	; 2
     c9c:	8d 91       	ld	r24, X+
     c9e:	9c 91       	ld	r25, X
     ca0:	13 97       	sbiw	r26, 0x03	; 3
     ca2:	92 83       	std	Z+2, r25	; 0x02
     ca4:	81 83       	std	Z+1, r24	; 0x01
     ca6:	01 80       	ldd	r0, Z+1	; 0x01
     ca8:	f2 81       	ldd	r31, Z+2	; 0x02
     caa:	e0 2d       	mov	r30, r0
     cac:	86 81       	ldd	r24, Z+6	; 0x06
     cae:	97 81       	ldd	r25, Z+7	; 0x07
     cb0:	90 93 4c 01 	sts	0x014C, r25
     cb4:	80 93 4b 01 	sts	0x014B, r24
     cb8:	08 95       	ret

00000cba <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29
     cbe:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     cc0:	60 91 4b 01 	lds	r22, 0x014B
     cc4:	70 91 4c 01 	lds	r23, 0x014C
     cc8:	64 5f       	subi	r22, 0xF4	; 244
     cca:	7f 4f       	sbci	r23, 0xFF	; 255
     ccc:	0e 94 ef 0a 	call	0x15de	; 0x15de <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
     cd0:	80 91 4b 01 	lds	r24, 0x014B
     cd4:	90 91 4c 01 	lds	r25, 0x014C
     cd8:	02 96       	adiw	r24, 0x02	; 2
     cda:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
	}
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
     cde:	80 91 53 01 	lds	r24, 0x0153
     ce2:	90 91 54 01 	lds	r25, 0x0154
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     ce6:	8c 0f       	add	r24, r28
     ce8:	9d 1f       	adc	r25, r29
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     cea:	df 91       	pop	r29
     cec:	cf 91       	pop	r28
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     cee:	0c 94 80 02 	jmp	0x500	; 0x500 <prvAddCurrentTaskToDelayedList>

00000cf2 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     cf2:	0f 93       	push	r16
     cf4:	1f 93       	push	r17
     cf6:	cf 93       	push	r28
     cf8:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     cfa:	dc 01       	movw	r26, r24
     cfc:	15 96       	adiw	r26, 0x05	; 5
     cfe:	ed 91       	ld	r30, X+
     d00:	fc 91       	ld	r31, X
     d02:	16 97       	sbiw	r26, 0x06	; 6
     d04:	c6 81       	ldd	r28, Z+6	; 0x06
     d06:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     d08:	8e 01       	movw	r16, r28
     d0a:	04 5f       	subi	r16, 0xF4	; 244
     d0c:	1f 4f       	sbci	r17, 0xFF	; 255
     d0e:	c8 01       	movw	r24, r16
     d10:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     d14:	80 91 50 01 	lds	r24, 0x0150
     d18:	81 11       	cpse	r24, r1
     d1a:	15 c0       	rjmp	.+42     	; 0xd46 <xTaskRemoveFromEventList+0x54>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
     d1c:	8e 01       	movw	r16, r28
     d1e:	0e 5f       	subi	r16, 0xFE	; 254
     d20:	1f 4f       	sbci	r17, 0xFF	; 255
     d22:	c8 01       	movw	r24, r16
     d24:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     d28:	8e 89       	ldd	r24, Y+22	; 0x16
     d2a:	90 91 52 01 	lds	r25, 0x0152
     d2e:	98 17       	cp	r25, r24
     d30:	10 f4       	brcc	.+4      	; 0xd36 <xTaskRemoveFromEventList+0x44>
     d32:	80 93 52 01 	sts	0x0152, r24
     d36:	b9 e0       	ldi	r27, 0x09	; 9
     d38:	8b 9f       	mul	r24, r27
     d3a:	c0 01       	movw	r24, r0
     d3c:	11 24       	eor	r1, r1
     d3e:	b8 01       	movw	r22, r16
     d40:	84 5a       	subi	r24, 0xA4	; 164
     d42:	9e 4f       	sbci	r25, 0xFE	; 254
     d44:	03 c0       	rjmp	.+6      	; 0xd4c <xTaskRemoveFromEventList+0x5a>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     d46:	b8 01       	movw	r22, r16
     d48:	82 e9       	ldi	r24, 0x92	; 146
     d4a:	91 e0       	ldi	r25, 0x01	; 1
     d4c:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
     d50:	e0 91 4b 01 	lds	r30, 0x014B
     d54:	f0 91 4c 01 	lds	r31, 0x014C
     d58:	9e 89       	ldd	r25, Y+22	; 0x16
     d5a:	86 89       	ldd	r24, Z+22	; 0x16
     d5c:	98 17       	cp	r25, r24
     d5e:	20 f0       	brcs	.+8      	; 0xd68 <xTaskRemoveFromEventList+0x76>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     d60:	81 e0       	ldi	r24, 0x01	; 1
     d62:	80 93 4e 01 	sts	0x014E, r24
     d66:	01 c0       	rjmp	.+2      	; 0xd6a <xTaskRemoveFromEventList+0x78>
	}
	else
	{
		xReturn = pdFALSE;
     d68:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
     d6a:	df 91       	pop	r29
     d6c:	cf 91       	pop	r28
     d6e:	1f 91       	pop	r17
     d70:	0f 91       	pop	r16
     d72:	08 95       	ret

00000d74 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     d74:	20 91 4d 01 	lds	r18, 0x014D
     d78:	fc 01       	movw	r30, r24
     d7a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     d7c:	20 91 53 01 	lds	r18, 0x0153
     d80:	30 91 54 01 	lds	r19, 0x0154
     d84:	32 83       	std	Z+2, r19	; 0x02
     d86:	21 83       	std	Z+1, r18	; 0x01
     d88:	08 95       	ret

00000d8a <xTaskCheckForTimeOut>:
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     d8a:	0f b6       	in	r0, 0x3f	; 63
     d8c:	f8 94       	cli
     d8e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
     d90:	40 91 53 01 	lds	r20, 0x0153
     d94:	50 91 54 01 	lds	r21, 0x0154
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     d98:	f0 91 4d 01 	lds	r31, 0x014D
     d9c:	dc 01       	movw	r26, r24
     d9e:	ec 91       	ld	r30, X
     da0:	11 96       	adiw	r26, 0x01	; 1
     da2:	2d 91       	ld	r18, X+
     da4:	3c 91       	ld	r19, X
     da6:	12 97       	sbiw	r26, 0x02	; 2
     da8:	fe 17       	cp	r31, r30
     daa:	19 f0       	breq	.+6      	; 0xdb2 <xTaskCheckForTimeOut+0x28>
     dac:	42 17       	cp	r20, r18
     dae:	53 07       	cpc	r21, r19
     db0:	a0 f4       	brcc	.+40     	; 0xdda <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
     db2:	db 01       	movw	r26, r22
     db4:	ed 91       	ld	r30, X+
     db6:	fc 91       	ld	r31, X
     db8:	da 01       	movw	r26, r20
     dba:	a2 1b       	sub	r26, r18
     dbc:	b3 0b       	sbc	r27, r19
     dbe:	ae 17       	cp	r26, r30
     dc0:	bf 07       	cpc	r27, r31
     dc2:	58 f4       	brcc	.+22     	; 0xdda <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
     dc4:	24 1b       	sub	r18, r20
     dc6:	35 0b       	sbc	r19, r21
     dc8:	2e 0f       	add	r18, r30
     dca:	3f 1f       	adc	r19, r31
     dcc:	fb 01       	movw	r30, r22
     dce:	31 83       	std	Z+1, r19	; 0x01
     dd0:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
     dd2:	0e 94 ba 06 	call	0xd74	; 0xd74 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
     dd6:	80 e0       	ldi	r24, 0x00	; 0
     dd8:	01 c0       	rjmp	.+2      	; 0xddc <xTaskCheckForTimeOut+0x52>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
     dda:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     ddc:	0f 90       	pop	r0
     dde:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     de0:	08 95       	ret

00000de2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	80 93 4e 01 	sts	0x014E, r24
     de8:	08 95       	ret

00000dea <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     dea:	1f 93       	push	r17
     dec:	cf 93       	push	r28
     dee:	df 93       	push	r29
     df0:	ec 01       	movw	r28, r24
     df2:	14 2f       	mov	r17, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     df4:	4c 8d       	ldd	r20, Y+28	; 0x1c
     df6:	44 23       	and	r20, r20
     df8:	d1 f1       	breq	.+116    	; 0xe6e <prvCopyDataToQueue+0x84>
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     dfa:	50 e0       	ldi	r21, 0x00	; 0
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     dfc:	11 11       	cpse	r17, r1
     dfe:	15 c0       	rjmp	.+42     	; 0xe2a <prvCopyDataToQueue+0x40>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     e00:	8c 81       	ldd	r24, Y+4	; 0x04
     e02:	9d 81       	ldd	r25, Y+5	; 0x05
     e04:	0e 94 57 11 	call	0x22ae	; 0x22ae <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     e08:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e0a:	8c 81       	ldd	r24, Y+4	; 0x04
     e0c:	9d 81       	ldd	r25, Y+5	; 0x05
     e0e:	82 0f       	add	r24, r18
     e10:	91 1d       	adc	r25, r1
     e12:	9d 83       	std	Y+5, r25	; 0x05
     e14:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     e16:	2a 81       	ldd	r18, Y+2	; 0x02
     e18:	3b 81       	ldd	r19, Y+3	; 0x03
     e1a:	82 17       	cp	r24, r18
     e1c:	93 07       	cpc	r25, r19
     e1e:	38 f1       	brcs	.+78     	; 0xe6e <prvCopyDataToQueue+0x84>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     e20:	88 81       	ld	r24, Y
     e22:	99 81       	ldd	r25, Y+1	; 0x01
     e24:	9d 83       	std	Y+5, r25	; 0x05
     e26:	8c 83       	std	Y+4, r24	; 0x04
     e28:	22 c0       	rjmp	.+68     	; 0xe6e <prvCopyDataToQueue+0x84>
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e2a:	8e 81       	ldd	r24, Y+6	; 0x06
     e2c:	9f 81       	ldd	r25, Y+7	; 0x07
     e2e:	0e 94 57 11 	call	0x22ae	; 0x22ae <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     e32:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e34:	30 e0       	ldi	r19, 0x00	; 0
     e36:	31 95       	neg	r19
     e38:	21 95       	neg	r18
     e3a:	31 09       	sbc	r19, r1
     e3c:	8e 81       	ldd	r24, Y+6	; 0x06
     e3e:	9f 81       	ldd	r25, Y+7	; 0x07
     e40:	82 0f       	add	r24, r18
     e42:	93 1f       	adc	r25, r19
     e44:	9f 83       	std	Y+7, r25	; 0x07
     e46:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     e48:	68 81       	ld	r22, Y
     e4a:	79 81       	ldd	r23, Y+1	; 0x01
     e4c:	86 17       	cp	r24, r22
     e4e:	97 07       	cpc	r25, r23
     e50:	30 f4       	brcc	.+12     	; 0xe5e <prvCopyDataToQueue+0x74>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     e52:	8a 81       	ldd	r24, Y+2	; 0x02
     e54:	9b 81       	ldd	r25, Y+3	; 0x03
     e56:	82 0f       	add	r24, r18
     e58:	93 1f       	adc	r25, r19
     e5a:	9f 83       	std	Y+7, r25	; 0x07
     e5c:	8e 83       	std	Y+6, r24	; 0x06
		}

		if( xPosition == queueOVERWRITE )
     e5e:	12 30       	cpi	r17, 0x02	; 2
     e60:	31 f4       	brne	.+12     	; 0xe6e <prvCopyDataToQueue+0x84>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     e62:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e64:	88 23       	and	r24, r24
     e66:	19 f0       	breq	.+6      	; 0xe6e <prvCopyDataToQueue+0x84>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     e68:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e6a:	81 50       	subi	r24, 0x01	; 1
     e6c:	8a 8f       	std	Y+26, r24	; 0x1a
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
     e6e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e70:	8f 5f       	subi	r24, 0xFF	; 255
     e72:	8a 8f       	std	Y+26, r24	; 0x1a
}
     e74:	df 91       	pop	r29
     e76:	cf 91       	pop	r28
     e78:	1f 91       	pop	r17
     e7a:	08 95       	ret

00000e7c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
     e7c:	cf 93       	push	r28
     e7e:	df 93       	push	r29
     e80:	fc 01       	movw	r30, r24
     e82:	cb 01       	movw	r24, r22
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     e84:	a0 81       	ld	r26, Z
     e86:	b1 81       	ldd	r27, Z+1	; 0x01
     e88:	10 97       	sbiw	r26, 0x00	; 0
     e8a:	a9 f0       	breq	.+42     	; 0xeb6 <prvCopyDataFromQueue+0x3a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     e8c:	44 8d       	ldd	r20, Z+28	; 0x1c
     e8e:	26 81       	ldd	r18, Z+6	; 0x06
     e90:	37 81       	ldd	r19, Z+7	; 0x07
     e92:	24 0f       	add	r18, r20
     e94:	31 1d       	adc	r19, r1
     e96:	37 83       	std	Z+7, r19	; 0x07
     e98:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     e9a:	c2 81       	ldd	r28, Z+2	; 0x02
     e9c:	d3 81       	ldd	r29, Z+3	; 0x03
     e9e:	2c 17       	cp	r18, r28
     ea0:	3d 07       	cpc	r19, r29
     ea2:	10 f0       	brcs	.+4      	; 0xea8 <prvCopyDataFromQueue+0x2c>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     ea4:	b7 83       	std	Z+7, r27	; 0x07
     ea6:	a6 83       	std	Z+6, r26	; 0x06
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     ea8:	66 81       	ldd	r22, Z+6	; 0x06
     eaa:	77 81       	ldd	r23, Z+7	; 0x07
     eac:	50 e0       	ldi	r21, 0x00	; 0
	}
}
     eae:	df 91       	pop	r29
     eb0:	cf 91       	pop	r28
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     eb2:	0c 94 57 11 	jmp	0x22ae	; 0x22ae <memcpy>
	}
}
     eb6:	df 91       	pop	r29
     eb8:	cf 91       	pop	r28
     eba:	08 95       	ret

00000ebc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
     ebc:	0f 93       	push	r16
     ebe:	1f 93       	push	r17
     ec0:	cf 93       	push	r28
     ec2:	df 93       	push	r29
     ec4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     ec6:	0f b6       	in	r0, 0x3f	; 63
     ec8:	f8 94       	cli
     eca:	0f 92       	push	r0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ecc:	8c 01       	movw	r16, r24
     ece:	0f 5e       	subi	r16, 0xEF	; 239
     ed0:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     ed2:	0c c0       	rjmp	.+24     	; 0xeec <prvUnlockQueue+0x30>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ed4:	89 89       	ldd	r24, Y+17	; 0x11
     ed6:	88 23       	and	r24, r24
     ed8:	61 f0       	breq	.+24     	; 0xef2 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     eda:	c8 01       	movw	r24, r16
     edc:	0e 94 79 06 	call	0xcf2	; 0xcf2 <xTaskRemoveFromEventList>
     ee0:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     ee2:	0e 94 f1 06 	call	0xde2	; 0xde2 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     ee6:	8e 8d       	ldd	r24, Y+30	; 0x1e
     ee8:	81 50       	subi	r24, 0x01	; 1
     eea:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     eec:	8e 8d       	ldd	r24, Y+30	; 0x1e
     eee:	18 16       	cp	r1, r24
     ef0:	8c f3       	brlt	.-30     	; 0xed4 <prvUnlockQueue+0x18>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     ef2:	8f ef       	ldi	r24, 0xFF	; 255
     ef4:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     ef6:	0f 90       	pop	r0
     ef8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     efa:	0f b6       	in	r0, 0x3f	; 63
     efc:	f8 94       	cli
     efe:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     f00:	8e 01       	movw	r16, r28
     f02:	08 5f       	subi	r16, 0xF8	; 248
     f04:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     f06:	0c c0       	rjmp	.+24     	; 0xf20 <prvUnlockQueue+0x64>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f08:	88 85       	ldd	r24, Y+8	; 0x08
     f0a:	88 23       	and	r24, r24
     f0c:	61 f0       	breq	.+24     	; 0xf26 <prvUnlockQueue+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     f0e:	c8 01       	movw	r24, r16
     f10:	0e 94 79 06 	call	0xcf2	; 0xcf2 <xTaskRemoveFromEventList>
     f14:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     f16:	0e 94 f1 06 	call	0xde2	; 0xde2 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     f1a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f1c:	81 50       	subi	r24, 0x01	; 1
     f1e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     f20:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f22:	18 16       	cp	r1, r24
     f24:	8c f3       	brlt	.-30     	; 0xf08 <prvUnlockQueue+0x4c>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     f26:	8f ef       	ldi	r24, 0xFF	; 255
     f28:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     f2a:	0f 90       	pop	r0
     f2c:	0f be       	out	0x3f, r0	; 63
}
     f2e:	df 91       	pop	r29
     f30:	cf 91       	pop	r28
     f32:	1f 91       	pop	r17
     f34:	0f 91       	pop	r16
     f36:	08 95       	ret

00000f38 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
     f38:	cf 93       	push	r28
     f3a:	df 93       	push	r29
     f3c:	ec 01       	movw	r28, r24
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     f3e:	0f b6       	in	r0, 0x3f	; 63
     f40:	f8 94       	cli
     f42:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     f44:	28 81       	ld	r18, Y
     f46:	39 81       	ldd	r19, Y+1	; 0x01
     f48:	4b 8d       	ldd	r20, Y+27	; 0x1b
     f4a:	7c 8d       	ldd	r23, Y+28	; 0x1c
     f4c:	c9 01       	movw	r24, r18
     f4e:	47 9f       	mul	r20, r23
     f50:	80 0d       	add	r24, r0
     f52:	91 1d       	adc	r25, r1
     f54:	11 24       	eor	r1, r1
     f56:	9b 83       	std	Y+3, r25	; 0x03
     f58:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     f5a:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     f5c:	3d 83       	std	Y+5, r19	; 0x05
     f5e:	2c 83       	std	Y+4, r18	; 0x04

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     f60:	50 e0       	ldi	r21, 0x00	; 0
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
     f62:	41 50       	subi	r20, 0x01	; 1
     f64:	51 09       	sbc	r21, r1
     f66:	74 9f       	mul	r23, r20
     f68:	c0 01       	movw	r24, r0
     f6a:	75 9f       	mul	r23, r21
     f6c:	90 0d       	add	r25, r0
     f6e:	11 24       	eor	r1, r1
     f70:	82 0f       	add	r24, r18
     f72:	93 1f       	adc	r25, r19
     f74:	9f 83       	std	Y+7, r25	; 0x07
     f76:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     f78:	8f ef       	ldi	r24, 0xFF	; 255
     f7a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     f7c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     f7e:	61 11       	cpse	r22, r1
     f80:	0c c0       	rjmp	.+24     	; 0xf9a <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f82:	88 85       	ldd	r24, Y+8	; 0x08
     f84:	88 23       	and	r24, r24
     f86:	89 f0       	breq	.+34     	; 0xfaa <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     f88:	ce 01       	movw	r24, r28
     f8a:	08 96       	adiw	r24, 0x08	; 8
     f8c:	0e 94 79 06 	call	0xcf2	; 0xcf2 <xTaskRemoveFromEventList>
     f90:	81 30       	cpi	r24, 0x01	; 1
     f92:	59 f4       	brne	.+22     	; 0xfaa <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
     f94:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>
     f98:	08 c0       	rjmp	.+16     	; 0xfaa <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     f9a:	ce 01       	movw	r24, r28
     f9c:	08 96       	adiw	r24, 0x08	; 8
     f9e:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     fa2:	ce 01       	movw	r24, r28
     fa4:	41 96       	adiw	r24, 0x11	; 17
     fa6:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     faa:	0f 90       	pop	r0
     fac:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     fae:	81 e0       	ldi	r24, 0x01	; 1
     fb0:	df 91       	pop	r29
     fb2:	cf 91       	pop	r28
     fb4:	08 95       	ret

00000fb6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
     fb6:	0f 93       	push	r16
     fb8:	1f 93       	push	r17
     fba:	cf 93       	push	r28
     fbc:	df 93       	push	r29
     fbe:	18 2f       	mov	r17, r24
     fc0:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     fc2:	81 11       	cpse	r24, r1
     fc4:	01 c0       	rjmp	.+2      	; 0xfc8 <xQueueGenericCreate+0x12>
     fc6:	1b c0       	rjmp	.+54     	; 0xffe <xQueueGenericCreate+0x48>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     fc8:	8f e1       	ldi	r24, 0x1F	; 31
     fca:	90 e0       	ldi	r25, 0x00	; 0
     fcc:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <pvPortMalloc>
     fd0:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     fd2:	00 97       	sbiw	r24, 0x00	; 0
     fd4:	a1 f0       	breq	.+40     	; 0xffe <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     fd6:	10 9f       	mul	r17, r16
     fd8:	c0 01       	movw	r24, r0
     fda:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     fdc:	01 96       	adiw	r24, 0x01	; 1
     fde:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <pvPortMalloc>
     fe2:	99 83       	std	Y+1, r25	; 0x01
     fe4:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     fe6:	89 2b       	or	r24, r25
     fe8:	39 f0       	breq	.+14     	; 0xff8 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     fea:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     fec:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     fee:	61 e0       	ldi	r22, 0x01	; 1
     ff0:	ce 01       	movw	r24, r28
     ff2:	0e 94 9c 07 	call	0xf38	; 0xf38 <xQueueGenericReset>
     ff6:	05 c0       	rjmp	.+10     	; 0x1002 <xQueueGenericCreate+0x4c>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     ff8:	ce 01       	movw	r24, r28
     ffa:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     ffe:	c0 e0       	ldi	r28, 0x00	; 0
    1000:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1002:	ce 01       	movw	r24, r28
    1004:	df 91       	pop	r29
    1006:	cf 91       	pop	r28
    1008:	1f 91       	pop	r17
    100a:	0f 91       	pop	r16
    100c:	08 95       	ret

0000100e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    100e:	bf 92       	push	r11
    1010:	cf 92       	push	r12
    1012:	df 92       	push	r13
    1014:	ef 92       	push	r14
    1016:	ff 92       	push	r15
    1018:	0f 93       	push	r16
    101a:	1f 93       	push	r17
    101c:	cf 93       	push	r28
    101e:	df 93       	push	r29
    1020:	00 d0       	rcall	.+0      	; 0x1022 <xQueueGenericSend+0x14>
    1022:	00 d0       	rcall	.+0      	; 0x1024 <xQueueGenericSend+0x16>
    1024:	1f 92       	push	r1
    1026:	cd b7       	in	r28, 0x3d	; 61
    1028:	de b7       	in	r29, 0x3e	; 62
    102a:	8c 01       	movw	r16, r24
    102c:	6b 01       	movw	r12, r22
    102e:	5d 83       	std	Y+5, r21	; 0x05
    1030:	4c 83       	std	Y+4, r20	; 0x04
    1032:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1034:	20 e0       	ldi	r18, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1036:	7c 01       	movw	r14, r24
    1038:	88 e0       	ldi	r24, 0x08	; 8
    103a:	e8 0e       	add	r14, r24
    103c:	f1 1c       	adc	r15, r1
    103e:	01 c0       	rjmp	.+2      	; 0x1042 <xQueueGenericSend+0x34>
    1040:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1042:	0f b6       	in	r0, 0x3f	; 63
    1044:	f8 94       	cli
    1046:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1048:	f8 01       	movw	r30, r16
    104a:	92 8d       	ldd	r25, Z+26	; 0x1a
    104c:	83 8d       	ldd	r24, Z+27	; 0x1b
    104e:	98 17       	cp	r25, r24
    1050:	18 f0       	brcs	.+6      	; 0x1058 <xQueueGenericSend+0x4a>
    1052:	f2 e0       	ldi	r31, 0x02	; 2
    1054:	bf 12       	cpse	r11, r31
    1056:	15 c0       	rjmp	.+42     	; 0x1082 <xQueueGenericSend+0x74>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1058:	4b 2d       	mov	r20, r11
    105a:	b6 01       	movw	r22, r12
    105c:	c8 01       	movw	r24, r16
    105e:	0e 94 f5 06 	call	0xdea	; 0xdea <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1062:	f8 01       	movw	r30, r16
    1064:	81 89       	ldd	r24, Z+17	; 0x11
    1066:	88 23       	and	r24, r24
    1068:	41 f0       	breq	.+16     	; 0x107a <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    106a:	c8 01       	movw	r24, r16
    106c:	41 96       	adiw	r24, 0x11	; 17
    106e:	0e 94 79 06 	call	0xcf2	; 0xcf2 <xTaskRemoveFromEventList>
    1072:	81 30       	cpi	r24, 0x01	; 1
    1074:	11 f4       	brne	.+4      	; 0x107a <xQueueGenericSend+0x6c>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1076:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    107a:	0f 90       	pop	r0
    107c:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	4f c0       	rjmp	.+158    	; 0x1120 <xQueueGenericSend+0x112>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1082:	8c 81       	ldd	r24, Y+4	; 0x04
    1084:	9d 81       	ldd	r25, Y+5	; 0x05
    1086:	89 2b       	or	r24, r25
    1088:	19 f4       	brne	.+6      	; 0x1090 <xQueueGenericSend+0x82>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    108a:	0f 90       	pop	r0
    108c:	0f be       	out	0x3f, r0	; 63
    108e:	47 c0       	rjmp	.+142    	; 0x111e <xQueueGenericSend+0x110>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1090:	21 11       	cpse	r18, r1
    1092:	04 c0       	rjmp	.+8      	; 0x109c <xQueueGenericSend+0x8e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1094:	ce 01       	movw	r24, r28
    1096:	01 96       	adiw	r24, 0x01	; 1
    1098:	0e 94 ba 06 	call	0xd74	; 0xd74 <vTaskSetTimeOutState>
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
    109c:	0f 90       	pop	r0
    109e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    10a0:	0e 94 31 04 	call	0x862	; 0x862 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    10a4:	0f b6       	in	r0, 0x3f	; 63
    10a6:	f8 94       	cli
    10a8:	0f 92       	push	r0
    10aa:	f8 01       	movw	r30, r16
    10ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    10ae:	8f 3f       	cpi	r24, 0xFF	; 255
    10b0:	09 f4       	brne	.+2      	; 0x10b4 <xQueueGenericSend+0xa6>
    10b2:	15 8e       	std	Z+29, r1	; 0x1d
    10b4:	f8 01       	movw	r30, r16
    10b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    10b8:	8f 3f       	cpi	r24, 0xFF	; 255
    10ba:	09 f4       	brne	.+2      	; 0x10be <xQueueGenericSend+0xb0>
    10bc:	16 8e       	std	Z+30, r1	; 0x1e
    10be:	0f 90       	pop	r0
    10c0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    10c2:	be 01       	movw	r22, r28
    10c4:	6c 5f       	subi	r22, 0xFC	; 252
    10c6:	7f 4f       	sbci	r23, 0xFF	; 255
    10c8:	ce 01       	movw	r24, r28
    10ca:	01 96       	adiw	r24, 0x01	; 1
    10cc:	0e 94 c5 06 	call	0xd8a	; 0xd8a <xTaskCheckForTimeOut>
    10d0:	81 11       	cpse	r24, r1
    10d2:	20 c0       	rjmp	.+64     	; 0x1114 <xQueueGenericSend+0x106>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    10d4:	0f b6       	in	r0, 0x3f	; 63
    10d6:	f8 94       	cli
    10d8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    10da:	f8 01       	movw	r30, r16
    10dc:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    10de:	0f 90       	pop	r0
    10e0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    10e2:	f8 01       	movw	r30, r16
    10e4:	83 8d       	ldd	r24, Z+27	; 0x1b
    10e6:	98 13       	cpse	r25, r24
    10e8:	0f c0       	rjmp	.+30     	; 0x1108 <xQueueGenericSend+0xfa>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    10ea:	6c 81       	ldd	r22, Y+4	; 0x04
    10ec:	7d 81       	ldd	r23, Y+5	; 0x05
    10ee:	c7 01       	movw	r24, r14
    10f0:	0e 94 5d 06 	call	0xcba	; 0xcba <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    10f4:	c8 01       	movw	r24, r16
    10f6:	0e 94 5e 07 	call	0xebc	; 0xebc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    10fa:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskResumeAll>
    10fe:	81 11       	cpse	r24, r1
    1100:	9f cf       	rjmp	.-194    	; 0x1040 <xQueueGenericSend+0x32>
				{
					portYIELD_WITHIN_API();
    1102:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>
    1106:	9c cf       	rjmp	.-200    	; 0x1040 <xQueueGenericSend+0x32>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1108:	c8 01       	movw	r24, r16
    110a:	0e 94 5e 07 	call	0xebc	; 0xebc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    110e:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskResumeAll>
    1112:	96 cf       	rjmp	.-212    	; 0x1040 <xQueueGenericSend+0x32>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1114:	c8 01       	movw	r24, r16
    1116:	0e 94 5e 07 	call	0xebc	; 0xebc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    111a:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    111e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1120:	0f 90       	pop	r0
    1122:	0f 90       	pop	r0
    1124:	0f 90       	pop	r0
    1126:	0f 90       	pop	r0
    1128:	0f 90       	pop	r0
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	1f 91       	pop	r17
    1130:	0f 91       	pop	r16
    1132:	ff 90       	pop	r15
    1134:	ef 90       	pop	r14
    1136:	df 90       	pop	r13
    1138:	cf 90       	pop	r12
    113a:	bf 90       	pop	r11
    113c:	08 95       	ret

0000113e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    113e:	0f 93       	push	r16
    1140:	1f 93       	push	r17
    1142:	cf 93       	push	r28
    1144:	df 93       	push	r29
    1146:	ec 01       	movw	r28, r24
    1148:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    114a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    114c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    114e:	98 17       	cp	r25, r24
    1150:	10 f0       	brcs	.+4      	; 0x1156 <xQueueGenericSendFromISR+0x18>
    1152:	22 30       	cpi	r18, 0x02	; 2
    1154:	e9 f4       	brne	.+58     	; 0x1190 <xQueueGenericSendFromISR+0x52>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1156:	42 2f       	mov	r20, r18
    1158:	ce 01       	movw	r24, r28
    115a:	0e 94 f5 06 	call	0xdea	; 0xdea <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    115e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1160:	8f 3f       	cpi	r24, 0xFF	; 255
    1162:	89 f4       	brne	.+34     	; 0x1186 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1164:	89 89       	ldd	r24, Y+17	; 0x11
    1166:	81 11       	cpse	r24, r1
    1168:	01 c0       	rjmp	.+2      	; 0x116c <xQueueGenericSendFromISR+0x2e>
    116a:	10 c0       	rjmp	.+32     	; 0x118c <xQueueGenericSendFromISR+0x4e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    116c:	ce 01       	movw	r24, r28
    116e:	41 96       	adiw	r24, 0x11	; 17
    1170:	0e 94 79 06 	call	0xcf2	; 0xcf2 <xTaskRemoveFromEventList>
    1174:	88 23       	and	r24, r24
    1176:	51 f0       	breq	.+20     	; 0x118c <xQueueGenericSendFromISR+0x4e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1178:	01 15       	cp	r16, r1
    117a:	11 05       	cpc	r17, r1
    117c:	39 f0       	breq	.+14     	; 0x118c <xQueueGenericSendFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    117e:	81 e0       	ldi	r24, 0x01	; 1
    1180:	f8 01       	movw	r30, r16
    1182:	80 83       	st	Z, r24
    1184:	06 c0       	rjmp	.+12     	; 0x1192 <xQueueGenericSendFromISR+0x54>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1186:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1188:	8f 5f       	subi	r24, 0xFF	; 255
    118a:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    118c:	81 e0       	ldi	r24, 0x01	; 1
    118e:	01 c0       	rjmp	.+2      	; 0x1192 <xQueueGenericSendFromISR+0x54>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1190:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1192:	df 91       	pop	r29
    1194:	cf 91       	pop	r28
    1196:	1f 91       	pop	r17
    1198:	0f 91       	pop	r16
    119a:	08 95       	ret

0000119c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    119c:	bf 92       	push	r11
    119e:	cf 92       	push	r12
    11a0:	df 92       	push	r13
    11a2:	ef 92       	push	r14
    11a4:	ff 92       	push	r15
    11a6:	0f 93       	push	r16
    11a8:	1f 93       	push	r17
    11aa:	cf 93       	push	r28
    11ac:	df 93       	push	r29
    11ae:	00 d0       	rcall	.+0      	; 0x11b0 <xQueueGenericReceive+0x14>
    11b0:	00 d0       	rcall	.+0      	; 0x11b2 <xQueueGenericReceive+0x16>
    11b2:	1f 92       	push	r1
    11b4:	cd b7       	in	r28, 0x3d	; 61
    11b6:	de b7       	in	r29, 0x3e	; 62
    11b8:	8c 01       	movw	r16, r24
    11ba:	6b 01       	movw	r12, r22
    11bc:	5d 83       	std	Y+5, r21	; 0x05
    11be:	4c 83       	std	Y+4, r20	; 0x04
    11c0:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    11c2:	30 e0       	ldi	r19, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    11c4:	7c 01       	movw	r14, r24
    11c6:	81 e1       	ldi	r24, 0x11	; 17
    11c8:	e8 0e       	add	r14, r24
    11ca:	f1 1c       	adc	r15, r1
    11cc:	01 c0       	rjmp	.+2      	; 0x11d0 <xQueueGenericReceive+0x34>
    11ce:	31 e0       	ldi	r19, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    11d0:	0f b6       	in	r0, 0x3f	; 63
    11d2:	f8 94       	cli
    11d4:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    11d6:	f8 01       	movw	r30, r16
    11d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    11da:	88 23       	and	r24, r24
    11dc:	39 f1       	breq	.+78     	; 0x122c <xQueueGenericReceive+0x90>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    11de:	e6 80       	ldd	r14, Z+6	; 0x06
    11e0:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    11e2:	b6 01       	movw	r22, r12
    11e4:	c8 01       	movw	r24, r16
    11e6:	0e 94 3e 07 	call	0xe7c	; 0xe7c <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    11ea:	f8 01       	movw	r30, r16
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    11ec:	b1 10       	cpse	r11, r1
    11ee:	0f c0       	rjmp	.+30     	; 0x120e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    11f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    11f2:	81 50       	subi	r24, 0x01	; 1
    11f4:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11f6:	80 85       	ldd	r24, Z+8	; 0x08
    11f8:	88 23       	and	r24, r24
    11fa:	a1 f0       	breq	.+40     	; 0x1224 <xQueueGenericReceive+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    11fc:	c8 01       	movw	r24, r16
    11fe:	08 96       	adiw	r24, 0x08	; 8
    1200:	0e 94 79 06 	call	0xcf2	; 0xcf2 <xTaskRemoveFromEventList>
    1204:	81 30       	cpi	r24, 0x01	; 1
    1206:	71 f4       	brne	.+28     	; 0x1224 <xQueueGenericReceive+0x88>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1208:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>
    120c:	0b c0       	rjmp	.+22     	; 0x1224 <xQueueGenericReceive+0x88>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    120e:	f7 82       	std	Z+7, r15	; 0x07
    1210:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1212:	81 89       	ldd	r24, Z+17	; 0x11
    1214:	88 23       	and	r24, r24
    1216:	31 f0       	breq	.+12     	; 0x1224 <xQueueGenericReceive+0x88>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1218:	c8 01       	movw	r24, r16
    121a:	41 96       	adiw	r24, 0x11	; 17
    121c:	0e 94 79 06 	call	0xcf2	; 0xcf2 <xTaskRemoveFromEventList>
    1220:	81 11       	cpse	r24, r1
    1222:	f2 cf       	rjmp	.-28     	; 0x1208 <xQueueGenericReceive+0x6c>
							queueYIELD_IF_USING_PREEMPTION();
						}
					}
				}

				taskEXIT_CRITICAL();
    1224:	0f 90       	pop	r0
    1226:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	4d c0       	rjmp	.+154    	; 0x12c6 <xQueueGenericReceive+0x12a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    122c:	8c 81       	ldd	r24, Y+4	; 0x04
    122e:	9d 81       	ldd	r25, Y+5	; 0x05
    1230:	89 2b       	or	r24, r25
    1232:	19 f4       	brne	.+6      	; 0x123a <xQueueGenericReceive+0x9e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1234:	0f 90       	pop	r0
    1236:	0f be       	out	0x3f, r0	; 63
    1238:	45 c0       	rjmp	.+138    	; 0x12c4 <xQueueGenericReceive+0x128>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    123a:	31 11       	cpse	r19, r1
    123c:	04 c0       	rjmp	.+8      	; 0x1246 <xQueueGenericReceive+0xaa>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    123e:	ce 01       	movw	r24, r28
    1240:	01 96       	adiw	r24, 0x01	; 1
    1242:	0e 94 ba 06 	call	0xd74	; 0xd74 <vTaskSetTimeOutState>
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
    1246:	0f 90       	pop	r0
    1248:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    124a:	0e 94 31 04 	call	0x862	; 0x862 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    124e:	0f b6       	in	r0, 0x3f	; 63
    1250:	f8 94       	cli
    1252:	0f 92       	push	r0
    1254:	f8 01       	movw	r30, r16
    1256:	85 8d       	ldd	r24, Z+29	; 0x1d
    1258:	8f 3f       	cpi	r24, 0xFF	; 255
    125a:	09 f4       	brne	.+2      	; 0x125e <xQueueGenericReceive+0xc2>
    125c:	15 8e       	std	Z+29, r1	; 0x1d
    125e:	f8 01       	movw	r30, r16
    1260:	86 8d       	ldd	r24, Z+30	; 0x1e
    1262:	8f 3f       	cpi	r24, 0xFF	; 255
    1264:	09 f4       	brne	.+2      	; 0x1268 <xQueueGenericReceive+0xcc>
    1266:	16 8e       	std	Z+30, r1	; 0x1e
    1268:	0f 90       	pop	r0
    126a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    126c:	be 01       	movw	r22, r28
    126e:	6c 5f       	subi	r22, 0xFC	; 252
    1270:	7f 4f       	sbci	r23, 0xFF	; 255
    1272:	ce 01       	movw	r24, r28
    1274:	01 96       	adiw	r24, 0x01	; 1
    1276:	0e 94 c5 06 	call	0xd8a	; 0xd8a <xTaskCheckForTimeOut>
    127a:	81 11       	cpse	r24, r1
    127c:	1e c0       	rjmp	.+60     	; 0x12ba <xQueueGenericReceive+0x11e>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    127e:	0f b6       	in	r0, 0x3f	; 63
    1280:	f8 94       	cli
    1282:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
    1284:	f8 01       	movw	r30, r16
    1286:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1288:	0f 90       	pop	r0
    128a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    128c:	81 11       	cpse	r24, r1
    128e:	0f c0       	rjmp	.+30     	; 0x12ae <xQueueGenericReceive+0x112>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1290:	6c 81       	ldd	r22, Y+4	; 0x04
    1292:	7d 81       	ldd	r23, Y+5	; 0x05
    1294:	c7 01       	movw	r24, r14
    1296:	0e 94 5d 06 	call	0xcba	; 0xcba <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    129a:	c8 01       	movw	r24, r16
    129c:	0e 94 5e 07 	call	0xebc	; 0xebc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    12a0:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskResumeAll>
    12a4:	81 11       	cpse	r24, r1
    12a6:	93 cf       	rjmp	.-218    	; 0x11ce <xQueueGenericReceive+0x32>
				{
					portYIELD_WITHIN_API();
    12a8:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <vPortYield>
    12ac:	90 cf       	rjmp	.-224    	; 0x11ce <xQueueGenericReceive+0x32>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    12ae:	c8 01       	movw	r24, r16
    12b0:	0e 94 5e 07 	call	0xebc	; 0xebc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    12b4:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskResumeAll>
    12b8:	8a cf       	rjmp	.-236    	; 0x11ce <xQueueGenericReceive+0x32>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    12ba:	c8 01       	movw	r24, r16
    12bc:	0e 94 5e 07 	call	0xebc	; 0xebc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12c0:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    12c4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    12c6:	0f 90       	pop	r0
    12c8:	0f 90       	pop	r0
    12ca:	0f 90       	pop	r0
    12cc:	0f 90       	pop	r0
    12ce:	0f 90       	pop	r0
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	1f 91       	pop	r17
    12d6:	0f 91       	pop	r16
    12d8:	ff 90       	pop	r15
    12da:	ef 90       	pop	r14
    12dc:	df 90       	pop	r13
    12de:	cf 90       	pop	r12
    12e0:	bf 90       	pop	r11
    12e2:	08 95       	ret

000012e4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    12e4:	0f 93       	push	r16
    12e6:	1f 93       	push	r17
    12e8:	cf 93       	push	r28
    12ea:	df 93       	push	r29
    12ec:	ec 01       	movw	r28, r24
    12ee:	8a 01       	movw	r16, r20
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    12f0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12f2:	88 23       	and	r24, r24
    12f4:	f9 f0       	breq	.+62     	; 0x1334 <xQueueReceiveFromISR+0x50>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    12f6:	ce 01       	movw	r24, r28
    12f8:	0e 94 3e 07 	call	0xe7c	; 0xe7c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    12fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12fe:	81 50       	subi	r24, 0x01	; 1
    1300:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1302:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1304:	8f 3f       	cpi	r24, 0xFF	; 255
    1306:	89 f4       	brne	.+34     	; 0x132a <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1308:	88 85       	ldd	r24, Y+8	; 0x08
    130a:	81 11       	cpse	r24, r1
    130c:	01 c0       	rjmp	.+2      	; 0x1310 <xQueueReceiveFromISR+0x2c>
    130e:	10 c0       	rjmp	.+32     	; 0x1330 <xQueueReceiveFromISR+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1310:	ce 01       	movw	r24, r28
    1312:	08 96       	adiw	r24, 0x08	; 8
    1314:	0e 94 79 06 	call	0xcf2	; 0xcf2 <xTaskRemoveFromEventList>
    1318:	88 23       	and	r24, r24
    131a:	51 f0       	breq	.+20     	; 0x1330 <xQueueReceiveFromISR+0x4c>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    131c:	01 15       	cp	r16, r1
    131e:	11 05       	cpc	r17, r1
    1320:	39 f0       	breq	.+14     	; 0x1330 <xQueueReceiveFromISR+0x4c>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	f8 01       	movw	r30, r16
    1326:	80 83       	st	Z, r24
    1328:	06 c0       	rjmp	.+12     	; 0x1336 <xQueueReceiveFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    132a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    132c:	8f 5f       	subi	r24, 0xFF	; 255
    132e:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1330:	81 e0       	ldi	r24, 0x01	; 1
    1332:	01 c0       	rjmp	.+2      	; 0x1336 <xQueueReceiveFromISR+0x52>
		}
		else
		{
			xReturn = pdFAIL;
    1334:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1336:	df 91       	pop	r29
    1338:	cf 91       	pop	r28
    133a:	1f 91       	pop	r17
    133c:	0f 91       	pop	r16
    133e:	08 95       	ret

00001340 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue,  void * const pvBuffer )
{
    1340:	0f 93       	push	r16
    1342:	1f 93       	push	r17
    1344:	cf 93       	push	r28
    1346:	df 93       	push	r29
    1348:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    134a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    134c:	88 23       	and	r24, r24
    134e:	49 f0       	breq	.+18     	; 0x1362 <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1350:	0e 81       	ldd	r16, Y+6	; 0x06
    1352:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1354:	ce 01       	movw	r24, r28
    1356:	0e 94 3e 07 	call	0xe7c	; 0xe7c <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    135a:	1f 83       	std	Y+7, r17	; 0x07
    135c:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    135e:	81 e0       	ldi	r24, 0x01	; 1
    1360:	01 c0       	rjmp	.+2      	; 0x1364 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1362:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1364:	df 91       	pop	r29
    1366:	cf 91       	pop	r28
    1368:	1f 91       	pop	r17
    136a:	0f 91       	pop	r16
    136c:	08 95       	ret

0000136e <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    136e:	0f b6       	in	r0, 0x3f	; 63
    1370:	f8 94       	cli
    1372:	0f 92       	push	r0
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    1374:	fc 01       	movw	r30, r24
    1376:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1378:	0f 90       	pop	r0
    137a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    137c:	08 95       	ret

0000137e <uxQueueSpacesAvailable>:
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    137e:	0f b6       	in	r0, 0x3f	; 63
    1380:	f8 94       	cli
    1382:	0f 92       	push	r0
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1384:	fc 01       	movw	r30, r24
    1386:	22 8d       	ldd	r18, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1388:	0f 90       	pop	r0
    138a:	0f be       	out	0x3f, r0	; 63

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    138c:	fc 01       	movw	r30, r24
    138e:	83 8d       	ldd	r24, Z+27	; 0x1b
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1390:	82 1b       	sub	r24, r18
    1392:	08 95       	ret

00001394 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    1394:	fc 01       	movw	r30, r24
    1396:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1398:	08 95       	ret

0000139a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
    139a:	cf 93       	push	r28
    139c:	df 93       	push	r29
    139e:	ec 01       	movw	r28, r24
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
    13a0:	88 81       	ld	r24, Y
    13a2:	99 81       	ldd	r25, Y+1	; 0x01
    13a4:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <vPortFree>
	vPortFree( pxQueue );
    13a8:	ce 01       	movw	r24, r28
}
    13aa:	df 91       	pop	r29
    13ac:	cf 91       	pop	r28
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
	vPortFree( pxQueue );
    13ae:	0c 94 39 0d 	jmp	0x1a72	; 0x1a72 <vPortFree>

000013b2 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
    13b2:	fc 01       	movw	r30, r24
    13b4:	92 8d       	ldd	r25, Z+26	; 0x1a
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	91 11       	cpse	r25, r1
    13ba:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    13bc:	08 95       	ret

000013be <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
    13be:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
    13c0:	22 8d       	ldd	r18, Z+26	; 0x1a
    13c2:	81 e0       	ldi	r24, 0x01	; 1
    13c4:	93 8d       	ldd	r25, Z+27	; 0x1b
    13c6:	29 13       	cpse	r18, r25
    13c8:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    13ca:	08 95       	ret

000013cc <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait )
	{
    13cc:	cf 93       	push	r28
    13ce:	df 93       	push	r29
    13d0:	ec 01       	movw	r28, r24
    13d2:	ca 01       	movw	r24, r20
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    13d4:	f8 94       	cli

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    13d6:	0f b6       	in	r0, 0x3f	; 63
    13d8:	f8 94       	cli
    13da:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    13dc:	3a 8d       	ldd	r19, Y+26	; 0x1a
    13de:	2b 8d       	ldd	r18, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    13e0:	0f 90       	pop	r0
    13e2:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    13e4:	32 13       	cpse	r19, r18
    13e6:	0d c0       	rjmp	.+26     	; 0x1402 <xQueueCRSend+0x36>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( portTickType ) 0 )
    13e8:	00 97       	sbiw	r24, 0x00	; 0
    13ea:	41 f0       	breq	.+16     	; 0x13fc <xQueueCRSend+0x30>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    13ec:	be 01       	movw	r22, r28
    13ee:	68 5f       	subi	r22, 0xF8	; 248
    13f0:	7f 4f       	sbci	r23, 0xFF	; 255
    13f2:	0e 94 bf 0b 	call	0x177e	; 0x177e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    13f6:	78 94       	sei
					return errQUEUE_BLOCKED;
    13f8:	8c ef       	ldi	r24, 0xFC	; 252
    13fa:	1b c0       	rjmp	.+54     	; 0x1432 <xQueueCRSend+0x66>
				}
				else
				{
					portENABLE_INTERRUPTS();
    13fc:	78 94       	sei
					return errQUEUE_FULL;
    13fe:	80 e0       	ldi	r24, 0x00	; 0
    1400:	18 c0       	rjmp	.+48     	; 0x1432 <xQueueCRSend+0x66>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1402:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1404:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1406:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1408:	82 17       	cp	r24, r18
    140a:	88 f4       	brcc	.+34     	; 0x142e <xQueueCRSend+0x62>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    140c:	40 e0       	ldi	r20, 0x00	; 0
    140e:	ce 01       	movw	r24, r28
    1410:	0e 94 f5 06 	call	0xdea	; 0xdea <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1414:	89 89       	ldd	r24, Y+17	; 0x11
    1416:	81 11       	cpse	r24, r1
    1418:	02 c0       	rjmp	.+4      	; 0x141e <xQueueCRSend+0x52>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	09 c0       	rjmp	.+18     	; 0x1430 <xQueueCRSend+0x64>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    141e:	ce 01       	movw	r24, r28
    1420:	41 96       	adiw	r24, 0x11	; 17
    1422:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xCoRoutineRemoveFromEventList>
    1426:	88 23       	and	r24, r24
    1428:	c1 f3       	breq	.-16     	; 0x141a <xQueueCRSend+0x4e>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    142a:	8b ef       	ldi	r24, 0xFB	; 251
    142c:	01 c0       	rjmp	.+2      	; 0x1430 <xQueueCRSend+0x64>
					}
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    142e:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1430:	78 94       	sei

		return xReturn;
	}
    1432:	df 91       	pop	r29
    1434:	cf 91       	pop	r28
    1436:	08 95       	ret

00001438 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait )
	{
    1438:	cf 93       	push	r28
    143a:	df 93       	push	r29
    143c:	ec 01       	movw	r28, r24
    143e:	cb 01       	movw	r24, r22
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1440:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
    1442:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1444:	21 11       	cpse	r18, r1
    1446:	0f c0       	rjmp	.+30     	; 0x1466 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( portTickType ) 0 )
    1448:	41 15       	cp	r20, r1
    144a:	51 05       	cpc	r21, r1
    144c:	49 f0       	breq	.+18     	; 0x1460 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    144e:	be 01       	movw	r22, r28
    1450:	6f 5e       	subi	r22, 0xEF	; 239
    1452:	7f 4f       	sbci	r23, 0xFF	; 255
    1454:	ca 01       	movw	r24, r20
    1456:	0e 94 bf 0b 	call	0x177e	; 0x177e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    145a:	78 94       	sei
					return errQUEUE_BLOCKED;
    145c:	8c ef       	ldi	r24, 0xFC	; 252
    145e:	2f c0       	rjmp	.+94     	; 0x14be <xQueueCRReceive+0x86>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1460:	78 94       	sei
					return errQUEUE_FULL;
    1462:	80 e0       	ldi	r24, 0x00	; 0
    1464:	2c c0       	rjmp	.+88     	; 0x14be <xQueueCRReceive+0x86>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1466:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1468:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    146a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    146c:	22 23       	and	r18, r18
    146e:	29 f1       	breq	.+74     	; 0x14ba <xQueueCRReceive+0x82>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1470:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1472:	2e 81       	ldd	r18, Y+6	; 0x06
    1474:	3f 81       	ldd	r19, Y+7	; 0x07
    1476:	24 0f       	add	r18, r20
    1478:	31 1d       	adc	r19, r1
    147a:	3f 83       	std	Y+7, r19	; 0x07
    147c:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    147e:	ea 81       	ldd	r30, Y+2	; 0x02
    1480:	fb 81       	ldd	r31, Y+3	; 0x03
    1482:	2e 17       	cp	r18, r30
    1484:	3f 07       	cpc	r19, r31
    1486:	20 f0       	brcs	.+8      	; 0x1490 <xQueueCRReceive+0x58>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1488:	28 81       	ld	r18, Y
    148a:	39 81       	ldd	r19, Y+1	; 0x01
    148c:	3f 83       	std	Y+7, r19	; 0x07
    148e:	2e 83       	std	Y+6, r18	; 0x06
				}
				--( pxQueue->uxMessagesWaiting );
    1490:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1492:	21 50       	subi	r18, 0x01	; 1
    1494:	2a 8f       	std	Y+26, r18	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1496:	6e 81       	ldd	r22, Y+6	; 0x06
    1498:	7f 81       	ldd	r23, Y+7	; 0x07
    149a:	50 e0       	ldi	r21, 0x00	; 0
    149c:	0e 94 57 11 	call	0x22ae	; 0x22ae <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14a0:	88 85       	ldd	r24, Y+8	; 0x08
    14a2:	81 11       	cpse	r24, r1
    14a4:	02 c0       	rjmp	.+4      	; 0x14aa <xQueueCRReceive+0x72>
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	09 c0       	rjmp	.+18     	; 0x14bc <xQueueCRReceive+0x84>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14aa:	ce 01       	movw	r24, r28
    14ac:	08 96       	adiw	r24, 0x08	; 8
    14ae:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xCoRoutineRemoveFromEventList>
    14b2:	88 23       	and	r24, r24
    14b4:	c1 f3       	breq	.-16     	; 0x14a6 <xQueueCRReceive+0x6e>
					{
						xReturn = errQUEUE_YIELD;
    14b6:	8b ef       	ldi	r24, 0xFB	; 251
    14b8:	01 c0       	rjmp	.+2      	; 0x14bc <xQueueCRReceive+0x84>
					}
				}
			}
			else
			{
				xReturn = pdFAIL;
    14ba:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    14bc:	78 94       	sei

		return xReturn;
	}
    14be:	df 91       	pop	r29
    14c0:	cf 91       	pop	r28
    14c2:	08 95       	ret

000014c4 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
	{
    14c4:	1f 93       	push	r17
    14c6:	cf 93       	push	r28
    14c8:	df 93       	push	r29
    14ca:	ec 01       	movw	r28, r24
    14cc:	14 2f       	mov	r17, r20
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    14ce:	9a 8d       	ldd	r25, Y+26	; 0x1a
    14d0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    14d2:	98 17       	cp	r25, r24
    14d4:	88 f4       	brcc	.+34     	; 0x14f8 <xQueueCRSendFromISR+0x34>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    14d6:	40 e0       	ldi	r20, 0x00	; 0
    14d8:	ce 01       	movw	r24, r28
    14da:	0e 94 f5 06 	call	0xdea	; 0xdea <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    14de:	11 11       	cpse	r17, r1
    14e0:	0b c0       	rjmp	.+22     	; 0x14f8 <xQueueCRSendFromISR+0x34>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14e2:	89 89       	ldd	r24, Y+17	; 0x11
    14e4:	88 23       	and	r24, r24
    14e6:	41 f0       	breq	.+16     	; 0x14f8 <xQueueCRSendFromISR+0x34>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14e8:	ce 01       	movw	r24, r28
    14ea:	41 96       	adiw	r24, 0x11	; 17
    14ec:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xCoRoutineRemoveFromEventList>
    14f0:	11 e0       	ldi	r17, 0x01	; 1
    14f2:	81 11       	cpse	r24, r1
    14f4:	01 c0       	rjmp	.+2      	; 0x14f8 <xQueueCRSendFromISR+0x34>
    14f6:	10 e0       	ldi	r17, 0x00	; 0
				}
			}
		}

		return xCoRoutinePreviouslyWoken;
	}
    14f8:	81 2f       	mov	r24, r17
    14fa:	df 91       	pop	r29
    14fc:	cf 91       	pop	r28
    14fe:	1f 91       	pop	r17
    1500:	08 95       	ret

00001502 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
	{
    1502:	0f 93       	push	r16
    1504:	1f 93       	push	r17
    1506:	cf 93       	push	r28
    1508:	df 93       	push	r29
    150a:	ec 01       	movw	r28, r24
    150c:	cb 01       	movw	r24, r22
    150e:	8a 01       	movw	r16, r20
	signed portBASE_TYPE xReturn;
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1510:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1512:	22 23       	and	r18, r18
    1514:	59 f1       	breq	.+86     	; 0x156c <xQueueCRReceiveFromISR+0x6a>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1516:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1518:	2e 81       	ldd	r18, Y+6	; 0x06
    151a:	3f 81       	ldd	r19, Y+7	; 0x07
    151c:	24 0f       	add	r18, r20
    151e:	31 1d       	adc	r19, r1
    1520:	3f 83       	std	Y+7, r19	; 0x07
    1522:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1524:	ea 81       	ldd	r30, Y+2	; 0x02
    1526:	fb 81       	ldd	r31, Y+3	; 0x03
    1528:	2e 17       	cp	r18, r30
    152a:	3f 07       	cpc	r19, r31
    152c:	20 f0       	brcs	.+8      	; 0x1536 <xQueueCRReceiveFromISR+0x34>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    152e:	28 81       	ld	r18, Y
    1530:	39 81       	ldd	r19, Y+1	; 0x01
    1532:	3f 83       	std	Y+7, r19	; 0x07
    1534:	2e 83       	std	Y+6, r18	; 0x06
			}
			--( pxQueue->uxMessagesWaiting );
    1536:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1538:	21 50       	subi	r18, 0x01	; 1
    153a:	2a 8f       	std	Y+26, r18	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    153c:	6e 81       	ldd	r22, Y+6	; 0x06
    153e:	7f 81       	ldd	r23, Y+7	; 0x07
    1540:	50 e0       	ldi	r21, 0x00	; 0
    1542:	0e 94 57 11 	call	0x22ae	; 0x22ae <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1546:	f8 01       	movw	r30, r16
    1548:	80 81       	ld	r24, Z
    154a:	88 23       	and	r24, r24
    154c:	11 f0       	breq	.+4      	; 0x1552 <xQueueCRReceiveFromISR+0x50>
						*pxCoRoutineWoken = pdTRUE;
					}
				}
			}

			xReturn = pdPASS;
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	0e c0       	rjmp	.+28     	; 0x156e <xQueueCRReceiveFromISR+0x6c>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1552:	88 85       	ldd	r24, Y+8	; 0x08
    1554:	88 23       	and	r24, r24
    1556:	d9 f3       	breq	.-10     	; 0x154e <xQueueCRReceiveFromISR+0x4c>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1558:	ce 01       	movw	r24, r28
    155a:	08 96       	adiw	r24, 0x08	; 8
    155c:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xCoRoutineRemoveFromEventList>
    1560:	88 23       	and	r24, r24
    1562:	a9 f3       	breq	.-22     	; 0x154e <xQueueCRReceiveFromISR+0x4c>
					{
						*pxCoRoutineWoken = pdTRUE;
    1564:	81 e0       	ldi	r24, 0x01	; 1
    1566:	f8 01       	movw	r30, r16
    1568:	80 83       	st	Z, r24
    156a:	01 c0       	rjmp	.+2      	; 0x156e <xQueueCRReceiveFromISR+0x6c>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    156c:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    156e:	df 91       	pop	r29
    1570:	cf 91       	pop	r28
    1572:	1f 91       	pop	r17
    1574:	0f 91       	pop	r16
    1576:	08 95       	ret

00001578 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList * const pxList )
{
    1578:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    157a:	03 96       	adiw	r24, 0x03	; 3
    157c:	92 83       	std	Z+2, r25	; 0x02
    157e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1580:	2f ef       	ldi	r18, 0xFF	; 255
    1582:	3f ef       	ldi	r19, 0xFF	; 255
    1584:	34 83       	std	Z+4, r19	; 0x04
    1586:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1588:	96 83       	std	Z+6, r25	; 0x06
    158a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    158c:	90 87       	std	Z+8, r25	; 0x08
    158e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1590:	10 82       	st	Z, r1
    1592:	08 95       	ret

00001594 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1594:	fc 01       	movw	r30, r24
    1596:	11 86       	std	Z+9, r1	; 0x09
    1598:	10 86       	std	Z+8, r1	; 0x08
    159a:	08 95       	ret

0000159c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList * const pxList, xListItem * const pxNewListItem )
{
    159c:	cf 93       	push	r28
    159e:	df 93       	push	r29
    15a0:	9c 01       	movw	r18, r24
    15a2:	fb 01       	movw	r30, r22
xListItem * pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;
    15a4:	dc 01       	movw	r26, r24
    15a6:	11 96       	adiw	r26, 0x01	; 1
    15a8:	cd 91       	ld	r28, X+
    15aa:	dc 91       	ld	r29, X
    15ac:	12 97       	sbiw	r26, 0x02	; 2

	pxNewListItem->pxNext = pxIndex;
    15ae:	d3 83       	std	Z+3, r29	; 0x03
    15b0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    15b2:	8c 81       	ldd	r24, Y+4	; 0x04
    15b4:	9d 81       	ldd	r25, Y+5	; 0x05
    15b6:	95 83       	std	Z+5, r25	; 0x05
    15b8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    15ba:	8c 81       	ldd	r24, Y+4	; 0x04
    15bc:	9d 81       	ldd	r25, Y+5	; 0x05
    15be:	dc 01       	movw	r26, r24
    15c0:	13 96       	adiw	r26, 0x03	; 3
    15c2:	7c 93       	st	X, r23
    15c4:	6e 93       	st	-X, r22
    15c6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    15c8:	7d 83       	std	Y+5, r23	; 0x05
    15ca:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    15cc:	31 87       	std	Z+9, r19	; 0x09
    15ce:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    15d0:	f9 01       	movw	r30, r18
    15d2:	80 81       	ld	r24, Z
    15d4:	8f 5f       	subi	r24, 0xFF	; 255
    15d6:	80 83       	st	Z, r24
}
    15d8:	df 91       	pop	r29
    15da:	cf 91       	pop	r28
    15dc:	08 95       	ret

000015de <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
{
    15de:	0f 93       	push	r16
    15e0:	1f 93       	push	r17
    15e2:	cf 93       	push	r28
    15e4:	df 93       	push	r29
    15e6:	8c 01       	movw	r16, r24
    15e8:	fb 01       	movw	r30, r22
xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    15ea:	80 81       	ld	r24, Z
    15ec:	91 81       	ldd	r25, Z+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    15ee:	8f 3f       	cpi	r24, 0xFF	; 255
    15f0:	2f ef       	ldi	r18, 0xFF	; 255
    15f2:	92 07       	cpc	r25, r18
    15f4:	21 f4       	brne	.+8      	; 0x15fe <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    15f6:	e8 01       	movw	r28, r16
    15f8:	af 81       	ldd	r26, Y+7	; 0x07
    15fa:	b8 85       	ldd	r27, Y+8	; 0x08
    15fc:	0e c0       	rjmp	.+28     	; 0x161a <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15fe:	d8 01       	movw	r26, r16
    1600:	13 96       	adiw	r26, 0x03	; 3
    1602:	01 c0       	rjmp	.+2      	; 0x1606 <vListInsert+0x28>
    1604:	d9 01       	movw	r26, r18
    1606:	12 96       	adiw	r26, 0x02	; 2
    1608:	2d 91       	ld	r18, X+
    160a:	3c 91       	ld	r19, X
    160c:	13 97       	sbiw	r26, 0x03	; 3
    160e:	e9 01       	movw	r28, r18
    1610:	48 81       	ld	r20, Y
    1612:	59 81       	ldd	r21, Y+1	; 0x01
    1614:	84 17       	cp	r24, r20
    1616:	95 07       	cpc	r25, r21
    1618:	a8 f7       	brcc	.-22     	; 0x1604 <vListInsert+0x26>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    161a:	12 96       	adiw	r26, 0x02	; 2
    161c:	8d 91       	ld	r24, X+
    161e:	9c 91       	ld	r25, X
    1620:	13 97       	sbiw	r26, 0x03	; 3
    1622:	93 83       	std	Z+3, r25	; 0x03
    1624:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1626:	ec 01       	movw	r28, r24
    1628:	fd 83       	std	Y+5, r31	; 0x05
    162a:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    162c:	b5 83       	std	Z+5, r27	; 0x05
    162e:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1630:	13 96       	adiw	r26, 0x03	; 3
    1632:	fc 93       	st	X, r31
    1634:	ee 93       	st	-X, r30
    1636:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1638:	11 87       	std	Z+9, r17	; 0x09
    163a:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    163c:	f8 01       	movw	r30, r16
    163e:	80 81       	ld	r24, Z
    1640:	8f 5f       	subi	r24, 0xFF	; 255
    1642:	80 83       	st	Z, r24
}
    1644:	df 91       	pop	r29
    1646:	cf 91       	pop	r28
    1648:	1f 91       	pop	r17
    164a:	0f 91       	pop	r16
    164c:	08 95       	ret

0000164e <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
{
    164e:	cf 93       	push	r28
    1650:	df 93       	push	r29
    1652:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1654:	a2 81       	ldd	r26, Z+2	; 0x02
    1656:	b3 81       	ldd	r27, Z+3	; 0x03
    1658:	84 81       	ldd	r24, Z+4	; 0x04
    165a:	95 81       	ldd	r25, Z+5	; 0x05
    165c:	15 96       	adiw	r26, 0x05	; 5
    165e:	9c 93       	st	X, r25
    1660:	8e 93       	st	-X, r24
    1662:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1664:	c4 81       	ldd	r28, Z+4	; 0x04
    1666:	d5 81       	ldd	r29, Z+5	; 0x05
    1668:	bb 83       	std	Y+3, r27	; 0x03
    166a:	aa 83       	std	Y+2, r26	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    166c:	a0 85       	ldd	r26, Z+8	; 0x08
    166e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1670:	11 96       	adiw	r26, 0x01	; 1
    1672:	8d 91       	ld	r24, X+
    1674:	9c 91       	ld	r25, X
    1676:	12 97       	sbiw	r26, 0x02	; 2
    1678:	8e 17       	cp	r24, r30
    167a:	9f 07       	cpc	r25, r31
    167c:	21 f4       	brne	.+8      	; 0x1686 <uxListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    167e:	12 96       	adiw	r26, 0x02	; 2
    1680:	dc 93       	st	X, r29
    1682:	ce 93       	st	-X, r28
    1684:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1686:	11 86       	std	Z+9, r1	; 0x09
    1688:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    168a:	8c 91       	ld	r24, X
    168c:	81 50       	subi	r24, 0x01	; 1
    168e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1690:	df 91       	pop	r29
    1692:	cf 91       	pop	r28
    1694:	08 95       	ret

00001696 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1696:	df 92       	push	r13
    1698:	ef 92       	push	r14
    169a:	ff 92       	push	r15
    169c:	0f 93       	push	r16
    169e:	1f 93       	push	r17
    16a0:	cf 93       	push	r28
    16a2:	df 93       	push	r29
    16a4:	7c 01       	movw	r14, r24
    16a6:	d6 2e       	mov	r13, r22
    16a8:	14 2f       	mov	r17, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    16aa:	8a e1       	ldi	r24, 0x1A	; 26
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <pvPortMalloc>
    16b2:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    16b4:	00 97       	sbiw	r24, 0x00	; 0
    16b6:	09 f4       	brne	.+2      	; 0x16ba <xCoRoutineCreate+0x24>
    16b8:	59 c0       	rjmp	.+178    	; 0x176c <xCoRoutineCreate+0xd6>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    16ba:	80 91 a4 01 	lds	r24, 0x01A4
    16be:	90 91 a5 01 	lds	r25, 0x01A5
    16c2:	89 2b       	or	r24, r25
    16c4:	21 f5       	brne	.+72     	; 0x170e <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    16c6:	d0 93 a5 01 	sts	0x01A5, r29
    16ca:	c0 93 a4 01 	sts	0x01A4, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    16ce:	87 ea       	ldi	r24, 0xA7	; 167
    16d0:	91 e0       	ldi	r25, 0x01	; 1
    16d2:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>
    16d6:	80 eb       	ldi	r24, 0xB0	; 176
    16d8:	91 e0       	ldi	r25, 0x01	; 1
    16da:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    16de:	89 eb       	ldi	r24, 0xB9	; 185
    16e0:	91 e0       	ldi	r25, 0x01	; 1
    16e2:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    16e6:	82 ec       	ldi	r24, 0xC2	; 194
    16e8:	91 e0       	ldi	r25, 0x01	; 1
    16ea:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    16ee:	8b ec       	ldi	r24, 0xCB	; 203
    16f0:	91 e0       	ldi	r25, 0x01	; 1
    16f2:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    16f6:	89 eb       	ldi	r24, 0xB9	; 185
    16f8:	91 e0       	ldi	r25, 0x01	; 1
    16fa:	90 93 d5 01 	sts	0x01D5, r25
    16fe:	80 93 d4 01 	sts	0x01D4, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1702:	82 ec       	ldi	r24, 0xC2	; 194
    1704:	91 e0       	ldi	r25, 0x01	; 1
    1706:	90 93 d7 01 	sts	0x01D7, r25
    170a:	80 93 d6 01 	sts	0x01D6, r24
    170e:	dd 20       	and	r13, r13
    1710:	11 f0       	breq	.+4      	; 0x1716 <xCoRoutineCreate+0x80>
    1712:	dd 24       	eor	r13, r13
    1714:	d3 94       	inc	r13
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1716:	19 8e       	std	Y+25, r1	; 0x19
    1718:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    171a:	de 8a       	std	Y+22, r13	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    171c:	1f 8b       	std	Y+23, r17	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    171e:	fe 01       	movw	r30, r28
    1720:	e1 92       	st	Z+, r14
    1722:	f1 92       	st	Z+, r15
    1724:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1726:	cf 01       	movw	r24, r30
    1728:	0e 94 ca 0a 	call	0x1594	; 0x1594 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    172c:	ce 01       	movw	r24, r28
    172e:	0c 96       	adiw	r24, 0x0c	; 12
    1730:	0e 94 ca 0a 	call	0x1594	; 0x1594 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1734:	d9 87       	std	Y+9, r29	; 0x09
    1736:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1738:	db 8b       	std	Y+19, r29	; 0x13
    173a:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    173c:	84 e0       	ldi	r24, 0x04	; 4
    173e:	90 e0       	ldi	r25, 0x00	; 0
    1740:	8d 19       	sub	r24, r13
    1742:	91 09       	sbc	r25, r1
    1744:	9d 87       	std	Y+13, r25	; 0x0d
    1746:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1748:	8e 89       	ldd	r24, Y+22	; 0x16
    174a:	90 91 a6 01 	lds	r25, 0x01A6
    174e:	98 17       	cp	r25, r24
    1750:	10 f4       	brcc	.+4      	; 0x1756 <xCoRoutineCreate+0xc0>
    1752:	80 93 a6 01 	sts	0x01A6, r24
    1756:	f9 e0       	ldi	r31, 0x09	; 9
    1758:	8f 9f       	mul	r24, r31
    175a:	c0 01       	movw	r24, r0
    175c:	11 24       	eor	r1, r1
    175e:	b8 01       	movw	r22, r16
    1760:	89 55       	subi	r24, 0x59	; 89
    1762:	9e 4f       	sbci	r25, 0xFE	; 254
    1764:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInsertEnd>

		xReturn = pdPASS;
    1768:	81 e0       	ldi	r24, 0x01	; 1
    176a:	01 c0       	rjmp	.+2      	; 0x176e <xCoRoutineCreate+0xd8>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    176c:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    176e:	df 91       	pop	r29
    1770:	cf 91       	pop	r28
    1772:	1f 91       	pop	r17
    1774:	0f 91       	pop	r16
    1776:	ff 90       	pop	r15
    1778:	ef 90       	pop	r14
    177a:	df 90       	pop	r13
    177c:	08 95       	ret

0000177e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    177e:	0f 93       	push	r16
    1780:	1f 93       	push	r17
    1782:	cf 93       	push	r28
    1784:	df 93       	push	r29
    1786:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1788:	c0 91 d8 01 	lds	r28, 0x01D8
    178c:	d0 91 d9 01 	lds	r29, 0x01D9
    1790:	c8 0f       	add	r28, r24
    1792:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1794:	80 91 a4 01 	lds	r24, 0x01A4
    1798:	90 91 a5 01 	lds	r25, 0x01A5
    179c:	02 96       	adiw	r24, 0x02	; 2
    179e:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    17a2:	e0 91 a4 01 	lds	r30, 0x01A4
    17a6:	f0 91 a5 01 	lds	r31, 0x01A5
    17aa:	d3 83       	std	Z+3, r29	; 0x03
    17ac:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    17ae:	80 91 d8 01 	lds	r24, 0x01D8
    17b2:	90 91 d9 01 	lds	r25, 0x01D9
    17b6:	bf 01       	movw	r22, r30
    17b8:	6e 5f       	subi	r22, 0xFE	; 254
    17ba:	7f 4f       	sbci	r23, 0xFF	; 255
    17bc:	c8 17       	cp	r28, r24
    17be:	d9 07       	cpc	r29, r25
    17c0:	28 f4       	brcc	.+10     	; 0x17cc <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    17c2:	80 91 d6 01 	lds	r24, 0x01D6
    17c6:	90 91 d7 01 	lds	r25, 0x01D7
    17ca:	04 c0       	rjmp	.+8      	; 0x17d4 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    17cc:	80 91 d4 01 	lds	r24, 0x01D4
    17d0:	90 91 d5 01 	lds	r25, 0x01D5
    17d4:	0e 94 ef 0a 	call	0x15de	; 0x15de <vListInsert>
	}

	if( pxEventList )
    17d8:	01 15       	cp	r16, r1
    17da:	11 05       	cpc	r17, r1
    17dc:	69 f0       	breq	.+26     	; 0x17f8 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    17de:	60 91 a4 01 	lds	r22, 0x01A4
    17e2:	70 91 a5 01 	lds	r23, 0x01A5
    17e6:	64 5f       	subi	r22, 0xF4	; 244
    17e8:	7f 4f       	sbci	r23, 0xFF	; 255
    17ea:	c8 01       	movw	r24, r16
	}
}
    17ec:	df 91       	pop	r29
    17ee:	cf 91       	pop	r28
    17f0:	1f 91       	pop	r17
    17f2:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    17f4:	0c 94 ef 0a 	jmp	0x15de	; 0x15de <vListInsert>
	}
}
    17f8:	df 91       	pop	r29
    17fa:	cf 91       	pop	r28
    17fc:	1f 91       	pop	r17
    17fe:	0f 91       	pop	r16
    1800:	08 95       	ret

00001802 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1802:	ff 92       	push	r15
    1804:	0f 93       	push	r16
    1806:	1f 93       	push	r17
    1808:	cf 93       	push	r28
    180a:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    180c:	99 e0       	ldi	r25, 0x09	; 9
    180e:	f9 2e       	mov	r15, r25
    1810:	21 c0       	rjmp	.+66     	; 0x1854 <vCoRoutineSchedule+0x52>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1812:	f8 94       	cli
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1814:	e0 91 d0 01 	lds	r30, 0x01D0
    1818:	f0 91 d1 01 	lds	r31, 0x01D1
    181c:	c6 81       	ldd	r28, Z+6	; 0x06
    181e:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1820:	ce 01       	movw	r24, r28
    1822:	0c 96       	adiw	r24, 0x0c	; 12
    1824:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1828:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    182a:	8e 01       	movw	r16, r28
    182c:	0e 5f       	subi	r16, 0xFE	; 254
    182e:	1f 4f       	sbci	r17, 0xFF	; 255
    1830:	c8 01       	movw	r24, r16
    1832:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1836:	8e 89       	ldd	r24, Y+22	; 0x16
    1838:	90 91 a6 01 	lds	r25, 0x01A6
    183c:	98 17       	cp	r25, r24
    183e:	10 f4       	brcc	.+4      	; 0x1844 <vCoRoutineSchedule+0x42>
    1840:	80 93 a6 01 	sts	0x01A6, r24
    1844:	f8 9e       	mul	r15, r24
    1846:	c0 01       	movw	r24, r0
    1848:	11 24       	eor	r1, r1
    184a:	b8 01       	movw	r22, r16
    184c:	89 55       	subi	r24, 0x59	; 89
    184e:	9e 4f       	sbci	r25, 0xFE	; 254
    1850:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1854:	80 91 cb 01 	lds	r24, 0x01CB
    1858:	81 11       	cpse	r24, r1
    185a:	db cf       	rjmp	.-74     	; 0x1812 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    185c:	0e 94 37 04 	call	0x86e	; 0x86e <xTaskGetTickCount>
    1860:	20 91 da 01 	lds	r18, 0x01DA
    1864:	30 91 db 01 	lds	r19, 0x01DB
    1868:	82 1b       	sub	r24, r18
    186a:	93 0b       	sbc	r25, r19
    186c:	90 93 dd 01 	sts	0x01DD, r25
    1870:	80 93 dc 01 	sts	0x01DC, r24
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1874:	89 e0       	ldi	r24, 0x09	; 9
    1876:	f8 2e       	mov	r15, r24
    1878:	53 c0       	rjmp	.+166    	; 0x1920 <vCoRoutineSchedule+0x11e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    187a:	01 96       	adiw	r24, 0x01	; 1
    187c:	90 93 d9 01 	sts	0x01D9, r25
    1880:	80 93 d8 01 	sts	0x01D8, r24
		xPassedTicks--;
    1884:	21 50       	subi	r18, 0x01	; 1
    1886:	31 09       	sbc	r19, r1
    1888:	30 93 dd 01 	sts	0x01DD, r19
    188c:	20 93 dc 01 	sts	0x01DC, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1890:	89 2b       	or	r24, r25
    1892:	09 f0       	breq	.+2      	; 0x1896 <vCoRoutineSchedule+0x94>
    1894:	3e c0       	rjmp	.+124    	; 0x1912 <vCoRoutineSchedule+0x110>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1896:	80 91 d4 01 	lds	r24, 0x01D4
    189a:	90 91 d5 01 	lds	r25, 0x01D5
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    189e:	20 91 d6 01 	lds	r18, 0x01D6
    18a2:	30 91 d7 01 	lds	r19, 0x01D7
    18a6:	30 93 d5 01 	sts	0x01D5, r19
    18aa:	20 93 d4 01 	sts	0x01D4, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    18ae:	90 93 d7 01 	sts	0x01D7, r25
    18b2:	80 93 d6 01 	sts	0x01D6, r24
    18b6:	2d c0       	rjmp	.+90     	; 0x1912 <vCoRoutineSchedule+0x110>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    18b8:	05 80       	ldd	r0, Z+5	; 0x05
    18ba:	f6 81       	ldd	r31, Z+6	; 0x06
    18bc:	e0 2d       	mov	r30, r0
    18be:	c6 81       	ldd	r28, Z+6	; 0x06
    18c0:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    18c2:	20 91 d8 01 	lds	r18, 0x01D8
    18c6:	30 91 d9 01 	lds	r19, 0x01D9
    18ca:	8a 81       	ldd	r24, Y+2	; 0x02
    18cc:	9b 81       	ldd	r25, Y+3	; 0x03
    18ce:	28 17       	cp	r18, r24
    18d0:	39 07       	cpc	r19, r25
    18d2:	30 f1       	brcs	.+76     	; 0x1920 <vCoRoutineSchedule+0x11e>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    18d4:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
    18d6:	8e 01       	movw	r16, r28
    18d8:	0e 5f       	subi	r16, 0xFE	; 254
    18da:	1f 4f       	sbci	r17, 0xFF	; 255
    18dc:	c8 01       	movw	r24, r16
    18de:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    18e2:	8c 89       	ldd	r24, Y+20	; 0x14
    18e4:	9d 89       	ldd	r25, Y+21	; 0x15
    18e6:	89 2b       	or	r24, r25
    18e8:	21 f0       	breq	.+8      	; 0x18f2 <vCoRoutineSchedule+0xf0>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    18ea:	ce 01       	movw	r24, r28
    18ec:	0c 96       	adiw	r24, 0x0c	; 12
    18ee:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    18f2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    18f4:	8e 89       	ldd	r24, Y+22	; 0x16
    18f6:	90 91 a6 01 	lds	r25, 0x01A6
    18fa:	98 17       	cp	r25, r24
    18fc:	10 f4       	brcc	.+4      	; 0x1902 <vCoRoutineSchedule+0x100>
    18fe:	80 93 a6 01 	sts	0x01A6, r24
    1902:	f8 9e       	mul	r15, r24
    1904:	c0 01       	movw	r24, r0
    1906:	11 24       	eor	r1, r1
    1908:	b8 01       	movw	r22, r16
    190a:	89 55       	subi	r24, 0x59	; 89
    190c:	9e 4f       	sbci	r25, 0xFE	; 254
    190e:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1912:	e0 91 d4 01 	lds	r30, 0x01D4
    1916:	f0 91 d5 01 	lds	r31, 0x01D5
    191a:	80 81       	ld	r24, Z
    191c:	81 11       	cpse	r24, r1
    191e:	cc cf       	rjmp	.-104    	; 0x18b8 <vCoRoutineSchedule+0xb6>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1920:	20 91 dc 01 	lds	r18, 0x01DC
    1924:	30 91 dd 01 	lds	r19, 0x01DD
    1928:	80 91 d8 01 	lds	r24, 0x01D8
    192c:	90 91 d9 01 	lds	r25, 0x01D9
    1930:	21 15       	cp	r18, r1
    1932:	31 05       	cpc	r19, r1
    1934:	09 f0       	breq	.+2      	; 0x1938 <vCoRoutineSchedule+0x136>
    1936:	a1 cf       	rjmp	.-190    	; 0x187a <vCoRoutineSchedule+0x78>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1938:	90 93 db 01 	sts	0x01DB, r25
    193c:	80 93 da 01 	sts	0x01DA, r24
    1940:	80 91 a6 01 	lds	r24, 0x01A6

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1944:	29 e0       	ldi	r18, 0x09	; 9
    1946:	06 c0       	rjmp	.+12     	; 0x1954 <vCoRoutineSchedule+0x152>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1948:	81 11       	cpse	r24, r1
    194a:	03 c0       	rjmp	.+6      	; 0x1952 <vCoRoutineSchedule+0x150>
    194c:	10 92 a6 01 	sts	0x01A6, r1
    1950:	33 c0       	rjmp	.+102    	; 0x19b8 <vCoRoutineSchedule+0x1b6>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1952:	81 50       	subi	r24, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1954:	28 9f       	mul	r18, r24
    1956:	f0 01       	movw	r30, r0
    1958:	11 24       	eor	r1, r1
    195a:	e9 55       	subi	r30, 0x59	; 89
    195c:	fe 4f       	sbci	r31, 0xFE	; 254
    195e:	90 81       	ld	r25, Z
    1960:	99 23       	and	r25, r25
    1962:	91 f3       	breq	.-28     	; 0x1948 <vCoRoutineSchedule+0x146>
    1964:	80 93 a6 01 	sts	0x01A6, r24
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1968:	a1 81       	ldd	r26, Z+1	; 0x01
    196a:	b2 81       	ldd	r27, Z+2	; 0x02
    196c:	12 96       	adiw	r26, 0x02	; 2
    196e:	0d 90       	ld	r0, X+
    1970:	bc 91       	ld	r27, X
    1972:	a0 2d       	mov	r26, r0
    1974:	b2 83       	std	Z+2, r27	; 0x02
    1976:	a1 83       	std	Z+1, r26	; 0x01
    1978:	cf 01       	movw	r24, r30
    197a:	03 96       	adiw	r24, 0x03	; 3
    197c:	a8 17       	cp	r26, r24
    197e:	b9 07       	cpc	r27, r25
    1980:	31 f4       	brne	.+12     	; 0x198e <vCoRoutineSchedule+0x18c>
    1982:	12 96       	adiw	r26, 0x02	; 2
    1984:	8d 91       	ld	r24, X+
    1986:	9c 91       	ld	r25, X
    1988:	13 97       	sbiw	r26, 0x03	; 3
    198a:	92 83       	std	Z+2, r25	; 0x02
    198c:	81 83       	std	Z+1, r24	; 0x01
    198e:	01 80       	ldd	r0, Z+1	; 0x01
    1990:	f2 81       	ldd	r31, Z+2	; 0x02
    1992:	e0 2d       	mov	r30, r0
    1994:	86 81       	ldd	r24, Z+6	; 0x06
    1996:	97 81       	ldd	r25, Z+7	; 0x07
    1998:	90 93 a5 01 	sts	0x01A5, r25
    199c:	80 93 a4 01 	sts	0x01A4, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    19a0:	dc 01       	movw	r26, r24
    19a2:	ed 91       	ld	r30, X+
    19a4:	fc 91       	ld	r31, X
    19a6:	11 97       	sbiw	r26, 0x01	; 1
    19a8:	57 96       	adiw	r26, 0x17	; 23
    19aa:	6c 91       	ld	r22, X

	return;
}
    19ac:	df 91       	pop	r29
    19ae:	cf 91       	pop	r28
    19b0:	1f 91       	pop	r17
    19b2:	0f 91       	pop	r16
    19b4:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    19b6:	09 94       	ijmp

	return;
}
    19b8:	df 91       	pop	r29
    19ba:	cf 91       	pop	r28
    19bc:	1f 91       	pop	r17
    19be:	0f 91       	pop	r16
    19c0:	ff 90       	pop	r15
    19c2:	08 95       	ret

000019c4 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    19c4:	0f 93       	push	r16
    19c6:	1f 93       	push	r17
    19c8:	cf 93       	push	r28
    19ca:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    19cc:	dc 01       	movw	r26, r24
    19ce:	15 96       	adiw	r26, 0x05	; 5
    19d0:	ed 91       	ld	r30, X+
    19d2:	fc 91       	ld	r31, X
    19d4:	16 97       	sbiw	r26, 0x06	; 6
    19d6:	c6 81       	ldd	r28, Z+6	; 0x06
    19d8:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    19da:	8e 01       	movw	r16, r28
    19dc:	04 5f       	subi	r16, 0xF4	; 244
    19de:	1f 4f       	sbci	r17, 0xFF	; 255
    19e0:	c8 01       	movw	r24, r16
    19e2:	0e 94 27 0b 	call	0x164e	; 0x164e <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    19e6:	b8 01       	movw	r22, r16
    19e8:	8b ec       	ldi	r24, 0xCB	; 203
    19ea:	91 e0       	ldi	r25, 0x01	; 1
    19ec:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    19f0:	e0 91 a4 01 	lds	r30, 0x01A4
    19f4:	f0 91 a5 01 	lds	r31, 0x01A5
    19f8:	81 e0       	ldi	r24, 0x01	; 1
    19fa:	2e 89       	ldd	r18, Y+22	; 0x16
    19fc:	96 89       	ldd	r25, Z+22	; 0x16
    19fe:	29 17       	cp	r18, r25
    1a00:	08 f4       	brcc	.+2      	; 0x1a04 <xCoRoutineRemoveFromEventList+0x40>
    1a02:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1a04:	df 91       	pop	r29
    1a06:	cf 91       	pop	r28
    1a08:	1f 91       	pop	r17
    1a0a:	0f 91       	pop	r16
    1a0c:	08 95       	ret

00001a0e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1a0e:	cf 93       	push	r28
    1a10:	df 93       	push	r29
    1a12:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1a14:	0e 94 31 04 	call	0x862	; 0x862 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1a18:	80 91 de 01 	lds	r24, 0x01DE
    1a1c:	90 91 df 01 	lds	r25, 0x01DF
    1a20:	89 2b       	or	r24, r25
    1a22:	31 f4       	brne	.+12     	; 0x1a30 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    1a24:	81 ee       	ldi	r24, 0xE1	; 225
    1a26:	91 e0       	ldi	r25, 0x01	; 1
    1a28:	90 93 df 01 	sts	0x01DF, r25
    1a2c:	80 93 de 01 	sts	0x01DE, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1a30:	20 91 bc 07 	lds	r18, 0x07BC
    1a34:	30 91 bd 07 	lds	r19, 0x07BD
    1a38:	ce 01       	movw	r24, r28
    1a3a:	82 0f       	add	r24, r18
    1a3c:	93 1f       	adc	r25, r19
    1a3e:	8b 3d       	cpi	r24, 0xDB	; 219
    1a40:	45 e0       	ldi	r20, 0x05	; 5
    1a42:	94 07       	cpc	r25, r20
    1a44:	70 f4       	brcc	.+28     	; 0x1a62 <pvPortMalloc+0x54>
    1a46:	28 17       	cp	r18, r24
    1a48:	39 07       	cpc	r19, r25
    1a4a:	58 f4       	brcc	.+22     	; 0x1a62 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1a4c:	c0 91 de 01 	lds	r28, 0x01DE
    1a50:	d0 91 df 01 	lds	r29, 0x01DF
    1a54:	c2 0f       	add	r28, r18
    1a56:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    1a58:	90 93 bd 07 	sts	0x07BD, r25
    1a5c:	80 93 bc 07 	sts	0x07BC, r24
    1a60:	02 c0       	rjmp	.+4      	; 0x1a66 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1a62:	c0 e0       	ldi	r28, 0x00	; 0
    1a64:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}	
	xTaskResumeAll();
    1a66:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1a6a:	ce 01       	movw	r24, r28
    1a6c:	df 91       	pop	r29
    1a6e:	cf 91       	pop	r28
    1a70:	08 95       	ret

00001a72 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1a72:	08 95       	ret

00001a74 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1a74:	10 92 bd 07 	sts	0x07BD, r1
    1a78:	10 92 bc 07 	sts	0x07BC, r1
    1a7c:	08 95       	ret

00001a7e <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1a7e:	2b ed       	ldi	r18, 0xDB	; 219
    1a80:	35 e0       	ldi	r19, 0x05	; 5
    1a82:	80 91 bc 07 	lds	r24, 0x07BC
    1a86:	90 91 bd 07 	lds	r25, 0x07BD
    1a8a:	28 1b       	sub	r18, r24
    1a8c:	39 0b       	sbc	r19, r25
}
    1a8e:	c9 01       	movw	r24, r18
    1a90:	08 95       	ret

00001a92 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1a92:	31 e1       	ldi	r19, 0x11	; 17
    1a94:	fc 01       	movw	r30, r24
    1a96:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1a98:	31 97       	sbiw	r30, 0x01	; 1
    1a9a:	22 e2       	ldi	r18, 0x22	; 34
    1a9c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1a9e:	fc 01       	movw	r30, r24
    1aa0:	32 97       	sbiw	r30, 0x02	; 2
    1aa2:	a3 e3       	ldi	r26, 0x33	; 51
    1aa4:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1aa6:	fc 01       	movw	r30, r24
    1aa8:	33 97       	sbiw	r30, 0x03	; 3
    1aaa:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1aac:	fc 01       	movw	r30, r24
    1aae:	34 97       	sbiw	r30, 0x04	; 4
    1ab0:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1ab2:	fc 01       	movw	r30, r24
    1ab4:	35 97       	sbiw	r30, 0x05	; 5
    1ab6:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1ab8:	fc 01       	movw	r30, r24
    1aba:	36 97       	sbiw	r30, 0x06	; 6
    1abc:	60 e8       	ldi	r22, 0x80	; 128
    1abe:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1ac0:	fc 01       	movw	r30, r24
    1ac2:	37 97       	sbiw	r30, 0x07	; 7
    1ac4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1ac6:	fc 01       	movw	r30, r24
    1ac8:	38 97       	sbiw	r30, 0x08	; 8
    1aca:	62 e0       	ldi	r22, 0x02	; 2
    1acc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1ace:	fc 01       	movw	r30, r24
    1ad0:	39 97       	sbiw	r30, 0x09	; 9
    1ad2:	63 e0       	ldi	r22, 0x03	; 3
    1ad4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	3a 97       	sbiw	r30, 0x0a	; 10
    1ada:	64 e0       	ldi	r22, 0x04	; 4
    1adc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1ade:	fc 01       	movw	r30, r24
    1ae0:	3b 97       	sbiw	r30, 0x0b	; 11
    1ae2:	65 e0       	ldi	r22, 0x05	; 5
    1ae4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1ae6:	fc 01       	movw	r30, r24
    1ae8:	3c 97       	sbiw	r30, 0x0c	; 12
    1aea:	66 e0       	ldi	r22, 0x06	; 6
    1aec:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1aee:	fc 01       	movw	r30, r24
    1af0:	3d 97       	sbiw	r30, 0x0d	; 13
    1af2:	67 e0       	ldi	r22, 0x07	; 7
    1af4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1af6:	fc 01       	movw	r30, r24
    1af8:	3e 97       	sbiw	r30, 0x0e	; 14
    1afa:	68 e0       	ldi	r22, 0x08	; 8
    1afc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1afe:	fc 01       	movw	r30, r24
    1b00:	3f 97       	sbiw	r30, 0x0f	; 15
    1b02:	69 e0       	ldi	r22, 0x09	; 9
    1b04:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1b06:	fc 01       	movw	r30, r24
    1b08:	70 97       	sbiw	r30, 0x10	; 16
    1b0a:	60 e1       	ldi	r22, 0x10	; 16
    1b0c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1b0e:	fc 01       	movw	r30, r24
    1b10:	71 97       	sbiw	r30, 0x11	; 17
    1b12:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1b14:	fc 01       	movw	r30, r24
    1b16:	72 97       	sbiw	r30, 0x12	; 18
    1b18:	32 e1       	ldi	r19, 0x12	; 18
    1b1a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1b1c:	fc 01       	movw	r30, r24
    1b1e:	73 97       	sbiw	r30, 0x13	; 19
    1b20:	33 e1       	ldi	r19, 0x13	; 19
    1b22:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1b24:	fc 01       	movw	r30, r24
    1b26:	74 97       	sbiw	r30, 0x14	; 20
    1b28:	34 e1       	ldi	r19, 0x14	; 20
    1b2a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1b2c:	fc 01       	movw	r30, r24
    1b2e:	75 97       	sbiw	r30, 0x15	; 21
    1b30:	35 e1       	ldi	r19, 0x15	; 21
    1b32:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1b34:	fc 01       	movw	r30, r24
    1b36:	76 97       	sbiw	r30, 0x16	; 22
    1b38:	36 e1       	ldi	r19, 0x16	; 22
    1b3a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1b3c:	fc 01       	movw	r30, r24
    1b3e:	77 97       	sbiw	r30, 0x17	; 23
    1b40:	37 e1       	ldi	r19, 0x17	; 23
    1b42:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1b44:	fc 01       	movw	r30, r24
    1b46:	78 97       	sbiw	r30, 0x18	; 24
    1b48:	38 e1       	ldi	r19, 0x18	; 24
    1b4a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1b4c:	fc 01       	movw	r30, r24
    1b4e:	79 97       	sbiw	r30, 0x19	; 25
    1b50:	39 e1       	ldi	r19, 0x19	; 25
    1b52:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1b54:	fc 01       	movw	r30, r24
    1b56:	7a 97       	sbiw	r30, 0x1a	; 26
    1b58:	30 e2       	ldi	r19, 0x20	; 32
    1b5a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1b5c:	fc 01       	movw	r30, r24
    1b5e:	7b 97       	sbiw	r30, 0x1b	; 27
    1b60:	31 e2       	ldi	r19, 0x21	; 33
    1b62:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1b64:	fc 01       	movw	r30, r24
    1b66:	7c 97       	sbiw	r30, 0x1c	; 28
    1b68:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	7d 97       	sbiw	r30, 0x1d	; 29
    1b6e:	23 e2       	ldi	r18, 0x23	; 35
    1b70:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1b72:	fc 01       	movw	r30, r24
    1b74:	7e 97       	sbiw	r30, 0x1e	; 30
    1b76:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1b78:	fc 01       	movw	r30, r24
    1b7a:	7f 97       	sbiw	r30, 0x1f	; 31
    1b7c:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1b7e:	fc 01       	movw	r30, r24
    1b80:	b0 97       	sbiw	r30, 0x20	; 32
    1b82:	26 e2       	ldi	r18, 0x26	; 38
    1b84:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1b86:	fc 01       	movw	r30, r24
    1b88:	b1 97       	sbiw	r30, 0x21	; 33
    1b8a:	27 e2       	ldi	r18, 0x27	; 39
    1b8c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1b8e:	fc 01       	movw	r30, r24
    1b90:	b2 97       	sbiw	r30, 0x22	; 34
    1b92:	28 e2       	ldi	r18, 0x28	; 40
    1b94:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1b96:	fc 01       	movw	r30, r24
    1b98:	b3 97       	sbiw	r30, 0x23	; 35
    1b9a:	29 e2       	ldi	r18, 0x29	; 41
    1b9c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1b9e:	fc 01       	movw	r30, r24
    1ba0:	b4 97       	sbiw	r30, 0x24	; 36
    1ba2:	20 e3       	ldi	r18, 0x30	; 48
    1ba4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1ba6:	fc 01       	movw	r30, r24
    1ba8:	b5 97       	sbiw	r30, 0x25	; 37
    1baa:	21 e3       	ldi	r18, 0x31	; 49
    1bac:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1bae:	9c 01       	movw	r18, r24
    1bb0:	26 52       	subi	r18, 0x26	; 38
    1bb2:	31 09       	sbc	r19, r1
}
    1bb4:	c9 01       	movw	r24, r18
    1bb6:	08 95       	ret

00001bb8 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    1bb8:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    1bbc:	89 ef       	ldi	r24, 0xF9	; 249
    1bbe:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1bc2:	8b e0       	ldi	r24, 0x0B	; 11
    1bc4:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    1bc8:	ef e6       	ldi	r30, 0x6F	; 111
    1bca:	f0 e0       	ldi	r31, 0x00	; 0
    1bcc:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1bce:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    1bd0:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1bd2:	a0 91 4b 01 	lds	r26, 0x014B
    1bd6:	b0 91 4c 01 	lds	r27, 0x014C
    1bda:	cd 91       	ld	r28, X+
    1bdc:	cd bf       	out	0x3d, r28	; 61
    1bde:	dd 91       	ld	r29, X+
    1be0:	de bf       	out	0x3e, r29	; 62
    1be2:	ff 91       	pop	r31
    1be4:	ef 91       	pop	r30
    1be6:	df 91       	pop	r29
    1be8:	cf 91       	pop	r28
    1bea:	bf 91       	pop	r27
    1bec:	af 91       	pop	r26
    1bee:	9f 91       	pop	r25
    1bf0:	8f 91       	pop	r24
    1bf2:	7f 91       	pop	r23
    1bf4:	6f 91       	pop	r22
    1bf6:	5f 91       	pop	r21
    1bf8:	4f 91       	pop	r20
    1bfa:	3f 91       	pop	r19
    1bfc:	2f 91       	pop	r18
    1bfe:	1f 91       	pop	r17
    1c00:	0f 91       	pop	r16
    1c02:	ff 90       	pop	r15
    1c04:	ef 90       	pop	r14
    1c06:	df 90       	pop	r13
    1c08:	cf 90       	pop	r12
    1c0a:	bf 90       	pop	r11
    1c0c:	af 90       	pop	r10
    1c0e:	9f 90       	pop	r9
    1c10:	8f 90       	pop	r8
    1c12:	7f 90       	pop	r7
    1c14:	6f 90       	pop	r6
    1c16:	5f 90       	pop	r5
    1c18:	4f 90       	pop	r4
    1c1a:	3f 90       	pop	r3
    1c1c:	2f 90       	pop	r2
    1c1e:	1f 90       	pop	r1
    1c20:	0f 90       	pop	r0
    1c22:	0f be       	out	0x3f, r0	; 63
    1c24:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1c26:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	08 95       	ret

00001c2c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1c2c:	08 95       	ret

00001c2e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1c2e:	0f 92       	push	r0
    1c30:	0f b6       	in	r0, 0x3f	; 63
    1c32:	f8 94       	cli
    1c34:	0f 92       	push	r0
    1c36:	1f 92       	push	r1
    1c38:	11 24       	eor	r1, r1
    1c3a:	2f 92       	push	r2
    1c3c:	3f 92       	push	r3
    1c3e:	4f 92       	push	r4
    1c40:	5f 92       	push	r5
    1c42:	6f 92       	push	r6
    1c44:	7f 92       	push	r7
    1c46:	8f 92       	push	r8
    1c48:	9f 92       	push	r9
    1c4a:	af 92       	push	r10
    1c4c:	bf 92       	push	r11
    1c4e:	cf 92       	push	r12
    1c50:	df 92       	push	r13
    1c52:	ef 92       	push	r14
    1c54:	ff 92       	push	r15
    1c56:	0f 93       	push	r16
    1c58:	1f 93       	push	r17
    1c5a:	2f 93       	push	r18
    1c5c:	3f 93       	push	r19
    1c5e:	4f 93       	push	r20
    1c60:	5f 93       	push	r21
    1c62:	6f 93       	push	r22
    1c64:	7f 93       	push	r23
    1c66:	8f 93       	push	r24
    1c68:	9f 93       	push	r25
    1c6a:	af 93       	push	r26
    1c6c:	bf 93       	push	r27
    1c6e:	cf 93       	push	r28
    1c70:	df 93       	push	r29
    1c72:	ef 93       	push	r30
    1c74:	ff 93       	push	r31
    1c76:	a0 91 4b 01 	lds	r26, 0x014B
    1c7a:	b0 91 4c 01 	lds	r27, 0x014C
    1c7e:	0d b6       	in	r0, 0x3d	; 61
    1c80:	0d 92       	st	X+, r0
    1c82:	0e b6       	in	r0, 0x3e	; 62
    1c84:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1c86:	0e 94 1d 06 	call	0xc3a	; 0xc3a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1c8a:	a0 91 4b 01 	lds	r26, 0x014B
    1c8e:	b0 91 4c 01 	lds	r27, 0x014C
    1c92:	cd 91       	ld	r28, X+
    1c94:	cd bf       	out	0x3d, r28	; 61
    1c96:	dd 91       	ld	r29, X+
    1c98:	de bf       	out	0x3e, r29	; 62
    1c9a:	ff 91       	pop	r31
    1c9c:	ef 91       	pop	r30
    1c9e:	df 91       	pop	r29
    1ca0:	cf 91       	pop	r28
    1ca2:	bf 91       	pop	r27
    1ca4:	af 91       	pop	r26
    1ca6:	9f 91       	pop	r25
    1ca8:	8f 91       	pop	r24
    1caa:	7f 91       	pop	r23
    1cac:	6f 91       	pop	r22
    1cae:	5f 91       	pop	r21
    1cb0:	4f 91       	pop	r20
    1cb2:	3f 91       	pop	r19
    1cb4:	2f 91       	pop	r18
    1cb6:	1f 91       	pop	r17
    1cb8:	0f 91       	pop	r16
    1cba:	ff 90       	pop	r15
    1cbc:	ef 90       	pop	r14
    1cbe:	df 90       	pop	r13
    1cc0:	cf 90       	pop	r12
    1cc2:	bf 90       	pop	r11
    1cc4:	af 90       	pop	r10
    1cc6:	9f 90       	pop	r9
    1cc8:	8f 90       	pop	r8
    1cca:	7f 90       	pop	r7
    1ccc:	6f 90       	pop	r6
    1cce:	5f 90       	pop	r5
    1cd0:	4f 90       	pop	r4
    1cd2:	3f 90       	pop	r3
    1cd4:	2f 90       	pop	r2
    1cd6:	1f 90       	pop	r1
    1cd8:	0f 90       	pop	r0
    1cda:	0f be       	out	0x3f, r0	; 63
    1cdc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1cde:	08 95       	ret

00001ce0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1ce0:	0f 92       	push	r0
    1ce2:	0f b6       	in	r0, 0x3f	; 63
    1ce4:	f8 94       	cli
    1ce6:	0f 92       	push	r0
    1ce8:	1f 92       	push	r1
    1cea:	11 24       	eor	r1, r1
    1cec:	2f 92       	push	r2
    1cee:	3f 92       	push	r3
    1cf0:	4f 92       	push	r4
    1cf2:	5f 92       	push	r5
    1cf4:	6f 92       	push	r6
    1cf6:	7f 92       	push	r7
    1cf8:	8f 92       	push	r8
    1cfa:	9f 92       	push	r9
    1cfc:	af 92       	push	r10
    1cfe:	bf 92       	push	r11
    1d00:	cf 92       	push	r12
    1d02:	df 92       	push	r13
    1d04:	ef 92       	push	r14
    1d06:	ff 92       	push	r15
    1d08:	0f 93       	push	r16
    1d0a:	1f 93       	push	r17
    1d0c:	2f 93       	push	r18
    1d0e:	3f 93       	push	r19
    1d10:	4f 93       	push	r20
    1d12:	5f 93       	push	r21
    1d14:	6f 93       	push	r22
    1d16:	7f 93       	push	r23
    1d18:	8f 93       	push	r24
    1d1a:	9f 93       	push	r25
    1d1c:	af 93       	push	r26
    1d1e:	bf 93       	push	r27
    1d20:	cf 93       	push	r28
    1d22:	df 93       	push	r29
    1d24:	ef 93       	push	r30
    1d26:	ff 93       	push	r31
    1d28:	a0 91 4b 01 	lds	r26, 0x014B
    1d2c:	b0 91 4c 01 	lds	r27, 0x014C
    1d30:	0d b6       	in	r0, 0x3d	; 61
    1d32:	0d 92       	st	X+, r0
    1d34:	0e b6       	in	r0, 0x3e	; 62
    1d36:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1d38:	0e 94 4b 04 	call	0x896	; 0x896 <xTaskIncrementTick>
    1d3c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1d3e:	0e 94 1d 06 	call	0xc3a	; 0xc3a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1d42:	a0 91 4b 01 	lds	r26, 0x014B
    1d46:	b0 91 4c 01 	lds	r27, 0x014C
    1d4a:	cd 91       	ld	r28, X+
    1d4c:	cd bf       	out	0x3d, r28	; 61
    1d4e:	dd 91       	ld	r29, X+
    1d50:	de bf       	out	0x3e, r29	; 62
    1d52:	ff 91       	pop	r31
    1d54:	ef 91       	pop	r30
    1d56:	df 91       	pop	r29
    1d58:	cf 91       	pop	r28
    1d5a:	bf 91       	pop	r27
    1d5c:	af 91       	pop	r26
    1d5e:	9f 91       	pop	r25
    1d60:	8f 91       	pop	r24
    1d62:	7f 91       	pop	r23
    1d64:	6f 91       	pop	r22
    1d66:	5f 91       	pop	r21
    1d68:	4f 91       	pop	r20
    1d6a:	3f 91       	pop	r19
    1d6c:	2f 91       	pop	r18
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	ff 90       	pop	r15
    1d74:	ef 90       	pop	r14
    1d76:	df 90       	pop	r13
    1d78:	cf 90       	pop	r12
    1d7a:	bf 90       	pop	r11
    1d7c:	af 90       	pop	r10
    1d7e:	9f 90       	pop	r9
    1d80:	8f 90       	pop	r8
    1d82:	7f 90       	pop	r7
    1d84:	6f 90       	pop	r6
    1d86:	5f 90       	pop	r5
    1d88:	4f 90       	pop	r4
    1d8a:	3f 90       	pop	r3
    1d8c:	2f 90       	pop	r2
    1d8e:	1f 90       	pop	r1
    1d90:	0f 90       	pop	r0
    1d92:	0f be       	out	0x3f, r0	; 63
    1d94:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d96:	08 95       	ret

00001d98 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1d98:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1d9c:	18 95       	reti

00001d9e <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex )
{
    1d9e:	0f 93       	push	r16
    1da0:	1f 93       	push	r17
    1da2:	cf 93       	push	r28
    1da4:	df 93       	push	r29
    1da6:	1f 92       	push	r1
    1da8:	cd b7       	in	r28, 0x3d	; 61
    1daa:	de b7       	in	r29, 0x3e	; 62
    1dac:	8c 01       	movw	r16, r24
static as we do not need it to maintain their state between blocks. */
signed portBASE_TYPE xResult;
unsigned portBASE_TYPE uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    1dae:	fc 01       	movw	r30, r24
    1db0:	80 8d       	ldd	r24, Z+24	; 0x18
    1db2:	91 8d       	ldd	r25, Z+25	; 0x19
    1db4:	8a 3b       	cpi	r24, 0xBA	; 186
    1db6:	f1 e0       	ldi	r31, 0x01	; 1
    1db8:	9f 07       	cpc	r25, r31
    1dba:	b1 f0       	breq	.+44     	; 0x1de8 <prvFlashCoRoutine+0x4a>
    1dbc:	8b 3b       	cpi	r24, 0xBB	; 187
    1dbe:	21 e0       	ldi	r18, 0x01	; 1
    1dc0:	92 07       	cpc	r25, r18
    1dc2:	51 f1       	breq	.+84     	; 0x1e18 <prvFlashCoRoutine+0x7a>
    1dc4:	89 2b       	or	r24, r25
    1dc6:	61 f5       	brne	.+88     	; 0x1e20 <prvFlashCoRoutine+0x82>
	( void ) uxIndex;
	
	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );		
    1dc8:	4f ef       	ldi	r20, 0xFF	; 255
    1dca:	5f ef       	ldi	r21, 0xFF	; 255
    1dcc:	be 01       	movw	r22, r28
    1dce:	6f 5f       	subi	r22, 0xFF	; 255
    1dd0:	7f 4f       	sbci	r23, 0xFF	; 255
    1dd2:	80 91 be 07 	lds	r24, 0x07BE
    1dd6:	90 91 bf 07 	lds	r25, 0x07BF
    1dda:	0e 94 1c 0a 	call	0x1438	; 0x1438 <xQueueCRReceive>
    1dde:	8c 3f       	cpi	r24, 0xFC	; 252
    1de0:	71 f4       	brne	.+28     	; 0x1dfe <prvFlashCoRoutine+0x60>
    1de2:	8a eb       	ldi	r24, 0xBA	; 186
    1de4:	91 e0       	ldi	r25, 0x01	; 1
    1de6:	0f c0       	rjmp	.+30     	; 0x1e06 <prvFlashCoRoutine+0x68>
    1de8:	40 e0       	ldi	r20, 0x00	; 0
    1dea:	50 e0       	ldi	r21, 0x00	; 0
    1dec:	be 01       	movw	r22, r28
    1dee:	6f 5f       	subi	r22, 0xFF	; 255
    1df0:	7f 4f       	sbci	r23, 0xFF	; 255
    1df2:	80 91 be 07 	lds	r24, 0x07BE
    1df6:	90 91 bf 07 	lds	r25, 0x07BF
    1dfa:	0e 94 1c 0a 	call	0x1438	; 0x1438 <xQueueCRReceive>
    1dfe:	8b 3f       	cpi	r24, 0xFB	; 251
    1e00:	31 f4       	brne	.+12     	; 0x1e0e <prvFlashCoRoutine+0x70>
    1e02:	8b eb       	ldi	r24, 0xBB	; 187
    1e04:	91 e0       	ldi	r25, 0x01	; 1
    1e06:	f8 01       	movw	r30, r16
    1e08:	91 8f       	std	Z+25, r25	; 0x19
    1e0a:	80 8f       	std	Z+24, r24	; 0x18
    1e0c:	09 c0       	rjmp	.+18     	; 0x1e20 <prvFlashCoRoutine+0x82>

		if( xResult != pdPASS )
    1e0e:	81 30       	cpi	r24, 0x01	; 1
    1e10:	19 f0       	breq	.+6      	; 0x1e18 <prvFlashCoRoutine+0x7a>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
    1e12:	10 92 03 01 	sts	0x0103, r1
    1e16:	d8 cf       	rjmp	.-80     	; 0x1dc8 <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED( uxLEDToFlash );
    1e18:	89 81       	ldd	r24, Y+1	; 0x01
    1e1a:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vParTestToggleLED>
    1e1e:	d4 cf       	rjmp	.-88     	; 0x1dc8 <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    1e20:	0f 90       	pop	r0
    1e22:	df 91       	pop	r29
    1e24:	cf 91       	pop	r28
    1e26:	1f 91       	pop	r17
    1e28:	0f 91       	pop	r16
    1e2a:	08 95       	ret

00001e2c <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex )
{
    1e2c:	0f 93       	push	r16
    1e2e:	1f 93       	push	r17
    1e30:	cf 93       	push	r28
    1e32:	df 93       	push	r29
    1e34:	1f 92       	push	r1
    1e36:	cd b7       	in	r28, 0x3d	; 61
    1e38:	de b7       	in	r29, 0x3e	; 62
    1e3a:	8c 01       	movw	r16, r24
    1e3c:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_RATE_MS,
																450 / portTICK_RATE_MS,
																500  / portTICK_RATE_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    1e3e:	fc 01       	movw	r30, r24
    1e40:	20 8d       	ldd	r18, Z+24	; 0x18
    1e42:	31 8d       	ldd	r19, Z+25	; 0x19
    1e44:	2a 37       	cpi	r18, 0x7A	; 122
    1e46:	f1 e0       	ldi	r31, 0x01	; 1
    1e48:	3f 07       	cpc	r19, r31
    1e4a:	d9 f0       	breq	.+54     	; 0x1e82 <prvFixedDelayCoRoutine+0x56>
    1e4c:	18 f4       	brcc	.+6      	; 0x1e54 <prvFixedDelayCoRoutine+0x28>
    1e4e:	23 2b       	or	r18, r19
    1e50:	41 f0       	breq	.+16     	; 0x1e62 <prvFixedDelayCoRoutine+0x36>
    1e52:	3e c0       	rjmp	.+124    	; 0x1ed0 <prvFixedDelayCoRoutine+0xa4>
    1e54:	2b 37       	cpi	r18, 0x7B	; 123
    1e56:	e1 e0       	ldi	r30, 0x01	; 1
    1e58:	3e 07       	cpc	r19, r30
    1e5a:	39 f1       	breq	.+78     	; 0x1eaa <prvFixedDelayCoRoutine+0x7e>
    1e5c:	2e 38       	cpi	r18, 0x8E	; 142
    1e5e:	31 40       	sbci	r19, 0x01	; 1
    1e60:	b9 f5       	brne	.+110    	; 0x1ed0 <prvFixedDelayCoRoutine+0xa4>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
    1e62:	40 e0       	ldi	r20, 0x00	; 0
    1e64:	50 e0       	ldi	r21, 0x00	; 0
    1e66:	be 01       	movw	r22, r28
    1e68:	6f 5f       	subi	r22, 0xFF	; 255
    1e6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e6c:	80 91 be 07 	lds	r24, 0x07BE
    1e70:	90 91 bf 07 	lds	r25, 0x07BF
    1e74:	0e 94 e6 09 	call	0x13cc	; 0x13cc <xQueueCRSend>
    1e78:	8c 3f       	cpi	r24, 0xFC	; 252
    1e7a:	71 f4       	brne	.+28     	; 0x1e98 <prvFixedDelayCoRoutine+0x6c>
    1e7c:	8a e7       	ldi	r24, 0x7A	; 122
    1e7e:	91 e0       	ldi	r25, 0x01	; 1
    1e80:	24 c0       	rjmp	.+72     	; 0x1eca <prvFixedDelayCoRoutine+0x9e>
    1e82:	40 e0       	ldi	r20, 0x00	; 0
    1e84:	50 e0       	ldi	r21, 0x00	; 0
    1e86:	be 01       	movw	r22, r28
    1e88:	6f 5f       	subi	r22, 0xFF	; 255
    1e8a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e8c:	80 91 be 07 	lds	r24, 0x07BE
    1e90:	90 91 bf 07 	lds	r25, 0x07BF
    1e94:	0e 94 e6 09 	call	0x13cc	; 0x13cc <xQueueCRSend>
    1e98:	8b 3f       	cpi	r24, 0xFB	; 251
    1e9a:	19 f4       	brne	.+6      	; 0x1ea2 <prvFixedDelayCoRoutine+0x76>
    1e9c:	8b e7       	ldi	r24, 0x7B	; 123
    1e9e:	91 e0       	ldi	r25, 0x01	; 1
    1ea0:	14 c0       	rjmp	.+40     	; 0x1eca <prvFixedDelayCoRoutine+0x9e>

		if( xResult != pdPASS )
    1ea2:	81 30       	cpi	r24, 0x01	; 1
    1ea4:	11 f0       	breq	.+4      	; 0x1eaa <prvFixedDelayCoRoutine+0x7e>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
    1ea6:	10 92 03 01 	sts	0x0103, r1
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
    1eaa:	e9 81       	ldd	r30, Y+1	; 0x01
    1eac:	f0 e0       	ldi	r31, 0x00	; 0
    1eae:	ee 0f       	add	r30, r30
    1eb0:	ff 1f       	adc	r31, r31
    1eb2:	ec 5f       	subi	r30, 0xFC	; 252
    1eb4:	fe 4f       	sbci	r31, 0xFE	; 254
    1eb6:	80 81       	ld	r24, Z
    1eb8:	91 81       	ldd	r25, Z+1	; 0x01
    1eba:	00 97       	sbiw	r24, 0x00	; 0
    1ebc:	21 f0       	breq	.+8      	; 0x1ec6 <prvFixedDelayCoRoutine+0x9a>
    1ebe:	60 e0       	ldi	r22, 0x00	; 0
    1ec0:	70 e0       	ldi	r23, 0x00	; 0
    1ec2:	0e 94 bf 0b 	call	0x177e	; 0x177e <vCoRoutineAddToDelayedList>
    1ec6:	8e e8       	ldi	r24, 0x8E	; 142
    1ec8:	91 e0       	ldi	r25, 0x01	; 1
    1eca:	f8 01       	movw	r30, r16
    1ecc:	91 8f       	std	Z+25, r25	; 0x19
    1ece:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    1ed0:	0f 90       	pop	r0
    1ed2:	df 91       	pop	r29
    1ed4:	cf 91       	pop	r28
    1ed6:	1f 91       	pop	r17
    1ed8:	0f 91       	pop	r16
    1eda:	08 95       	ret

00001edc <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( unsigned portBASE_TYPE uxNumberToCreate )
{
    1edc:	cf 93       	push	r28
    1ede:	df 93       	push	r29
    1ee0:	d8 2f       	mov	r29, r24
    1ee2:	89 30       	cpi	r24, 0x09	; 9
    1ee4:	08 f0       	brcs	.+2      	; 0x1ee8 <vStartFlashCoRoutines+0xc>
    1ee6:	d8 e0       	ldi	r29, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( unsigned portBASE_TYPE ) );
    1ee8:	40 e0       	ldi	r20, 0x00	; 0
    1eea:	61 e0       	ldi	r22, 0x01	; 1
    1eec:	81 e0       	ldi	r24, 0x01	; 1
    1eee:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xQueueGenericCreate>
    1ef2:	90 93 bf 07 	sts	0x07BF, r25
    1ef6:	80 93 be 07 	sts	0x07BE, r24

	if( xFlashQueue )
    1efa:	89 2b       	or	r24, r25
    1efc:	49 f4       	brne	.+18     	; 0x1f10 <vStartFlashCoRoutines+0x34>
    1efe:	13 c0       	rjmp	.+38     	; 0x1f26 <vStartFlashCoRoutines+0x4a>
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
    1f00:	4c 2f       	mov	r20, r28
    1f02:	60 e0       	ldi	r22, 0x00	; 0
    1f04:	86 e1       	ldi	r24, 0x16	; 22
    1f06:	9f e0       	ldi	r25, 0x0F	; 15
    1f08:	0e 94 4b 0b 	call	0x1696	; 0x1696 <xCoRoutineCreate>
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( unsigned portBASE_TYPE ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    1f0c:	cf 5f       	subi	r28, 0xFF	; 255
    1f0e:	01 c0       	rjmp	.+2      	; 0x1f12 <vStartFlashCoRoutines+0x36>
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( unsigned portBASE_TYPE ) );

	if( xFlashQueue )
    1f10:	c0 e0       	ldi	r28, 0x00	; 0
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    1f12:	cd 13       	cpse	r28, r29
    1f14:	f5 cf       	rjmp	.-22     	; 0x1f00 <vStartFlashCoRoutines+0x24>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    1f16:	40 e0       	ldi	r20, 0x00	; 0
    1f18:	61 e0       	ldi	r22, 0x01	; 1
    1f1a:	8f ec       	ldi	r24, 0xCF	; 207
    1f1c:	9e e0       	ldi	r25, 0x0E	; 14
	}
}
    1f1e:	df 91       	pop	r29
    1f20:	cf 91       	pop	r28
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    1f22:	0c 94 4b 0b 	jmp	0x1696	; 0x1696 <xCoRoutineCreate>
	}
}
    1f26:	df 91       	pop	r29
    1f28:	cf 91       	pop	r28
    1f2a:	08 95       	ret

00001f2c <xAreFlashCoRoutinesStillRunning>:
portBASE_TYPE xAreFlashCoRoutinesStillRunning( void )
{
	/* Return pdPASS or pdFAIL depending on whether an error has been detected
	or not. */
	return xCoRoutineFlashStatus;
}
    1f2c:	80 91 03 01 	lds	r24, 0x0103
    1f30:	08 95       	ret

00001f32 <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    1f32:	cf 93       	push	r28
    1f34:	df 93       	push	r29
    1f36:	00 d0       	rcall	.+0      	; 0x1f38 <vCompeteingIntMathTask+0x6>
    1f38:	00 d0       	rcall	.+0      	; 0x1f3a <vCompeteingIntMathTask+0x8>
    1f3a:	cd b7       	in	r28, 0x3d	; 61
    1f3c:	de b7       	in	r29, 0x3e	; 62
    1f3e:	5c 01       	movw	r10, r24
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    1f40:	00 e0       	ldi	r16, 0x00	; 0
    1f42:	10 e0       	ldi	r17, 0x00	; 0
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    1f44:	8b e7       	ldi	r24, 0x7B	; 123
    1f46:	c8 2e       	mov	r12, r24
    1f48:	d1 2c       	mov	r13, r1
    1f4a:	e1 2c       	mov	r14, r1
    1f4c:	f1 2c       	mov	r15, r1
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
		lValue /= intgCONST4;
    1f4e:	97 e0       	ldi	r25, 0x07	; 7
    1f50:	49 2e       	mov	r4, r25
    1f52:	51 2c       	mov	r5, r1
    1f54:	61 2c       	mov	r6, r1
    1f56:	71 2c       	mov	r7, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    1f58:	99 24       	eor	r9, r9
    1f5a:	93 94       	inc	r9
    1f5c:	02 c0       	rjmp	.+4      	; 0x1f62 <vCompeteingIntMathTask+0x30>
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    1f5e:	01 e0       	ldi	r16, 0x01	; 1
    1f60:	10 e0       	ldi	r17, 0x00	; 0
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    1f62:	c9 82       	std	Y+1, r12	; 0x01
    1f64:	da 82       	std	Y+2, r13	; 0x02
    1f66:	eb 82       	std	Y+3, r14	; 0x03
    1f68:	fc 82       	std	Y+4, r15	; 0x04
		lValue += intgCONST2;
    1f6a:	89 81       	ldd	r24, Y+1	; 0x01
    1f6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f6e:	ab 81       	ldd	r26, Y+3	; 0x03
    1f70:	bc 81       	ldd	r27, Y+4	; 0x04
    1f72:	89 5b       	subi	r24, 0xB9	; 185
    1f74:	9b 46       	sbci	r25, 0x6B	; 107
    1f76:	ac 4f       	sbci	r26, 0xFC	; 252
    1f78:	bf 4f       	sbci	r27, 0xFF	; 255
    1f7a:	89 83       	std	Y+1, r24	; 0x01
    1f7c:	9a 83       	std	Y+2, r25	; 0x02
    1f7e:	ab 83       	std	Y+3, r26	; 0x03
    1f80:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    1f82:	29 81       	ldd	r18, Y+1	; 0x01
    1f84:	3a 81       	ldd	r19, Y+2	; 0x02
    1f86:	4b 81       	ldd	r20, Y+3	; 0x03
    1f88:	5c 81       	ldd	r21, Y+4	; 0x04
    1f8a:	ad ef       	ldi	r26, 0xFD	; 253
    1f8c:	bf ef       	ldi	r27, 0xFF	; 255
    1f8e:	0e 94 fd 10 	call	0x21fa	; 0x21fa <__mulohisi3>
    1f92:	69 83       	std	Y+1, r22	; 0x01
    1f94:	7a 83       	std	Y+2, r23	; 0x02
    1f96:	8b 83       	std	Y+3, r24	; 0x03
    1f98:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
    1f9a:	69 81       	ldd	r22, Y+1	; 0x01
    1f9c:	7a 81       	ldd	r23, Y+2	; 0x02
    1f9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fa2:	a3 01       	movw	r20, r6
    1fa4:	92 01       	movw	r18, r4
    1fa6:	0e 94 02 11 	call	0x2204	; 0x2204 <__divmodsi4>
    1faa:	29 83       	std	Y+1, r18	; 0x01
    1fac:	3a 83       	std	Y+2, r19	; 0x02
    1fae:	4b 83       	std	Y+3, r20	; 0x03
    1fb0:	5c 83       	std	Y+4, r21	; 0x04

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    1fb2:	89 81       	ldd	r24, Y+1	; 0x01
    1fb4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fb6:	ab 81       	ldd	r26, Y+3	; 0x03
    1fb8:	bc 81       	ldd	r27, Y+4	; 0x04
    1fba:	8b 31       	cpi	r24, 0x1B	; 27
    1fbc:	97 47       	sbci	r25, 0x77	; 119
    1fbe:	ae 4f       	sbci	r26, 0xFE	; 254
    1fc0:	bf 4f       	sbci	r27, 0xFF	; 255
    1fc2:	69 f6       	brne	.-102    	; 0x1f5e <vCompeteingIntMathTask+0x2c>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    1fc4:	01 15       	cp	r16, r1
    1fc6:	11 05       	cpc	r17, r1
    1fc8:	51 f6       	brne	.-108    	; 0x1f5e <vCompeteingIntMathTask+0x2c>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    1fca:	0f b6       	in	r0, 0x3f	; 63
    1fcc:	f8 94       	cli
    1fce:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    1fd0:	f5 01       	movw	r30, r10
    1fd2:	90 82       	st	Z, r9
			portEXIT_CRITICAL();
    1fd4:	0f 90       	pop	r0
    1fd6:	0f be       	out	0x3f, r0	; 63
    1fd8:	c4 cf       	rjmp	.-120    	; 0x1f62 <vCompeteingIntMathTask+0x30>

00001fda <vStartIntegerMathTasks>:
static volatile signed portBASE_TYPE xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( signed portBASE_TYPE ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
{
    1fda:	af 92       	push	r10
    1fdc:	bf 92       	push	r11
    1fde:	cf 92       	push	r12
    1fe0:	df 92       	push	r13
    1fe2:	ef 92       	push	r14
    1fe4:	ff 92       	push	r15
    1fe6:	0f 93       	push	r16
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( xTaskHandle * ) NULL );
    1fe8:	a1 2c       	mov	r10, r1
    1fea:	b1 2c       	mov	r11, r1
    1fec:	c1 2c       	mov	r12, r1
    1fee:	d1 2c       	mov	r13, r1
    1ff0:	e1 2c       	mov	r14, r1
    1ff2:	f1 2c       	mov	r15, r1
    1ff4:	08 2f       	mov	r16, r24
    1ff6:	20 ec       	ldi	r18, 0xC0	; 192
    1ff8:	37 e0       	ldi	r19, 0x07	; 7
    1ffa:	45 e5       	ldi	r20, 0x55	; 85
    1ffc:	50 e0       	ldi	r21, 0x00	; 0
    1ffe:	61 e3       	ldi	r22, 0x31	; 49
    2000:	71 e0       	ldi	r23, 0x01	; 1
    2002:	89 e9       	ldi	r24, 0x99	; 153
    2004:	9f e0       	ldi	r25, 0x0F	; 15
    2006:	0e 94 b4 02 	call	0x568	; 0x568 <xTaskGenericCreate>
	}
}
    200a:	0f 91       	pop	r16
    200c:	ff 90       	pop	r15
    200e:	ef 90       	pop	r14
    2010:	df 90       	pop	r13
    2012:	cf 90       	pop	r12
    2014:	bf 90       	pop	r11
    2016:	af 90       	pop	r10
    2018:	08 95       	ret

0000201a <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    201a:	90 91 c0 07 	lds	r25, 0x07C0
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    201e:	10 92 c0 07 	sts	0x07C0, r1

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    2022:	81 e0       	ldi	r24, 0x01	; 1
    2024:	91 11       	cpse	r25, r1
    2026:	01 c0       	rjmp	.+2      	; 0x202a <xAreIntegerMathsTaskStillRunning+0x10>
    2028:	80 e0       	ldi	r24, 0x00	; 0
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
}
    202a:	08 95       	ret

0000202c <vPolledQueueProducer>:
	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    202c:	cf 93       	push	r28
    202e:	df 93       	push	r29
    2030:	00 d0       	rcall	.+0      	; 0x2032 <vPolledQueueProducer+0x6>
    2032:	cd b7       	in	r28, 0x3d	; 61
    2034:	de b7       	in	r29, 0x3e	; 62
    2036:	8c 01       	movw	r16, r24
unsigned short usValue = ( unsigned short ) 0;
    2038:	1a 82       	std	Y+2, r1	; 0x02
    203a:	19 82       	std	Y+1, r1	; 0x01
signed portBASE_TYPE xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    203c:	f1 2c       	mov	r15, r1
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
unsigned short usValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE, xLoop;
    203e:	e1 2c       	mov	r14, r1
    2040:	23 c0       	rjmp	.+70     	; 0x2088 <vPolledQueueProducer+0x5c>
	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    2042:	20 e0       	ldi	r18, 0x00	; 0
    2044:	40 e0       	ldi	r20, 0x00	; 0
    2046:	50 e0       	ldi	r21, 0x00	; 0
    2048:	be 01       	movw	r22, r28
    204a:	6f 5f       	subi	r22, 0xFF	; 255
    204c:	7f 4f       	sbci	r23, 0xFF	; 255
    204e:	f8 01       	movw	r30, r16
    2050:	80 81       	ld	r24, Z
    2052:	91 81       	ldd	r25, Z+1	; 0x01
    2054:	0e 94 07 08 	call	0x100e	; 0x100e <xQueueGenericSend>
    2058:	81 30       	cpi	r24, 0x01	; 1
    205a:	99 f4       	brne	.+38     	; 0x2082 <vPolledQueueProducer+0x56>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
    205c:	e1 10       	cpse	r14, r1
    205e:	0a c0       	rjmp	.+20     	; 0x2074 <vPolledQueueProducer+0x48>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    2060:	0f b6       	in	r0, 0x3f	; 63
    2062:	f8 94       	cli
    2064:	0f 92       	push	r0
						xPollingProducerCount++;
    2066:	80 91 c1 07 	lds	r24, 0x07C1
    206a:	8f 5f       	subi	r24, 0xFF	; 255
    206c:	80 93 c1 07 	sts	0x07C1, r24
					portEXIT_CRITICAL();
    2070:	0f 90       	pop	r0
    2072:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    2074:	29 81       	ldd	r18, Y+1	; 0x01
    2076:	3a 81       	ldd	r19, Y+2	; 0x02
    2078:	2f 5f       	subi	r18, 0xFF	; 255
    207a:	3f 4f       	sbci	r19, 0xFF	; 255
    207c:	3a 83       	std	Y+2, r19	; 0x02
    207e:	29 83       	std	Y+1, r18	; 0x01
    2080:	02 c0       	rjmp	.+4      	; 0x2086 <vPolledQueueProducer+0x5a>
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    2082:	ee 24       	eor	r14, r14
    2084:	e3 94       	inc	r14
unsigned short usValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    2086:	f3 94       	inc	r15
    2088:	f2 e0       	ldi	r31, 0x02	; 2
    208a:	ff 15       	cp	r31, r15
    208c:	d4 f6       	brge	.-76     	; 0x2042 <vPolledQueueProducer+0x16>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    208e:	88 ec       	ldi	r24, 0xC8	; 200
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	0e 94 bd 05 	call	0xb7a	; 0xb7a <vTaskDelay>
unsigned short usValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    2096:	f1 2c       	mov	r15, r1
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
	}
    2098:	d4 cf       	rjmp	.-88     	; 0x2042 <vPolledQueueProducer+0x16>

0000209a <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    209a:	cf 93       	push	r28
    209c:	df 93       	push	r29
    209e:	00 d0       	rcall	.+0      	; 0x20a0 <vPolledQueueConsumer+0x6>
    20a0:	cd b7       	in	r28, 0x3d	; 61
    20a2:	de b7       	in	r29, 0x3e	; 62
    20a4:	7c 01       	movw	r14, r24
unsigned short usData, usExpectedValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE;
    20a6:	d1 2c       	mov	r13, r1
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
unsigned short usData, usExpectedValue = ( unsigned short ) 0;
    20a8:	00 e0       	ldi	r16, 0x00	; 0
    20aa:	10 e0       	ldi	r17, 0x00	; 0
    20ac:	24 c0       	rjmp	.+72     	; 0x20f6 <vPolledQueueConsumer+0x5c>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    20ae:	20 e0       	ldi	r18, 0x00	; 0
    20b0:	40 e0       	ldi	r20, 0x00	; 0
    20b2:	50 e0       	ldi	r21, 0x00	; 0
    20b4:	be 01       	movw	r22, r28
    20b6:	6f 5f       	subi	r22, 0xFF	; 255
    20b8:	7f 4f       	sbci	r23, 0xFF	; 255
    20ba:	f7 01       	movw	r30, r14
    20bc:	80 81       	ld	r24, Z
    20be:	91 81       	ldd	r25, Z+1	; 0x01
    20c0:	0e 94 ce 08 	call	0x119c	; 0x119c <xQueueGenericReceive>
    20c4:	81 30       	cpi	r24, 0x01	; 1
    20c6:	b9 f4       	brne	.+46     	; 0x20f6 <vPolledQueueConsumer+0x5c>
			{
				if( usData != usExpectedValue )
    20c8:	89 81       	ldd	r24, Y+1	; 0x01
    20ca:	9a 81       	ldd	r25, Y+2	; 0x02
    20cc:	80 17       	cp	r24, r16
    20ce:	91 07       	cpc	r25, r17
    20d0:	69 f4       	brne	.+26     	; 0x20ec <vPolledQueueConsumer+0x52>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
    20d2:	d1 10       	cpse	r13, r1
    20d4:	0d c0       	rjmp	.+26     	; 0x20f0 <vPolledQueueConsumer+0x56>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    20d6:	0f b6       	in	r0, 0x3f	; 63
    20d8:	f8 94       	cli
    20da:	0f 92       	push	r0
							xPollingConsumerCount++;
    20dc:	20 91 c2 07 	lds	r18, 0x07C2
    20e0:	2f 5f       	subi	r18, 0xFF	; 255
    20e2:	20 93 c2 07 	sts	0x07C2, r18
						portEXIT_CRITICAL();
    20e6:	0f 90       	pop	r0
    20e8:	0f be       	out	0x3f, r0	; 63
    20ea:	02 c0       	rjmp	.+4      	; 0x20f0 <vPolledQueueConsumer+0x56>
			{
				if( usData != usExpectedValue )
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    20ec:	dd 24       	eor	r13, r13
    20ee:	d3 94       	inc	r13
						portEXIT_CRITICAL();
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    20f0:	8c 01       	movw	r16, r24
    20f2:	0f 5f       	subi	r16, 0xFF	; 255
    20f4:	1f 4f       	sbci	r17, 0xFF	; 255
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
    20f6:	f7 01       	movw	r30, r14
    20f8:	80 81       	ld	r24, Z
    20fa:	91 81       	ldd	r25, Z+1	; 0x01
    20fc:	0e 94 b7 09 	call	0x136e	; 0x136e <uxQueueMessagesWaiting>
    2100:	81 11       	cpse	r24, r1
    2102:	d5 cf       	rjmp	.-86     	; 0x20ae <vPolledQueueConsumer+0x14>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    2104:	84 eb       	ldi	r24, 0xB4	; 180
    2106:	90 e0       	ldi	r25, 0x00	; 0
    2108:	0e 94 bd 05 	call	0xb7a	; 0xb7a <vTaskDelay>
	}
    210c:	f4 cf       	rjmp	.-24     	; 0x20f6 <vPolledQueueConsumer+0x5c>

0000210e <vStartPolledQueueTasks>:
static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
{
    210e:	af 92       	push	r10
    2110:	bf 92       	push	r11
    2112:	cf 92       	push	r12
    2114:	df 92       	push	r13
    2116:	ef 92       	push	r14
    2118:	ff 92       	push	r15
    211a:	0f 93       	push	r16
    211c:	cf 93       	push	r28
    211e:	c8 2f       	mov	r28, r24
static xQueueHandle xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
    2120:	40 e0       	ldi	r20, 0x00	; 0
    2122:	62 e0       	ldi	r22, 0x02	; 2
    2124:	8a e0       	ldi	r24, 0x0A	; 10
    2126:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xQueueGenericCreate>
    212a:	90 93 c4 07 	sts	0x07C4, r25
    212e:	80 93 c3 07 	sts	0x07C3, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
    2132:	a1 2c       	mov	r10, r1
    2134:	b1 2c       	mov	r11, r1
    2136:	c1 2c       	mov	r12, r1
    2138:	d1 2c       	mov	r13, r1
    213a:	e1 2c       	mov	r14, r1
    213c:	f1 2c       	mov	r15, r1
    213e:	0c 2f       	mov	r16, r28
    2140:	23 ec       	ldi	r18, 0xC3	; 195
    2142:	37 e0       	ldi	r19, 0x07	; 7
    2144:	45 e5       	ldi	r20, 0x55	; 85
    2146:	50 e0       	ldi	r21, 0x00	; 0
    2148:	69 e3       	ldi	r22, 0x39	; 57
    214a:	71 e0       	ldi	r23, 0x01	; 1
    214c:	8d e4       	ldi	r24, 0x4D	; 77
    214e:	90 e1       	ldi	r25, 0x10	; 16
    2150:	0e 94 b4 02 	call	0x568	; 0x568 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
    2154:	23 ec       	ldi	r18, 0xC3	; 195
    2156:	37 e0       	ldi	r19, 0x07	; 7
    2158:	45 e5       	ldi	r20, 0x55	; 85
    215a:	50 e0       	ldi	r21, 0x00	; 0
    215c:	61 e4       	ldi	r22, 0x41	; 65
    215e:	71 e0       	ldi	r23, 0x01	; 1
    2160:	86 e1       	ldi	r24, 0x16	; 22
    2162:	90 e1       	ldi	r25, 0x10	; 16
    2164:	0e 94 b4 02 	call	0x568	; 0x568 <xTaskGenericCreate>
}
    2168:	cf 91       	pop	r28
    216a:	0f 91       	pop	r16
    216c:	ff 90       	pop	r15
    216e:	ef 90       	pop	r14
    2170:	df 90       	pop	r13
    2172:	cf 90       	pop	r12
    2174:	bf 90       	pop	r11
    2176:	af 90       	pop	r10
    2178:	08 95       	ret

0000217a <xArePollingQueuesStillRunning>:
    217a:	80 91 c2 07 	lds	r24, 0x07C2
    217e:	88 23       	and	r24, r24
    2180:	29 f0       	breq	.+10     	; 0x218c <xArePollingQueuesStillRunning+0x12>
    2182:	90 91 c1 07 	lds	r25, 0x07C1
    2186:	81 e0       	ldi	r24, 0x01	; 1
    2188:	91 11       	cpse	r25, r1
    218a:	01 c0       	rjmp	.+2      	; 0x218e <xArePollingQueuesStillRunning+0x14>
    218c:	80 e0       	ldi	r24, 0x00	; 0
    218e:	10 92 c2 07 	sts	0x07C2, r1
    2192:	10 92 c1 07 	sts	0x07C1, r1
    2196:	08 95       	ret

00002198 <main>:
    2198:	af 92       	push	r10
    219a:	bf 92       	push	r11
    219c:	cf 92       	push	r12
    219e:	df 92       	push	r13
    21a0:	ef 92       	push	r14
    21a2:	ff 92       	push	r15
    21a4:	0f 93       	push	r16
    21a6:	a1 2c       	mov	r10, r1
    21a8:	b1 2c       	mov	r11, r1
    21aa:	c1 2c       	mov	r12, r1
    21ac:	d1 2c       	mov	r13, r1
    21ae:	e1 2c       	mov	r14, r1
    21b0:	f1 2c       	mov	r15, r1
    21b2:	01 e0       	ldi	r16, 0x01	; 1
    21b4:	20 e0       	ldi	r18, 0x00	; 0
    21b6:	30 e0       	ldi	r19, 0x00	; 0
    21b8:	40 ef       	ldi	r20, 0xF0	; 240
    21ba:	50 e0       	ldi	r21, 0x00	; 0
    21bc:	64 e1       	ldi	r22, 0x14	; 20
    21be:	71 e0       	ldi	r23, 0x01	; 1
    21c0:	83 e5       	ldi	r24, 0x53	; 83
    21c2:	90 e0       	ldi	r25, 0x00	; 0
    21c4:	0e 94 b4 02 	call	0x568	; 0x568 <xTaskGenericCreate>
    21c8:	20 e0       	ldi	r18, 0x00	; 0
    21ca:	30 e0       	ldi	r19, 0x00	; 0
    21cc:	40 ef       	ldi	r20, 0xF0	; 240
    21ce:	50 e0       	ldi	r21, 0x00	; 0
    21d0:	6b e1       	ldi	r22, 0x1B	; 27
    21d2:	71 e0       	ldi	r23, 0x01	; 1
    21d4:	83 e7       	ldi	r24, 0x73	; 115
    21d6:	90 e0       	ldi	r25, 0x00	; 0
    21d8:	0e 94 b4 02 	call	0x568	; 0x568 <xTaskGenericCreate>
    21dc:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <vTaskStartScheduler>
    21e0:	80 e0       	ldi	r24, 0x00	; 0
    21e2:	90 e0       	ldi	r25, 0x00	; 0
    21e4:	0f 91       	pop	r16
    21e6:	ff 90       	pop	r15
    21e8:	ef 90       	pop	r14
    21ea:	df 90       	pop	r13
    21ec:	cf 90       	pop	r12
    21ee:	bf 90       	pop	r11
    21f0:	af 90       	pop	r10
    21f2:	08 95       	ret

000021f4 <__mulshisi3>:
    21f4:	b7 ff       	sbrs	r27, 7
    21f6:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__muluhisi3>

000021fa <__mulohisi3>:
    21fa:	0e 94 1e 11 	call	0x223c	; 0x223c <__muluhisi3>
    21fe:	82 1b       	sub	r24, r18
    2200:	93 0b       	sbc	r25, r19
    2202:	08 95       	ret

00002204 <__divmodsi4>:
    2204:	05 2e       	mov	r0, r21
    2206:	97 fb       	bst	r25, 7
    2208:	16 f4       	brtc	.+4      	; 0x220e <__divmodsi4+0xa>
    220a:	00 94       	com	r0
    220c:	07 d0       	rcall	.+14     	; 0x221c <__divmodsi4_neg1>
    220e:	57 fd       	sbrc	r21, 7
    2210:	0d d0       	rcall	.+26     	; 0x222c <__divmodsi4_neg2>
    2212:	0e 94 29 11 	call	0x2252	; 0x2252 <__udivmodsi4>
    2216:	07 fc       	sbrc	r0, 7
    2218:	09 d0       	rcall	.+18     	; 0x222c <__divmodsi4_neg2>
    221a:	7e f4       	brtc	.+30     	; 0x223a <__divmodsi4_exit>

0000221c <__divmodsi4_neg1>:
    221c:	90 95       	com	r25
    221e:	80 95       	com	r24
    2220:	70 95       	com	r23
    2222:	61 95       	neg	r22
    2224:	7f 4f       	sbci	r23, 0xFF	; 255
    2226:	8f 4f       	sbci	r24, 0xFF	; 255
    2228:	9f 4f       	sbci	r25, 0xFF	; 255
    222a:	08 95       	ret

0000222c <__divmodsi4_neg2>:
    222c:	50 95       	com	r21
    222e:	40 95       	com	r20
    2230:	30 95       	com	r19
    2232:	21 95       	neg	r18
    2234:	3f 4f       	sbci	r19, 0xFF	; 255
    2236:	4f 4f       	sbci	r20, 0xFF	; 255
    2238:	5f 4f       	sbci	r21, 0xFF	; 255

0000223a <__divmodsi4_exit>:
    223a:	08 95       	ret

0000223c <__muluhisi3>:
    223c:	0e 94 4b 11 	call	0x2296	; 0x2296 <__umulhisi3>
    2240:	a5 9f       	mul	r26, r21
    2242:	90 0d       	add	r25, r0
    2244:	b4 9f       	mul	r27, r20
    2246:	90 0d       	add	r25, r0
    2248:	a4 9f       	mul	r26, r20
    224a:	80 0d       	add	r24, r0
    224c:	91 1d       	adc	r25, r1
    224e:	11 24       	eor	r1, r1
    2250:	08 95       	ret

00002252 <__udivmodsi4>:
    2252:	a1 e2       	ldi	r26, 0x21	; 33
    2254:	1a 2e       	mov	r1, r26
    2256:	aa 1b       	sub	r26, r26
    2258:	bb 1b       	sub	r27, r27
    225a:	fd 01       	movw	r30, r26
    225c:	0d c0       	rjmp	.+26     	; 0x2278 <__udivmodsi4_ep>

0000225e <__udivmodsi4_loop>:
    225e:	aa 1f       	adc	r26, r26
    2260:	bb 1f       	adc	r27, r27
    2262:	ee 1f       	adc	r30, r30
    2264:	ff 1f       	adc	r31, r31
    2266:	a2 17       	cp	r26, r18
    2268:	b3 07       	cpc	r27, r19
    226a:	e4 07       	cpc	r30, r20
    226c:	f5 07       	cpc	r31, r21
    226e:	20 f0       	brcs	.+8      	; 0x2278 <__udivmodsi4_ep>
    2270:	a2 1b       	sub	r26, r18
    2272:	b3 0b       	sbc	r27, r19
    2274:	e4 0b       	sbc	r30, r20
    2276:	f5 0b       	sbc	r31, r21

00002278 <__udivmodsi4_ep>:
    2278:	66 1f       	adc	r22, r22
    227a:	77 1f       	adc	r23, r23
    227c:	88 1f       	adc	r24, r24
    227e:	99 1f       	adc	r25, r25
    2280:	1a 94       	dec	r1
    2282:	69 f7       	brne	.-38     	; 0x225e <__udivmodsi4_loop>
    2284:	60 95       	com	r22
    2286:	70 95       	com	r23
    2288:	80 95       	com	r24
    228a:	90 95       	com	r25
    228c:	9b 01       	movw	r18, r22
    228e:	ac 01       	movw	r20, r24
    2290:	bd 01       	movw	r22, r26
    2292:	cf 01       	movw	r24, r30
    2294:	08 95       	ret

00002296 <__umulhisi3>:
    2296:	a2 9f       	mul	r26, r18
    2298:	b0 01       	movw	r22, r0
    229a:	b3 9f       	mul	r27, r19
    229c:	c0 01       	movw	r24, r0
    229e:	a3 9f       	mul	r26, r19
    22a0:	01 d0       	rcall	.+2      	; 0x22a4 <__umulhisi3+0xe>
    22a2:	b2 9f       	mul	r27, r18
    22a4:	70 0d       	add	r23, r0
    22a6:	81 1d       	adc	r24, r1
    22a8:	11 24       	eor	r1, r1
    22aa:	91 1d       	adc	r25, r1
    22ac:	08 95       	ret

000022ae <memcpy>:
    22ae:	fb 01       	movw	r30, r22
    22b0:	dc 01       	movw	r26, r24
    22b2:	02 c0       	rjmp	.+4      	; 0x22b8 <memcpy+0xa>
    22b4:	01 90       	ld	r0, Z+
    22b6:	0d 92       	st	X+, r0
    22b8:	41 50       	subi	r20, 0x01	; 1
    22ba:	50 40       	sbci	r21, 0x00	; 0
    22bc:	d8 f7       	brcc	.-10     	; 0x22b4 <memcpy+0x6>
    22be:	08 95       	ret

000022c0 <memset>:
    22c0:	dc 01       	movw	r26, r24
    22c2:	01 c0       	rjmp	.+2      	; 0x22c6 <memset+0x6>
    22c4:	6d 93       	st	X+, r22
    22c6:	41 50       	subi	r20, 0x01	; 1
    22c8:	50 40       	sbci	r21, 0x00	; 0
    22ca:	e0 f7       	brcc	.-8      	; 0x22c4 <memset+0x4>
    22cc:	08 95       	ret

000022ce <_exit>:
    22ce:	f8 94       	cli

000022d0 <__stop_program>:
    22d0:	ff cf       	rjmp	.-2      	; 0x22d0 <__stop_program>
