   1               		.file	"PollQ.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 126               	vPolledQueueProducer:
 127               		.stabd	46,0,0
   1:../Common/Minimal/PollQ.c **** /*
   2:../Common/Minimal/PollQ.c ****     FreeRTOS V7.6.0 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:../Common/Minimal/PollQ.c ****     All rights reserved
   4:../Common/Minimal/PollQ.c **** 
   5:../Common/Minimal/PollQ.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../Common/Minimal/PollQ.c **** 
   7:../Common/Minimal/PollQ.c ****     ***************************************************************************
   8:../Common/Minimal/PollQ.c ****      *                                                                       *
   9:../Common/Minimal/PollQ.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:../Common/Minimal/PollQ.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:../Common/Minimal/PollQ.c ****      *    platform software that has become a de facto standard.             *
  12:../Common/Minimal/PollQ.c ****      *                                                                       *
  13:../Common/Minimal/PollQ.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:../Common/Minimal/PollQ.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:../Common/Minimal/PollQ.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:../Common/Minimal/PollQ.c ****      *                                                                       *
  17:../Common/Minimal/PollQ.c ****      *    Thank you!                                                         *
  18:../Common/Minimal/PollQ.c ****      *                                                                       *
  19:../Common/Minimal/PollQ.c ****     ***************************************************************************
  20:../Common/Minimal/PollQ.c **** 
  21:../Common/Minimal/PollQ.c ****     This file is part of the FreeRTOS distribution.
  22:../Common/Minimal/PollQ.c **** 
  23:../Common/Minimal/PollQ.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:../Common/Minimal/PollQ.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:../Common/Minimal/PollQ.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:../Common/Minimal/PollQ.c **** 
  27:../Common/Minimal/PollQ.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:../Common/Minimal/PollQ.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:../Common/Minimal/PollQ.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:../Common/Minimal/PollQ.c ****     >>! kernel.
  31:../Common/Minimal/PollQ.c **** 
  32:../Common/Minimal/PollQ.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:../Common/Minimal/PollQ.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:../Common/Minimal/PollQ.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:../Common/Minimal/PollQ.c ****     link: http://www.freertos.org/a00114.html
  36:../Common/Minimal/PollQ.c **** 
  37:../Common/Minimal/PollQ.c ****     1 tab == 4 spaces!
  38:../Common/Minimal/PollQ.c **** 
  39:../Common/Minimal/PollQ.c ****     ***************************************************************************
  40:../Common/Minimal/PollQ.c ****      *                                                                       *
  41:../Common/Minimal/PollQ.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:../Common/Minimal/PollQ.c ****      *    not run, what could be wrong?"                                     *
  43:../Common/Minimal/PollQ.c ****      *                                                                       *
  44:../Common/Minimal/PollQ.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:../Common/Minimal/PollQ.c ****      *                                                                       *
  46:../Common/Minimal/PollQ.c ****     ***************************************************************************
  47:../Common/Minimal/PollQ.c **** 
  48:../Common/Minimal/PollQ.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:../Common/Minimal/PollQ.c ****     license and Real Time Engineers Ltd. contact details.
  50:../Common/Minimal/PollQ.c **** 
  51:../Common/Minimal/PollQ.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:../Common/Minimal/PollQ.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:../Common/Minimal/PollQ.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:../Common/Minimal/PollQ.c **** 
  55:../Common/Minimal/PollQ.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:../Common/Minimal/PollQ.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:../Common/Minimal/PollQ.c ****     licenses offer ticketed support, indemnification and middleware.
  58:../Common/Minimal/PollQ.c **** 
  59:../Common/Minimal/PollQ.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:../Common/Minimal/PollQ.c ****     engineered and independently SIL3 certified version for use in safety and
  61:../Common/Minimal/PollQ.c ****     mission critical applications that require provable dependability.
  62:../Common/Minimal/PollQ.c **** 
  63:../Common/Minimal/PollQ.c ****     1 tab == 4 spaces!
  64:../Common/Minimal/PollQ.c **** */
  65:../Common/Minimal/PollQ.c **** 
  66:../Common/Minimal/PollQ.c **** /*
  67:../Common/Minimal/PollQ.c ****  * This version of PollQ. c is for use on systems that have limited stack
  68:../Common/Minimal/PollQ.c ****  * space and no display facilities.  The complete version can be found in
  69:../Common/Minimal/PollQ.c ****  * the Demo/Common/Full directory.
  70:../Common/Minimal/PollQ.c ****  *
  71:../Common/Minimal/PollQ.c ****  * Creates two tasks that communicate over a single queue.  One task acts as a
  72:../Common/Minimal/PollQ.c ****  * producer, the other a consumer.
  73:../Common/Minimal/PollQ.c ****  *
  74:../Common/Minimal/PollQ.c ****  * The producer loops for three iteration, posting an incrementing number onto the
  75:../Common/Minimal/PollQ.c ****  * queue each cycle.  It then delays for a fixed period before doing exactly the
  76:../Common/Minimal/PollQ.c ****  * same again.
  77:../Common/Minimal/PollQ.c ****  *
  78:../Common/Minimal/PollQ.c ****  * The consumer loops emptying the queue.  Each item removed from the queue is
  79:../Common/Minimal/PollQ.c ****  * checked to ensure it contains the expected value.  When the queue is empty it
  80:../Common/Minimal/PollQ.c ****  * blocks for a fixed period, then does the same again.
  81:../Common/Minimal/PollQ.c ****  *
  82:../Common/Minimal/PollQ.c ****  * All queue access is performed without blocking.  The consumer completely empties
  83:../Common/Minimal/PollQ.c ****  * the queue each time it runs so the producer should never find the queue full.
  84:../Common/Minimal/PollQ.c ****  *
  85:../Common/Minimal/PollQ.c ****  * An error is flagged if the consumer obtains an unexpected value or the producer
  86:../Common/Minimal/PollQ.c ****  * find the queue is full.
  87:../Common/Minimal/PollQ.c ****  */
  88:../Common/Minimal/PollQ.c **** 
  89:../Common/Minimal/PollQ.c **** /*
  90:../Common/Minimal/PollQ.c **** Changes from V2.0.0
  91:../Common/Minimal/PollQ.c **** 
  92:../Common/Minimal/PollQ.c **** 	+ Delay periods are now specified using variables and constants of
  93:../Common/Minimal/PollQ.c **** 	  portTickType rather than unsigned long.
  94:../Common/Minimal/PollQ.c **** */
  95:../Common/Minimal/PollQ.c **** 
  96:../Common/Minimal/PollQ.c **** #include <stdlib.h>
  97:../Common/Minimal/PollQ.c **** 
  98:../Common/Minimal/PollQ.c **** /* Scheduler include files. */
  99:../Common/Minimal/PollQ.c **** #include "FreeRTOS.h"
 100:../Common/Minimal/PollQ.c **** #include "task.h"
 101:../Common/Minimal/PollQ.c **** #include "queue.h"
 102:../Common/Minimal/PollQ.c **** 
 103:../Common/Minimal/PollQ.c **** /* Demo program include files. */
 104:../Common/Minimal/PollQ.c **** #include "PollQ.h"
 105:../Common/Minimal/PollQ.c **** 
 106:../Common/Minimal/PollQ.c **** #define pollqSTACK_SIZE			configMINIMAL_STACK_SIZE
 107:../Common/Minimal/PollQ.c **** #define pollqQUEUE_SIZE			( 10 )
 108:../Common/Minimal/PollQ.c **** #define pollqPRODUCER_DELAY		( ( portTickType ) 200 / portTICK_RATE_MS )
 109:../Common/Minimal/PollQ.c **** #define pollqCONSUMER_DELAY		( pollqPRODUCER_DELAY - ( portTickType ) ( 20 / portTICK_RATE_MS ) )
 110:../Common/Minimal/PollQ.c **** #define pollqNO_DELAY			( ( portTickType ) 0 )
 111:../Common/Minimal/PollQ.c **** #define pollqVALUES_TO_PRODUCE	( ( signed portBASE_TYPE ) 3 )
 112:../Common/Minimal/PollQ.c **** #define pollqINITIAL_VALUE		( ( signed portBASE_TYPE ) 0 )
 113:../Common/Minimal/PollQ.c **** 
 114:../Common/Minimal/PollQ.c **** /* The task that posts the incrementing number onto the queue. */
 115:../Common/Minimal/PollQ.c **** static portTASK_FUNCTION_PROTO( vPolledQueueProducer, pvParameters );
 116:../Common/Minimal/PollQ.c **** 
 117:../Common/Minimal/PollQ.c **** /* The task that empties the queue. */
 118:../Common/Minimal/PollQ.c **** static portTASK_FUNCTION_PROTO( vPolledQueueConsumer, pvParameters );
 119:../Common/Minimal/PollQ.c **** 
 120:../Common/Minimal/PollQ.c **** /* Variables that are used to check that the tasks are still running with no
 121:../Common/Minimal/PollQ.c **** errors. */
 122:../Common/Minimal/PollQ.c **** static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCo
 123:../Common/Minimal/PollQ.c **** 
 124:../Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 125:../Common/Minimal/PollQ.c **** 
 126:../Common/Minimal/PollQ.c **** void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
 127:../Common/Minimal/PollQ.c **** {
 128:../Common/Minimal/PollQ.c **** static xQueueHandle xPolledQueue;
 129:../Common/Minimal/PollQ.c **** 
 130:../Common/Minimal/PollQ.c **** 	/* Create the queue used by the producer and consumer. */
 131:../Common/Minimal/PollQ.c **** 	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) 
 132:../Common/Minimal/PollQ.c **** 
 133:../Common/Minimal/PollQ.c **** 	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
 134:../Common/Minimal/PollQ.c **** 	in use.  The queue registry is provided as a means for kernel aware 
 135:../Common/Minimal/PollQ.c **** 	debuggers to locate queues and has no purpose if a kernel aware debugger
 136:../Common/Minimal/PollQ.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 137:../Common/Minimal/PollQ.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
 138:../Common/Minimal/PollQ.c **** 	defined to be less than 1. */
 139:../Common/Minimal/PollQ.c **** 	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );
 140:../Common/Minimal/PollQ.c **** 
 141:../Common/Minimal/PollQ.c **** 	/* Spawn the producer and consumer. */
 142:../Common/Minimal/PollQ.c **** 	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPoll
 143:../Common/Minimal/PollQ.c **** 	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPoll
 144:../Common/Minimal/PollQ.c **** }
 145:../Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 146:../Common/Minimal/PollQ.c **** 
 147:../Common/Minimal/PollQ.c **** static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
 148:../Common/Minimal/PollQ.c **** {
 129               	.LM0:
 130               	.LFBB1:
 131 0000 CF93      		push r28
 132 0002 DF93      		push r29
 133 0004 00D0      		rcall .
 134 0006 CDB7      		in r28,__SP_L__
 135 0008 DEB7      		in r29,__SP_H__
 136               	/* prologue: function */
 137               	/* frame size = 2 */
 138               	/* stack size = 4 */
 139               	.L__stack_usage = 4
 140 000a 8C01      		movw r16,r24
 149:../Common/Minimal/PollQ.c **** unsigned short usValue = ( unsigned short ) 0;
 142               	.LM1:
 143 000c 1A82      		std Y+2,__zero_reg__
 144 000e 1982      		std Y+1,__zero_reg__
 150:../Common/Minimal/PollQ.c **** signed portBASE_TYPE xError = pdFALSE, xLoop;
 151:../Common/Minimal/PollQ.c **** 
 152:../Common/Minimal/PollQ.c **** 	for( ;; )
 153:../Common/Minimal/PollQ.c **** 	{		
 154:../Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 146               	.LM2:
 147 0010 F12C      		mov r15,__zero_reg__
 150:../Common/Minimal/PollQ.c **** signed portBASE_TYPE xError = pdFALSE, xLoop;
 149               	.LM3:
 150 0012 E12C      		mov r14,__zero_reg__
 151 0014 00C0      		rjmp .L8
 152               	.L5:
 155:../Common/Minimal/PollQ.c **** 		{
 156:../Common/Minimal/PollQ.c **** 			/* Send an incrementing number on the queue without blocking. */
 157:../Common/Minimal/PollQ.c **** 			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pd
 154               	.LM4:
 155 0016 20E0      		ldi r18,0
 156 0018 40E0      		ldi r20,0
 157 001a 50E0      		ldi r21,0
 158 001c BE01      		movw r22,r28
 159 001e 6F5F      		subi r22,-1
 160 0020 7F4F      		sbci r23,-1
 161 0022 F801      		movw r30,r16
 162 0024 8081      		ld r24,Z
 163 0026 9181      		ldd r25,Z+1
 164 0028 0E94 0000 		call xQueueGenericSend
 165 002c 8130      		cpi r24,lo8(1)
 166 002e 01F4      		brne .L7
 158:../Common/Minimal/PollQ.c **** 			{
 159:../Common/Minimal/PollQ.c **** 				/* We should never find the queue full so if we get here there
 160:../Common/Minimal/PollQ.c **** 				has been an error. */
 161:../Common/Minimal/PollQ.c **** 				xError = pdTRUE;
 162:../Common/Minimal/PollQ.c **** 			}
 163:../Common/Minimal/PollQ.c **** 			else
 164:../Common/Minimal/PollQ.c **** 			{
 165:../Common/Minimal/PollQ.c **** 				if( xError == pdFALSE )
 168               	.LM5:
 169 0030 E110      		cpse r14,__zero_reg__
 170 0032 00C0      		rjmp .L4
 166:../Common/Minimal/PollQ.c **** 				{
 167:../Common/Minimal/PollQ.c **** 					/* If an error has ever been recorded we stop incrementing the
 168:../Common/Minimal/PollQ.c **** 					check variable. */
 169:../Common/Minimal/PollQ.c **** 					portENTER_CRITICAL();
 172               	.LM6:
 173               	/* #APP */
 174               	 ;  169 "../Common/Minimal/PollQ.c" 1
 175 0034 0FB6      		in		__tmp_reg__, __SREG__
 176               	 ;  0 "" 2
 177               	 ;  169 "../Common/Minimal/PollQ.c" 1
 178 0036 F894      		cli
 179               	 ;  0 "" 2
 180               	 ;  169 "../Common/Minimal/PollQ.c" 1
 181 0038 0F92      		push	__tmp_reg__
 182               	 ;  0 "" 2
 170:../Common/Minimal/PollQ.c **** 						xPollingProducerCount++;
 184               	.LM7:
 185               	/* #NOAPP */
 186 003a 8091 0000 		lds r24,xPollingProducerCount
 187 003e 8F5F      		subi r24,lo8(-(1))
 188 0040 8093 0000 		sts xPollingProducerCount,r24
 171:../Common/Minimal/PollQ.c **** 					portEXIT_CRITICAL();
 190               	.LM8:
 191               	/* #APP */
 192               	 ;  171 "../Common/Minimal/PollQ.c" 1
 193 0044 0F90      		pop		__tmp_reg__
 194               	 ;  0 "" 2
 195               	 ;  171 "../Common/Minimal/PollQ.c" 1
 196 0046 0FBE      		out		__SREG__, __tmp_reg__
 197               	 ;  0 "" 2
 198               	/* #NOAPP */
 199               	.L4:
 172:../Common/Minimal/PollQ.c **** 				}
 173:../Common/Minimal/PollQ.c **** 
 174:../Common/Minimal/PollQ.c **** 				/* Update the value we are going to post next time around. */
 175:../Common/Minimal/PollQ.c **** 				usValue++;
 201               	.LM9:
 202 0048 2981      		ldd r18,Y+1
 203 004a 3A81      		ldd r19,Y+2
 204 004c 2F5F      		subi r18,-1
 205 004e 3F4F      		sbci r19,-1
 206 0050 3A83      		std Y+2,r19
 207 0052 2983      		std Y+1,r18
 208 0054 00C0      		rjmp .L3
 209               	.L7:
 161:../Common/Minimal/PollQ.c **** 				xError = pdTRUE;
 211               	.LM10:
 212 0056 EE24      		clr r14
 213 0058 E394      		inc r14
 214               	.L3:
 154:../Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 216               	.LM11:
 217 005a F394      		inc r15
 218               	.L8:
 154:../Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 220               	.LM12:
 221 005c F2E0      		ldi r31,lo8(2)
 222 005e FF15      		cp r31,r15
 223 0060 04F4      		brge .L5
 176:../Common/Minimal/PollQ.c **** 			}
 177:../Common/Minimal/PollQ.c **** 		}
 178:../Common/Minimal/PollQ.c **** 
 179:../Common/Minimal/PollQ.c **** 		/* Wait before we start posting again to ensure the consumer runs and
 180:../Common/Minimal/PollQ.c **** 		empties the queue. */
 181:../Common/Minimal/PollQ.c **** 		vTaskDelay( pollqPRODUCER_DELAY );
 225               	.LM13:
 226 0062 88EC      		ldi r24,lo8(-56)
 227 0064 90E0      		ldi r25,0
 228 0066 0E94 0000 		call vTaskDelay
 154:../Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 230               	.LM14:
 231 006a F12C      		mov r15,__zero_reg__
 182:../Common/Minimal/PollQ.c **** 	}
 233               	.LM15:
 234 006c 00C0      		rjmp .L5
 241               	.Lscope1:
 243               		.stabd	78,0,0
 247               	vPolledQueueConsumer:
 248               		.stabd	46,0,0
 183:../Common/Minimal/PollQ.c **** }  /*lint !e818 Function prototype must conform to API. */
 184:../Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 185:../Common/Minimal/PollQ.c **** 
 186:../Common/Minimal/PollQ.c **** static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
 187:../Common/Minimal/PollQ.c **** {
 250               	.LM16:
 251               	.LFBB2:
 252 006e CF93      		push r28
 253 0070 DF93      		push r29
 254 0072 00D0      		rcall .
 255 0074 CDB7      		in r28,__SP_L__
 256 0076 DEB7      		in r29,__SP_H__
 257               	/* prologue: function */
 258               	/* frame size = 2 */
 259               	/* stack size = 4 */
 260               	.L__stack_usage = 4
 261 0078 7C01      		movw r14,r24
 188:../Common/Minimal/PollQ.c **** unsigned short usData, usExpectedValue = ( unsigned short ) 0;
 189:../Common/Minimal/PollQ.c **** signed portBASE_TYPE xError = pdFALSE;
 263               	.LM17:
 264 007a D12C      		mov r13,__zero_reg__
 188:../Common/Minimal/PollQ.c **** unsigned short usData, usExpectedValue = ( unsigned short ) 0;
 266               	.LM18:
 267 007c 00E0      		ldi r16,0
 268 007e 10E0      		ldi r17,0
 269 0080 00C0      		rjmp .L17
 270               	.L13:
 190:../Common/Minimal/PollQ.c **** 
 191:../Common/Minimal/PollQ.c **** 	for( ;; )
 192:../Common/Minimal/PollQ.c **** 	{		
 193:../Common/Minimal/PollQ.c **** 		/* Loop until the queue is empty. */
 194:../Common/Minimal/PollQ.c **** 		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
 195:../Common/Minimal/PollQ.c **** 		{
 196:../Common/Minimal/PollQ.c **** 			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
 272               	.LM19:
 273 0082 20E0      		ldi r18,0
 274 0084 40E0      		ldi r20,0
 275 0086 50E0      		ldi r21,0
 276 0088 BE01      		movw r22,r28
 277 008a 6F5F      		subi r22,-1
 278 008c 7F4F      		sbci r23,-1
 279 008e F701      		movw r30,r14
 280 0090 8081      		ld r24,Z
 281 0092 9181      		ldd r25,Z+1
 282 0094 0E94 0000 		call xQueueGenericReceive
 283 0098 8130      		cpi r24,lo8(1)
 284 009a 01F4      		brne .L17
 197:../Common/Minimal/PollQ.c **** 			{
 198:../Common/Minimal/PollQ.c **** 				if( usData != usExpectedValue )
 286               	.LM20:
 287 009c 8981      		ldd r24,Y+1
 288 009e 9A81      		ldd r25,Y+2
 289 00a0 8017      		cp r24,r16
 290 00a2 9107      		cpc r25,r17
 291 00a4 01F4      		brne .L14
 199:../Common/Minimal/PollQ.c **** 				{
 200:../Common/Minimal/PollQ.c **** 					/* This is not what we expected to receive so an error has
 201:../Common/Minimal/PollQ.c **** 					occurred. */
 202:../Common/Minimal/PollQ.c **** 					xError = pdTRUE;
 203:../Common/Minimal/PollQ.c **** 
 204:../Common/Minimal/PollQ.c **** 					/* Catch-up to the value we received so our next expected
 205:../Common/Minimal/PollQ.c **** 					value should again be correct. */
 206:../Common/Minimal/PollQ.c **** 					usExpectedValue = usData;
 207:../Common/Minimal/PollQ.c **** 				}
 208:../Common/Minimal/PollQ.c **** 				else
 209:../Common/Minimal/PollQ.c **** 				{
 210:../Common/Minimal/PollQ.c **** 					if( xError == pdFALSE )
 293               	.LM21:
 294 00a6 D110      		cpse r13,__zero_reg__
 295 00a8 00C0      		rjmp .L12
 211:../Common/Minimal/PollQ.c **** 					{
 212:../Common/Minimal/PollQ.c **** 						/* Only increment the check variable if no errors have
 213:../Common/Minimal/PollQ.c **** 						occurred. */
 214:../Common/Minimal/PollQ.c **** 						portENTER_CRITICAL();
 297               	.LM22:
 298               	/* #APP */
 299               	 ;  214 "../Common/Minimal/PollQ.c" 1
 300 00aa 0FB6      		in		__tmp_reg__, __SREG__
 301               	 ;  0 "" 2
 302               	 ;  214 "../Common/Minimal/PollQ.c" 1
 303 00ac F894      		cli
 304               	 ;  0 "" 2
 305               	 ;  214 "../Common/Minimal/PollQ.c" 1
 306 00ae 0F92      		push	__tmp_reg__
 307               	 ;  0 "" 2
 215:../Common/Minimal/PollQ.c **** 							xPollingConsumerCount++;
 309               	.LM23:
 310               	/* #NOAPP */
 311 00b0 2091 0000 		lds r18,xPollingConsumerCount
 312 00b4 2F5F      		subi r18,lo8(-(1))
 313 00b6 2093 0000 		sts xPollingConsumerCount,r18
 216:../Common/Minimal/PollQ.c **** 						portEXIT_CRITICAL();
 315               	.LM24:
 316               	/* #APP */
 317               	 ;  216 "../Common/Minimal/PollQ.c" 1
 318 00ba 0F90      		pop		__tmp_reg__
 319               	 ;  0 "" 2
 320               	 ;  216 "../Common/Minimal/PollQ.c" 1
 321 00bc 0FBE      		out		__SREG__, __tmp_reg__
 322               	 ;  0 "" 2
 323               	/* #NOAPP */
 324 00be 00C0      		rjmp .L12
 325               	.L14:
 202:../Common/Minimal/PollQ.c **** 					xError = pdTRUE;
 327               	.LM25:
 328 00c0 DD24      		clr r13
 329 00c2 D394      		inc r13
 330               	.L12:
 217:../Common/Minimal/PollQ.c **** 					}
 218:../Common/Minimal/PollQ.c **** 				}
 219:../Common/Minimal/PollQ.c **** 
 220:../Common/Minimal/PollQ.c **** 				/* Next time round we would expect the number to be one higher. */
 221:../Common/Minimal/PollQ.c **** 				usExpectedValue++;
 332               	.LM26:
 333 00c4 8C01      		movw r16,r24
 334 00c6 0F5F      		subi r16,-1
 335 00c8 1F4F      		sbci r17,-1
 336               	.L17:
 194:../Common/Minimal/PollQ.c **** 		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
 338               	.LM27:
 339 00ca F701      		movw r30,r14
 340 00cc 8081      		ld r24,Z
 341 00ce 9181      		ldd r25,Z+1
 342 00d0 0E94 0000 		call uxQueueMessagesWaiting
 343 00d4 8111      		cpse r24,__zero_reg__
 344 00d6 00C0      		rjmp .L13
 222:../Common/Minimal/PollQ.c **** 			}
 223:../Common/Minimal/PollQ.c **** 		}
 224:../Common/Minimal/PollQ.c **** 
 225:../Common/Minimal/PollQ.c **** 		/* Now the queue is empty we block, allowing the producer to place more
 226:../Common/Minimal/PollQ.c **** 		items in the queue. */
 227:../Common/Minimal/PollQ.c **** 		vTaskDelay( pollqCONSUMER_DELAY );
 346               	.LM28:
 347 00d8 84EB      		ldi r24,lo8(-76)
 348 00da 90E0      		ldi r25,0
 349 00dc 0E94 0000 		call vTaskDelay
 228:../Common/Minimal/PollQ.c **** 	}
 351               	.LM29:
 352 00e0 00C0      		rjmp .L17
 358               	.Lscope2:
 360               		.stabd	78,0,0
 361               		.section	.rodata.str1.1,"aMS",@progbits,1
 362               	.LC0:
 363 0000 5143 6F6E 		.string	"QConsNB"
 363      734E 4200 
 364               	.LC1:
 365 0008 5150 726F 		.string	"QProdNB"
 365      644E 4200 
 366               		.text
 369               	.global	vStartPolledQueueTasks
 371               	vStartPolledQueueTasks:
 372               		.stabd	46,0,0
 127:../Common/Minimal/PollQ.c **** {
 374               	.LM30:
 375               	.LFBB3:
 376 00e2 AF92      		push r10
 377 00e4 BF92      		push r11
 378 00e6 CF92      		push r12
 379 00e8 DF92      		push r13
 380 00ea EF92      		push r14
 381 00ec FF92      		push r15
 382 00ee 0F93      		push r16
 383 00f0 CF93      		push r28
 384               	/* prologue: function */
 385               	/* frame size = 0 */
 386               	/* stack size = 8 */
 387               	.L__stack_usage = 8
 388 00f2 C82F      		mov r28,r24
 131:../Common/Minimal/PollQ.c **** 	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) 
 390               	.LM31:
 391 00f4 40E0      		ldi r20,0
 392 00f6 62E0      		ldi r22,lo8(2)
 393 00f8 8AE0      		ldi r24,lo8(10)
 394 00fa 0E94 0000 		call xQueueGenericCreate
 395 00fe 9093 0000 		sts xPolledQueue.1774+1,r25
 396 0102 8093 0000 		sts xPolledQueue.1774,r24
 142:../Common/Minimal/PollQ.c **** 	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPoll
 398               	.LM32:
 399 0106 A12C      		mov r10,__zero_reg__
 400 0108 B12C      		mov r11,__zero_reg__
 401 010a C12C      		mov r12,__zero_reg__
 402 010c D12C      		mov r13,__zero_reg__
 403 010e E12C      		mov r14,__zero_reg__
 404 0110 F12C      		mov r15,__zero_reg__
 405 0112 0C2F      		mov r16,r28
 406 0114 20E0      		ldi r18,lo8(xPolledQueue.1774)
 407 0116 30E0      		ldi r19,hi8(xPolledQueue.1774)
 408 0118 45E5      		ldi r20,lo8(85)
 409 011a 50E0      		ldi r21,0
 410 011c 60E0      		ldi r22,lo8(.LC0)
 411 011e 70E0      		ldi r23,hi8(.LC0)
 412 0120 80E0      		ldi r24,lo8(gs(vPolledQueueConsumer))
 413 0122 90E0      		ldi r25,hi8(gs(vPolledQueueConsumer))
 414 0124 0E94 0000 		call xTaskGenericCreate
 143:../Common/Minimal/PollQ.c **** 	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPoll
 416               	.LM33:
 417 0128 20E0      		ldi r18,lo8(xPolledQueue.1774)
 418 012a 30E0      		ldi r19,hi8(xPolledQueue.1774)
 419 012c 45E5      		ldi r20,lo8(85)
 420 012e 50E0      		ldi r21,0
 421 0130 60E0      		ldi r22,lo8(.LC1)
 422 0132 70E0      		ldi r23,hi8(.LC1)
 423 0134 80E0      		ldi r24,lo8(gs(vPolledQueueProducer))
 424 0136 90E0      		ldi r25,hi8(gs(vPolledQueueProducer))
 425 0138 0E94 0000 		call xTaskGenericCreate
 426               	/* epilogue start */
 144:../Common/Minimal/PollQ.c **** }
 428               	.LM34:
 429 013c CF91      		pop r28
 430 013e 0F91      		pop r16
 431 0140 FF90      		pop r15
 432 0142 EF90      		pop r14
 433 0144 DF90      		pop r13
 434 0146 CF90      		pop r12
 435 0148 BF90      		pop r11
 436 014a AF90      		pop r10
 437 014c 0895      		ret
 442               	.Lscope3:
 444               		.stabd	78,0,0
 446               	.global	xArePollingQueuesStillRunning
 448               	xArePollingQueuesStillRunning:
 449               		.stabd	46,0,0
 229:../Common/Minimal/PollQ.c **** } /*lint !e818 Function prototype must conform to API. */
 230:../Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 231:../Common/Minimal/PollQ.c **** 
 232:../Common/Minimal/PollQ.c **** /* This is called to check that all the created tasks are still running with no errors. */
 233:../Common/Minimal/PollQ.c **** portBASE_TYPE xArePollingQueuesStillRunning( void )
 234:../Common/Minimal/PollQ.c **** {
 451               	.LM35:
 452               	.LFBB4:
 453               	/* prologue: function */
 454               	/* frame size = 0 */
 455               	/* stack size = 0 */
 456               	.L__stack_usage = 0
 235:../Common/Minimal/PollQ.c **** portBASE_TYPE xReturn;
 236:../Common/Minimal/PollQ.c **** 
 237:../Common/Minimal/PollQ.c **** 	/* Check both the consumer and producer poll count to check they have both
 238:../Common/Minimal/PollQ.c **** 	been changed since out last trip round.  We do not need a critical section
 239:../Common/Minimal/PollQ.c **** 	around the check variables as this is called from a higher priority than
 240:../Common/Minimal/PollQ.c **** 	the other tasks that access the same variables. */
 241:../Common/Minimal/PollQ.c **** 	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
 458               	.LM36:
 459 014e 8091 0000 		lds r24,xPollingConsumerCount
 460 0152 8823      		tst r24
 461 0154 01F0      		breq .L22
 242:../Common/Minimal/PollQ.c **** 		( xPollingProducerCount == pollqINITIAL_VALUE )
 463               	.LM37:
 464 0156 9091 0000 		lds r25,xPollingProducerCount
 241:../Common/Minimal/PollQ.c **** 	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
 466               	.LM38:
 467 015a 81E0      		ldi r24,lo8(1)
 468 015c 9111      		cpse r25,__zero_reg__
 469 015e 00C0      		rjmp .L20
 470               	.L22:
 243:../Common/Minimal/PollQ.c **** 	  )
 244:../Common/Minimal/PollQ.c **** 	{
 245:../Common/Minimal/PollQ.c **** 		xReturn = pdFALSE;
 472               	.LM39:
 473 0160 80E0      		ldi r24,0
 474               	.L20:
 246:../Common/Minimal/PollQ.c **** 	}
 247:../Common/Minimal/PollQ.c **** 	else
 248:../Common/Minimal/PollQ.c **** 	{
 249:../Common/Minimal/PollQ.c **** 		xReturn = pdTRUE;
 250:../Common/Minimal/PollQ.c **** 	}
 251:../Common/Minimal/PollQ.c **** 
 252:../Common/Minimal/PollQ.c **** 	/* Set the check variables back down so we know if they have been
 253:../Common/Minimal/PollQ.c **** 	incremented the next time around. */
 254:../Common/Minimal/PollQ.c **** 	xPollingConsumerCount = pollqINITIAL_VALUE;
 476               	.LM40:
 477 0162 1092 0000 		sts xPollingConsumerCount,__zero_reg__
 255:../Common/Minimal/PollQ.c **** 	xPollingProducerCount = pollqINITIAL_VALUE;
 479               	.LM41:
 480 0166 1092 0000 		sts xPollingProducerCount,__zero_reg__
 256:../Common/Minimal/PollQ.c **** 
 257:../Common/Minimal/PollQ.c **** 	return xReturn;
 258:../Common/Minimal/PollQ.c **** }
 482               	.LM42:
 483 016a 0895      		ret
 488               	.Lscope4:
 490               		.stabd	78,0,0
 491               		.local	xPollingProducerCount
 492               		.comm	xPollingProducerCount,1,1
 493               		.local	xPollingConsumerCount
 494               		.comm	xPollingConsumerCount,1,1
 495               		.local	xPolledQueue.1774
 496               		.comm	xPolledQueue.1774,2,1
 500               	.Letext0:
 501               		.ident	"GCC: (GNU) 4.7.2"
 502               	.global __do_copy_data
 503               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 PollQ.c
     /tmp/ccJPZByr.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccJPZByr.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccJPZByr.s:4      *ABS*:0000003f __SREG__
     /tmp/ccJPZByr.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccJPZByr.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccJPZByr.s:126    .text:00000000 vPolledQueueProducer
                             .bss:00000000 xPollingProducerCount
     /tmp/ccJPZByr.s:247    .text:0000006e vPolledQueueConsumer
     /tmp/ccJPZByr.s:492    .bss:00000001 xPollingConsumerCount
     /tmp/ccJPZByr.s:371    .text:000000e2 vStartPolledQueueTasks
     /tmp/ccJPZByr.s:494    .bss:00000002 xPolledQueue.1774
     /tmp/ccJPZByr.s:448    .text:0000014e xArePollingQueuesStillRunning

UNDEFINED SYMBOLS
xQueueGenericSend
vTaskDelay
xQueueGenericReceive
uxQueueMessagesWaiting
xQueueGenericCreate
xTaskGenericCreate
__do_copy_data
__do_clear_bss
