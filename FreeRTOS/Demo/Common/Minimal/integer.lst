   1               		.file	"integer.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 121               	vCompeteingIntMathTask:
 122               		.stabd	46,0,0
   1:../Common/Minimal/integer.c **** /*
   2:../Common/Minimal/integer.c ****     FreeRTOS V7.6.0 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:../Common/Minimal/integer.c ****     All rights reserved
   4:../Common/Minimal/integer.c **** 
   5:../Common/Minimal/integer.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../Common/Minimal/integer.c **** 
   7:../Common/Minimal/integer.c ****     ***************************************************************************
   8:../Common/Minimal/integer.c ****      *                                                                       *
   9:../Common/Minimal/integer.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:../Common/Minimal/integer.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:../Common/Minimal/integer.c ****      *    platform software that has become a de facto standard.             *
  12:../Common/Minimal/integer.c ****      *                                                                       *
  13:../Common/Minimal/integer.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:../Common/Minimal/integer.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:../Common/Minimal/integer.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:../Common/Minimal/integer.c ****      *                                                                       *
  17:../Common/Minimal/integer.c ****      *    Thank you!                                                         *
  18:../Common/Minimal/integer.c ****      *                                                                       *
  19:../Common/Minimal/integer.c ****     ***************************************************************************
  20:../Common/Minimal/integer.c **** 
  21:../Common/Minimal/integer.c ****     This file is part of the FreeRTOS distribution.
  22:../Common/Minimal/integer.c **** 
  23:../Common/Minimal/integer.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:../Common/Minimal/integer.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:../Common/Minimal/integer.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:../Common/Minimal/integer.c **** 
  27:../Common/Minimal/integer.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:../Common/Minimal/integer.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:../Common/Minimal/integer.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:../Common/Minimal/integer.c ****     >>! kernel.
  31:../Common/Minimal/integer.c **** 
  32:../Common/Minimal/integer.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:../Common/Minimal/integer.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:../Common/Minimal/integer.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:../Common/Minimal/integer.c ****     link: http://www.freertos.org/a00114.html
  36:../Common/Minimal/integer.c **** 
  37:../Common/Minimal/integer.c ****     1 tab == 4 spaces!
  38:../Common/Minimal/integer.c **** 
  39:../Common/Minimal/integer.c ****     ***************************************************************************
  40:../Common/Minimal/integer.c ****      *                                                                       *
  41:../Common/Minimal/integer.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:../Common/Minimal/integer.c ****      *    not run, what could be wrong?"                                     *
  43:../Common/Minimal/integer.c ****      *                                                                       *
  44:../Common/Minimal/integer.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:../Common/Minimal/integer.c ****      *                                                                       *
  46:../Common/Minimal/integer.c ****     ***************************************************************************
  47:../Common/Minimal/integer.c **** 
  48:../Common/Minimal/integer.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:../Common/Minimal/integer.c ****     license and Real Time Engineers Ltd. contact details.
  50:../Common/Minimal/integer.c **** 
  51:../Common/Minimal/integer.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:../Common/Minimal/integer.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:../Common/Minimal/integer.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:../Common/Minimal/integer.c **** 
  55:../Common/Minimal/integer.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:../Common/Minimal/integer.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:../Common/Minimal/integer.c ****     licenses offer ticketed support, indemnification and middleware.
  58:../Common/Minimal/integer.c **** 
  59:../Common/Minimal/integer.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:../Common/Minimal/integer.c ****     engineered and independently SIL3 certified version for use in safety and
  61:../Common/Minimal/integer.c ****     mission critical applications that require provable dependability.
  62:../Common/Minimal/integer.c **** 
  63:../Common/Minimal/integer.c ****     1 tab == 4 spaces!
  64:../Common/Minimal/integer.c **** */
  65:../Common/Minimal/integer.c **** 
  66:../Common/Minimal/integer.c **** /*
  67:../Common/Minimal/integer.c ****  * Creates one or more tasks that repeatedly perform a set of integer
  68:../Common/Minimal/integer.c ****  * calculations.  The result of each run-time calculation is compared to the 
  69:../Common/Minimal/integer.c ****  * known expected result - with a mismatch being indicative of an error in the
  70:../Common/Minimal/integer.c ****  * context switch mechanism.
  71:../Common/Minimal/integer.c ****  */
  72:../Common/Minimal/integer.c **** 
  73:../Common/Minimal/integer.c **** #include <stdlib.h>
  74:../Common/Minimal/integer.c **** 
  75:../Common/Minimal/integer.c **** /* Scheduler include files. */
  76:../Common/Minimal/integer.c **** #include "FreeRTOS.h"
  77:../Common/Minimal/integer.c **** #include "task.h"
  78:../Common/Minimal/integer.c **** 
  79:../Common/Minimal/integer.c **** /* Demo program include files. */
  80:../Common/Minimal/integer.c **** #include "integer.h"
  81:../Common/Minimal/integer.c **** 
  82:../Common/Minimal/integer.c **** /* The constants used in the calculation. */
  83:../Common/Minimal/integer.c **** #define intgCONST1				( ( long ) 123 )
  84:../Common/Minimal/integer.c **** #define intgCONST2				( ( long ) 234567 )
  85:../Common/Minimal/integer.c **** #define intgCONST3				( ( long ) -3 )
  86:../Common/Minimal/integer.c **** #define intgCONST4				( ( long ) 7 )
  87:../Common/Minimal/integer.c **** #define intgEXPECTED_ANSWER		( ( ( intgCONST1 + intgCONST2 ) * intgCONST3 ) / intgCONST4 )
  88:../Common/Minimal/integer.c **** 
  89:../Common/Minimal/integer.c **** #define intgSTACK_SIZE			configMINIMAL_STACK_SIZE
  90:../Common/Minimal/integer.c **** 
  91:../Common/Minimal/integer.c **** /* As this is the minimal version, we will only create one task. */
  92:../Common/Minimal/integer.c **** #define intgNUMBER_OF_TASKS		( 1 )
  93:../Common/Minimal/integer.c **** 
  94:../Common/Minimal/integer.c **** /* The task function.  Repeatedly performs a 32 bit calculation, checking the
  95:../Common/Minimal/integer.c **** result against the expected result.  If the result is incorrect then the
  96:../Common/Minimal/integer.c **** context switch must have caused some corruption. */
  97:../Common/Minimal/integer.c **** static portTASK_FUNCTION_PROTO( vCompeteingIntMathTask, pvParameters );
  98:../Common/Minimal/integer.c **** 
  99:../Common/Minimal/integer.c **** /* Variables that are set to true within the calculation task to indicate
 100:../Common/Minimal/integer.c **** that the task is still executing.  The check task sets the variable back to
 101:../Common/Minimal/integer.c **** false, flagging an error if the variable is still false the next time it
 102:../Common/Minimal/integer.c **** is called. */
 103:../Common/Minimal/integer.c **** static volatile signed portBASE_TYPE xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( signed portBASE_TYPE )
 104:../Common/Minimal/integer.c **** 
 105:../Common/Minimal/integer.c **** /*-----------------------------------------------------------*/
 106:../Common/Minimal/integer.c **** 
 107:../Common/Minimal/integer.c **** void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
 108:../Common/Minimal/integer.c **** {
 109:../Common/Minimal/integer.c **** short sTask;
 110:../Common/Minimal/integer.c **** 
 111:../Common/Minimal/integer.c **** 	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
 112:../Common/Minimal/integer.c **** 	{
 113:../Common/Minimal/integer.c **** 		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( x
 114:../Common/Minimal/integer.c **** 	}
 115:../Common/Minimal/integer.c **** }
 116:../Common/Minimal/integer.c **** /*-----------------------------------------------------------*/
 117:../Common/Minimal/integer.c **** 
 118:../Common/Minimal/integer.c **** static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
 119:../Common/Minimal/integer.c **** {
 124               	.LM0:
 125               	.LFBB1:
 126 0000 CF93      		push r28
 127 0002 DF93      		push r29
 128 0004 00D0      		rcall .
 129 0006 00D0      		rcall .
 130 0008 CDB7      		in r28,__SP_L__
 131 000a DEB7      		in r29,__SP_H__
 132               	/* prologue: function */
 133               	/* frame size = 4 */
 134               	/* stack size = 6 */
 135               	.L__stack_usage = 6
 136 000c 5C01      		movw r10,r24
 120:../Common/Minimal/integer.c **** /* These variables are all effectively set to constants so they are volatile to
 121:../Common/Minimal/integer.c **** ensure the compiler does not just get rid of them. */
 122:../Common/Minimal/integer.c **** volatile long lValue;
 123:../Common/Minimal/integer.c **** short sError = pdFALSE;
 138               	.LM1:
 139 000e 00E0      		ldi r16,0
 140 0010 10E0      		ldi r17,0
 124:../Common/Minimal/integer.c **** volatile signed portBASE_TYPE *pxTaskHasExecuted;
 125:../Common/Minimal/integer.c **** 
 126:../Common/Minimal/integer.c **** 	/* Set a pointer to the variable we are going to set to true each
 127:../Common/Minimal/integer.c **** 	iteration.  This is also a good test of the parameter passing mechanism
 128:../Common/Minimal/integer.c **** 	within each port. */
 129:../Common/Minimal/integer.c **** 	pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
 130:../Common/Minimal/integer.c **** 
 131:../Common/Minimal/integer.c **** 	/* Keep performing a calculation and checking the result against a constant. */
 132:../Common/Minimal/integer.c **** 	for( ;; )
 133:../Common/Minimal/integer.c **** 	{
 134:../Common/Minimal/integer.c **** 		/* Perform the calculation.  This will store partial value in
 135:../Common/Minimal/integer.c **** 		registers, resulting in a good test of the context switch mechanism. */
 136:../Common/Minimal/integer.c **** 		lValue = intgCONST1;
 142               	.LM2:
 143 0012 8BE7      		ldi r24,lo8(123)
 144 0014 C82E      		mov r12,r24
 145 0016 D12C      		mov r13,__zero_reg__
 146 0018 E12C      		mov r14,__zero_reg__
 147 001a F12C      		mov r15,__zero_reg__
 137:../Common/Minimal/integer.c **** 		lValue += intgCONST2;
 138:../Common/Minimal/integer.c **** 
 139:../Common/Minimal/integer.c **** 		/* Yield in case cooperative scheduling is being used. */
 140:../Common/Minimal/integer.c **** 		#if configUSE_PREEMPTION == 0
 141:../Common/Minimal/integer.c **** 		{
 142:../Common/Minimal/integer.c **** 			taskYIELD();
 143:../Common/Minimal/integer.c **** 		}
 144:../Common/Minimal/integer.c **** 		#endif
 145:../Common/Minimal/integer.c **** 
 146:../Common/Minimal/integer.c **** 		/* Finish off the calculation. */
 147:../Common/Minimal/integer.c **** 		lValue *= intgCONST3;
 148:../Common/Minimal/integer.c **** 		lValue /= intgCONST4;
 149               	.LM3:
 150 001c 97E0      		ldi r25,lo8(7)
 151 001e 492E      		mov r4,r25
 152 0020 512C      		mov r5,__zero_reg__
 153 0022 612C      		mov r6,__zero_reg__
 154 0024 712C      		mov r7,__zero_reg__
 149:../Common/Minimal/integer.c **** 
 150:../Common/Minimal/integer.c **** 		/* If the calculation is found to be incorrect we stop setting the 
 151:../Common/Minimal/integer.c **** 		TaskHasExecuted variable so the check task can see an error has 
 152:../Common/Minimal/integer.c **** 		occurred. */
 153:../Common/Minimal/integer.c **** 		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised ou
 154:../Common/Minimal/integer.c **** 		{
 155:../Common/Minimal/integer.c **** 			sError = pdTRUE;
 156:../Common/Minimal/integer.c **** 		}
 157:../Common/Minimal/integer.c **** 
 158:../Common/Minimal/integer.c **** 		if( sError == pdFALSE )
 159:../Common/Minimal/integer.c **** 		{
 160:../Common/Minimal/integer.c **** 			/* We have not encountered any errors, so set the flag that show
 161:../Common/Minimal/integer.c **** 			we are still executing.  This will be periodically cleared by
 162:../Common/Minimal/integer.c **** 			the check task. */
 163:../Common/Minimal/integer.c **** 			portENTER_CRITICAL();
 164:../Common/Minimal/integer.c **** 				*pxTaskHasExecuted = pdTRUE;
 156               	.LM4:
 157 0026 9924      		clr r9
 158 0028 9394      		inc r9
 159 002a 00C0      		rjmp .L6
 160               	.L5:
 158:../Common/Minimal/integer.c **** 		if( sError == pdFALSE )
 162               	.LM5:
 163 002c 01E0      		ldi r16,lo8(1)
 164 002e 10E0      		ldi r17,0
 165               	.L6:
 136:../Common/Minimal/integer.c **** 		lValue = intgCONST1;
 167               	.LM6:
 168 0030 C982      		std Y+1,r12
 169 0032 DA82      		std Y+2,r13
 170 0034 EB82      		std Y+3,r14
 171 0036 FC82      		std Y+4,r15
 137:../Common/Minimal/integer.c **** 		lValue += intgCONST2;
 173               	.LM7:
 174 0038 8981      		ldd r24,Y+1
 175 003a 9A81      		ldd r25,Y+2
 176 003c AB81      		ldd r26,Y+3
 177 003e BC81      		ldd r27,Y+4
 178 0040 895B      		subi r24,-71
 179 0042 9B46      		sbci r25,107
 180 0044 AC4F      		sbci r26,-4
 181 0046 BF4F      		sbci r27,-1
 182 0048 8983      		std Y+1,r24
 183 004a 9A83      		std Y+2,r25
 184 004c AB83      		std Y+3,r26
 185 004e BC83      		std Y+4,r27
 147:../Common/Minimal/integer.c **** 		lValue *= intgCONST3;
 187               	.LM8:
 188 0050 2981      		ldd r18,Y+1
 189 0052 3A81      		ldd r19,Y+2
 190 0054 4B81      		ldd r20,Y+3
 191 0056 5C81      		ldd r21,Y+4
 192 0058 ADEF      		ldi r26,lo8(-3)
 193 005a BFEF      		ldi r27,lo8(-1)
 194 005c 0E94 0000 		call __mulohisi3
 195 0060 6983      		std Y+1,r22
 196 0062 7A83      		std Y+2,r23
 197 0064 8B83      		std Y+3,r24
 198 0066 9C83      		std Y+4,r25
 148:../Common/Minimal/integer.c **** 		lValue /= intgCONST4;
 200               	.LM9:
 201 0068 6981      		ldd r22,Y+1
 202 006a 7A81      		ldd r23,Y+2
 203 006c 8B81      		ldd r24,Y+3
 204 006e 9C81      		ldd r25,Y+4
 205 0070 A301      		movw r20,r6
 206 0072 9201      		movw r18,r4
 207 0074 0E94 0000 		call __divmodsi4
 208 0078 2983      		std Y+1,r18
 209 007a 3A83      		std Y+2,r19
 210 007c 4B83      		std Y+3,r20
 211 007e 5C83      		std Y+4,r21
 153:../Common/Minimal/integer.c **** 		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised ou
 213               	.LM10:
 214 0080 8981      		ldd r24,Y+1
 215 0082 9A81      		ldd r25,Y+2
 216 0084 AB81      		ldd r26,Y+3
 217 0086 BC81      		ldd r27,Y+4
 218 0088 8B31      		cpi r24,27
 219 008a 9747      		sbci r25,119
 220 008c AE4F      		sbci r26,-2
 221 008e BF4F      		sbci r27,-1
 222 0090 01F4      		brne .L5
 158:../Common/Minimal/integer.c **** 		if( sError == pdFALSE )
 224               	.LM11:
 225 0092 0115      		cp r16,__zero_reg__
 226 0094 1105      		cpc r17,__zero_reg__
 227 0096 01F4      		brne .L5
 163:../Common/Minimal/integer.c **** 			portENTER_CRITICAL();
 229               	.LM12:
 230               	/* #APP */
 231               	 ;  163 "../Common/Minimal/integer.c" 1
 232 0098 0FB6      		in		__tmp_reg__, __SREG__
 233               	 ;  0 "" 2
 234               	 ;  163 "../Common/Minimal/integer.c" 1
 235 009a F894      		cli
 236               	 ;  0 "" 2
 237               	 ;  163 "../Common/Minimal/integer.c" 1
 238 009c 0F92      		push	__tmp_reg__
 239               	 ;  0 "" 2
 241               	.LM13:
 242               	/* #NOAPP */
 243 009e F501      		movw r30,r10
 244 00a0 9082      		st Z,r9
 165:../Common/Minimal/integer.c **** 			portEXIT_CRITICAL();
 246               	.LM14:
 247               	/* #APP */
 248               	 ;  165 "../Common/Minimal/integer.c" 1
 249 00a2 0F90      		pop		__tmp_reg__
 250               	 ;  0 "" 2
 251               	 ;  165 "../Common/Minimal/integer.c" 1
 252 00a4 0FBE      		out		__SREG__, __tmp_reg__
 253               	 ;  0 "" 2
 254               	/* #NOAPP */
 255 00a6 00C0      		rjmp .L6
 261               	.Lscope1:
 263               		.stabd	78,0,0
 264               		.section	.rodata.str1.1,"aMS",@progbits,1
 265               	.LC0:
 266 0000 496E 744D 		.string	"IntMath"
 266      6174 6800 
 267               		.text
 270               	.global	vStartIntegerMathTasks
 272               	vStartIntegerMathTasks:
 273               		.stabd	46,0,0
 108:../Common/Minimal/integer.c **** {
 275               	.LM15:
 276               	.LFBB2:
 277 00a8 AF92      		push r10
 278 00aa BF92      		push r11
 279 00ac CF92      		push r12
 280 00ae DF92      		push r13
 281 00b0 EF92      		push r14
 282 00b2 FF92      		push r15
 283 00b4 0F93      		push r16
 284               	/* prologue: function */
 285               	/* frame size = 0 */
 286               	/* stack size = 7 */
 287               	.L__stack_usage = 7
 113:../Common/Minimal/integer.c **** 		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( x
 289               	.LM16:
 290 00b6 A12C      		mov r10,__zero_reg__
 291 00b8 B12C      		mov r11,__zero_reg__
 292 00ba C12C      		mov r12,__zero_reg__
 293 00bc D12C      		mov r13,__zero_reg__
 294 00be E12C      		mov r14,__zero_reg__
 295 00c0 F12C      		mov r15,__zero_reg__
 296 00c2 082F      		mov r16,r24
 297 00c4 20E0      		ldi r18,lo8(xTaskCheck)
 298 00c6 30E0      		ldi r19,hi8(xTaskCheck)
 299 00c8 45E5      		ldi r20,lo8(85)
 300 00ca 50E0      		ldi r21,0
 301 00cc 60E0      		ldi r22,lo8(.LC0)
 302 00ce 70E0      		ldi r23,hi8(.LC0)
 303 00d0 80E0      		ldi r24,lo8(gs(vCompeteingIntMathTask))
 304 00d2 90E0      		ldi r25,hi8(gs(vCompeteingIntMathTask))
 305 00d4 0E94 0000 		call xTaskGenericCreate
 306               	/* epilogue start */
 115:../Common/Minimal/integer.c **** }
 308               	.LM17:
 309 00d8 0F91      		pop r16
 310 00da FF90      		pop r15
 311 00dc EF90      		pop r14
 312 00de DF90      		pop r13
 313 00e0 CF90      		pop r12
 314 00e2 BF90      		pop r11
 315 00e4 AF90      		pop r10
 316 00e6 0895      		ret
 318               	.Lscope2:
 320               		.stabd	78,0,0
 322               	.global	xAreIntegerMathsTaskStillRunning
 324               	xAreIntegerMathsTaskStillRunning:
 325               		.stabd	46,0,0
 166:../Common/Minimal/integer.c **** 		}
 167:../Common/Minimal/integer.c **** 
 168:../Common/Minimal/integer.c **** 		/* Yield in case cooperative scheduling is being used. */
 169:../Common/Minimal/integer.c **** 		#if configUSE_PREEMPTION == 0
 170:../Common/Minimal/integer.c **** 		{
 171:../Common/Minimal/integer.c **** 			taskYIELD();
 172:../Common/Minimal/integer.c **** 		}
 173:../Common/Minimal/integer.c **** 		#endif
 174:../Common/Minimal/integer.c **** 	}
 175:../Common/Minimal/integer.c **** }
 176:../Common/Minimal/integer.c **** /*-----------------------------------------------------------*/
 177:../Common/Minimal/integer.c **** 
 178:../Common/Minimal/integer.c **** /* This is called to check that all the created tasks are still running. */
 179:../Common/Minimal/integer.c **** portBASE_TYPE xAreIntegerMathsTaskStillRunning( void )
 180:../Common/Minimal/integer.c **** {
 327               	.LM18:
 328               	.LFBB3:
 329               	/* prologue: function */
 330               	/* frame size = 0 */
 331               	/* stack size = 0 */
 332               	.L__stack_usage = 0
 181:../Common/Minimal/integer.c **** portBASE_TYPE xReturn = pdTRUE;
 182:../Common/Minimal/integer.c **** short sTask;
 183:../Common/Minimal/integer.c **** 
 184:../Common/Minimal/integer.c **** 	/* Check the maths tasks are still running by ensuring their check variables 
 185:../Common/Minimal/integer.c **** 	are still being set to true. */
 186:../Common/Minimal/integer.c **** 	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
 187:../Common/Minimal/integer.c **** 	{
 188:../Common/Minimal/integer.c **** 		if( xTaskCheck[ sTask ] == pdFALSE )
 334               	.LM19:
 335 00e8 9091 0000 		lds r25,xTaskCheck
 189:../Common/Minimal/integer.c **** 		{
 190:../Common/Minimal/integer.c **** 			/* The check has not incremented so an error exists. */
 191:../Common/Minimal/integer.c **** 			xReturn = pdFALSE;
 192:../Common/Minimal/integer.c **** 		}
 193:../Common/Minimal/integer.c **** 
 194:../Common/Minimal/integer.c **** 		/* Reset the check variable so we can tell if it has been set by
 195:../Common/Minimal/integer.c **** 		the next time around. */
 196:../Common/Minimal/integer.c **** 		xTaskCheck[ sTask ] = pdFALSE;
 337               	.LM20:
 338 00ec 1092 0000 		sts xTaskCheck,__zero_reg__
 188:../Common/Minimal/integer.c **** 		if( xTaskCheck[ sTask ] == pdFALSE )
 340               	.LM21:
 341 00f0 81E0      		ldi r24,lo8(1)
 342 00f2 9111      		cpse r25,__zero_reg__
 343 00f4 00C0      		rjmp .L9
 344 00f6 80E0      		ldi r24,0
 345               	.L9:
 197:../Common/Minimal/integer.c **** 	}
 198:../Common/Minimal/integer.c **** 
 199:../Common/Minimal/integer.c **** 	return xReturn;
 200:../Common/Minimal/integer.c **** }
 347               	.LM22:
 348 00f8 0895      		ret
 350               	.Lscope3:
 352               		.stabd	78,0,0
 353               		.local	xTaskCheck
 354               		.comm	xTaskCheck,1,1
 357               	.Letext0:
 358               		.ident	"GCC: (GNU) 4.7.2"
 359               	.global __do_copy_data
 360               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 integer.c
     /tmp/ccgTh2vo.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccgTh2vo.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccgTh2vo.s:4      *ABS*:0000003f __SREG__
     /tmp/ccgTh2vo.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccgTh2vo.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccgTh2vo.s:121    .text:00000000 vCompeteingIntMathTask
     /tmp/ccgTh2vo.s:272    .text:000000a8 vStartIntegerMathTasks
                             .bss:00000000 xTaskCheck
     /tmp/ccgTh2vo.s:324    .text:000000e8 xAreIntegerMathsTaskStillRunning

UNDEFINED SYMBOLS
__mulohisi3
__divmodsi4
xTaskGenericCreate
__do_copy_data
__do_clear_bss
