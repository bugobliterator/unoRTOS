   1               		.file	"queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 135               	prvCopyDataToQueue:
 136               		.stabd	46,0,0
   1:../../Source/queue.c **** /*
   2:../../Source/queue.c ****     FreeRTOS V7.6.0 - Copyright (C) 2013 Real Time Engineers Ltd.
   3:../../Source/queue.c ****     All rights reserved
   4:../../Source/queue.c **** 
   5:../../Source/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../../Source/queue.c **** 
   7:../../Source/queue.c ****     ***************************************************************************
   8:../../Source/queue.c ****      *                                                                       *
   9:../../Source/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:../../Source/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:../../Source/queue.c ****      *    platform software that has become a de facto standard.             *
  12:../../Source/queue.c ****      *                                                                       *
  13:../../Source/queue.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:../../Source/queue.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:../../Source/queue.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:../../Source/queue.c ****      *                                                                       *
  17:../../Source/queue.c ****      *    Thank you!                                                         *
  18:../../Source/queue.c ****      *                                                                       *
  19:../../Source/queue.c ****     ***************************************************************************
  20:../../Source/queue.c **** 
  21:../../Source/queue.c ****     This file is part of the FreeRTOS distribution.
  22:../../Source/queue.c **** 
  23:../../Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:../../Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:../../Source/queue.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:../../Source/queue.c **** 
  27:../../Source/queue.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:../../Source/queue.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:../../Source/queue.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:../../Source/queue.c ****     >>! kernel.
  31:../../Source/queue.c **** 
  32:../../Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:../../Source/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:../../Source/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:../../Source/queue.c ****     link: http://www.freertos.org/a00114.html
  36:../../Source/queue.c **** 
  37:../../Source/queue.c ****     1 tab == 4 spaces!
  38:../../Source/queue.c **** 
  39:../../Source/queue.c ****     ***************************************************************************
  40:../../Source/queue.c ****      *                                                                       *
  41:../../Source/queue.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:../../Source/queue.c ****      *    not run, what could be wrong?"                                     *
  43:../../Source/queue.c ****      *                                                                       *
  44:../../Source/queue.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:../../Source/queue.c ****      *                                                                       *
  46:../../Source/queue.c ****     ***************************************************************************
  47:../../Source/queue.c **** 
  48:../../Source/queue.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:../../Source/queue.c ****     license and Real Time Engineers Ltd. contact details.
  50:../../Source/queue.c **** 
  51:../../Source/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:../../Source/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:../../Source/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:../../Source/queue.c **** 
  55:../../Source/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:../../Source/queue.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:../../Source/queue.c ****     licenses offer ticketed support, indemnification and middleware.
  58:../../Source/queue.c **** 
  59:../../Source/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:../../Source/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  61:../../Source/queue.c ****     mission critical applications that require provable dependability.
  62:../../Source/queue.c **** 
  63:../../Source/queue.c ****     1 tab == 4 spaces!
  64:../../Source/queue.c **** */
  65:../../Source/queue.c **** 
  66:../../Source/queue.c **** #include <stdlib.h>
  67:../../Source/queue.c **** #include <string.h>
  68:../../Source/queue.c **** 
  69:../../Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  70:../../Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  71:../../Source/queue.c **** task.h is included from an application file. */
  72:../../Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  73:../../Source/queue.c **** 
  74:../../Source/queue.c **** #include "FreeRTOS.h"
  75:../../Source/queue.c **** #include "task.h"
  76:../../Source/queue.c **** #include "queue.h"
  77:../../Source/queue.c **** 
  78:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  79:../../Source/queue.c **** 	#include "croutine.h"
  80:../../Source/queue.c **** #endif
  81:../../Source/queue.c **** 
  82:../../Source/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  83:../../Source/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  84:../../Source/queue.c **** header files above, but not in this file, in order to generate the correct
  85:../../Source/queue.c **** privileged Vs unprivileged linkage and placement. */
  86:../../Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  87:../../Source/queue.c **** 
  88:../../Source/queue.c **** 
  89:../../Source/queue.c **** /* Constants used with the cRxLock and xTxLock structure members. */
  90:../../Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  91:../../Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  92:../../Source/queue.c **** 
  93:../../Source/queue.c **** /* When the xQUEUE structure is used to represent a base queue its pcHead and
  94:../../Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  95:../../Source/queue.c **** xQUEUE structure is used to represent a mutex pcHead and pcTail pointers are
  96:../../Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  97:../../Source/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
  98:../../Source/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
  99:../../Source/queue.c **** the code is maintained despite this dual use of two structure members.  An
 100:../../Source/queue.c **** alternative implementation would be to use a union, but use of a union is
 101:../../Source/queue.c **** against the coding standard (although an exception to the standard has been
 102:../../Source/queue.c **** permitted where the dual use also significantly changes the type of the
 103:../../Source/queue.c **** structure member). */
 104:../../Source/queue.c **** #define pxMutexHolder					pcTail
 105:../../Source/queue.c **** #define uxQueueType						pcHead
 106:../../Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 107:../../Source/queue.c **** 
 108:../../Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 109:../../Source/queue.c **** zero. */
 110:../../Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
 111:../../Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
 112:../../Source/queue.c **** 
 113:../../Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
 114:../../Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 115:../../Source/queue.c **** 	performed just because a higher priority task has been woken. */
 116:../../Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
 117:../../Source/queue.c **** #else
 118:../../Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 119:../../Source/queue.c **** #endif
 120:../../Source/queue.c **** 
 121:../../Source/queue.c **** /*
 122:../../Source/queue.c ****  * Definition of the queue used by the scheduler.
 123:../../Source/queue.c ****  * Items are queued by copy, not reference.
 124:../../Source/queue.c ****  */
 125:../../Source/queue.c **** typedef struct QueueDefinition
 126:../../Source/queue.c **** {
 127:../../Source/queue.c **** 	signed char *pcHead;					/*< Points to the beginning of the queue storage area. */
 128:../../Source/queue.c **** 	signed char *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more b
 129:../../Source/queue.c **** 
 130:../../Source/queue.c **** 	signed char *pcWriteTo;					/*< Points to the free next place in the storage area. */
 131:../../Source/queue.c **** 
 132:../../Source/queue.c **** 	union									/* Use of a union is an exception to the coding standard to ensure two mutually excl
 133:../../Source/queue.c **** 	{
 134:../../Source/queue.c **** 		signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from when the
 135:../../Source/queue.c **** 		unsigned portBASE_TYPE uxRecursiveCallCount;/*< Maintains a count of the numebr of times a recurs
 136:../../Source/queue.c **** 	} u;
 137:../../Source/queue.c **** 
 138:../../Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 139:../../Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 140:../../Source/queue.c **** 
 141:../../Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 142:../../Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 143:../../Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 144:../../Source/queue.c **** 
 145:../../Source/queue.c **** 	volatile signed portBASE_TYPE xRxLock;	/*< Stores the number of items received from the queue (rem
 146:../../Source/queue.c **** 	volatile signed portBASE_TYPE xTxLock;	/*< Stores the number of items transmitted to the queue (ad
 147:../../Source/queue.c **** 
 148:../../Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 149:../../Source/queue.c **** 		unsigned char ucQueueNumber;
 150:../../Source/queue.c **** 		unsigned char ucQueueType;
 151:../../Source/queue.c **** 	#endif
 152:../../Source/queue.c **** 
 153:../../Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 154:../../Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 155:../../Source/queue.c **** 	#endif
 156:../../Source/queue.c **** 
 157:../../Source/queue.c **** } xQUEUE;
 158:../../Source/queue.c **** /*-----------------------------------------------------------*/
 159:../../Source/queue.c **** 
 160:../../Source/queue.c **** /*
 161:../../Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 162:../../Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 163:../../Source/queue.c ****  */
 164:../../Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 165:../../Source/queue.c **** 
 166:../../Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 167:../../Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 168:../../Source/queue.c **** 	more user friendly. */
 169:../../Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 170:../../Source/queue.c **** 	{
 171:../../Source/queue.c **** 		signed char *pcQueueName;
 172:../../Source/queue.c **** 		xQueueHandle xHandle;
 173:../../Source/queue.c **** 	} xQueueRegistryItem;
 174:../../Source/queue.c **** 
 175:../../Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 176:../../Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 177:../../Source/queue.c **** 	array position being vacant. */
 178:../../Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 179:../../Source/queue.c **** 
 180:../../Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 181:../../Source/queue.c **** 
 182:../../Source/queue.c **** /*
 183:../../Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 184:../../Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 185:../../Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 186:../../Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 187:../../Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 188:../../Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 189:../../Source/queue.c ****  */
 190:../../Source/queue.c **** static void prvUnlockQueue( xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 191:../../Source/queue.c **** 
 192:../../Source/queue.c **** /*
 193:../../Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 194:../../Source/queue.c ****  *
 195:../../Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 196:../../Source/queue.c ****  */
 197:../../Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 198:../../Source/queue.c **** 
 199:../../Source/queue.c **** /*
 200:../../Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 201:../../Source/queue.c ****  *
 202:../../Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 203:../../Source/queue.c ****  */
 204:../../Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 205:../../Source/queue.c **** 
 206:../../Source/queue.c **** /*
 207:../../Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 208:../../Source/queue.c ****  * back of the queue.
 209:../../Source/queue.c ****  */
 210:../../Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 211:../../Source/queue.c **** 
 212:../../Source/queue.c **** /*
 213:../../Source/queue.c ****  * Copies an item out of a queue.
 214:../../Source/queue.c ****  */
 215:../../Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTI
 216:../../Source/queue.c **** 
 217:../../Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 218:../../Source/queue.c **** 	/*
 219:../../Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 220:../../Source/queue.c **** 	 * the queue set that the queue contains data.
 221:../../Source/queue.c **** 	 */
 222:../../Source/queue.c **** 	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopy
 223:../../Source/queue.c **** #endif
 224:../../Source/queue.c **** 
 225:../../Source/queue.c **** /*-----------------------------------------------------------*/
 226:../../Source/queue.c **** 
 227:../../Source/queue.c **** /*
 228:../../Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 229:../../Source/queue.c ****  * accessing the queue event lists.
 230:../../Source/queue.c ****  */
 231:../../Source/queue.c **** #define prvLockQueue( pxQueue )								\
 232:../../Source/queue.c **** 	taskENTER_CRITICAL();									\
 233:../../Source/queue.c **** 	{														\
 234:../../Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 235:../../Source/queue.c **** 		{													\
 236:../../Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 237:../../Source/queue.c **** 		}													\
 238:../../Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 239:../../Source/queue.c **** 		{													\
 240:../../Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 241:../../Source/queue.c **** 		}													\
 242:../../Source/queue.c **** 	}														\
 243:../../Source/queue.c **** 	taskEXIT_CRITICAL()
 244:../../Source/queue.c **** /*-----------------------------------------------------------*/
 245:../../Source/queue.c **** 
 246:../../Source/queue.c **** portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
 247:../../Source/queue.c **** {
 248:../../Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 249:../../Source/queue.c **** 
 250:../../Source/queue.c **** 	configASSERT( pxQueue );
 251:../../Source/queue.c **** 
 252:../../Source/queue.c **** 	taskENTER_CRITICAL();
 253:../../Source/queue.c **** 	{
 254:../../Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 255:../../Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 256:../../Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 257:../../Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U )
 258:../../Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 259:../../Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 260:../../Source/queue.c **** 
 261:../../Source/queue.c **** 		if( xNewQueue == pdFALSE )
 262:../../Source/queue.c **** 		{
 263:../../Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 264:../../Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 265:../../Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 266:../../Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 267:../../Source/queue.c **** 			it will be possible to write to it. */
 268:../../Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 269:../../Source/queue.c **** 			{
 270:../../Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 271:../../Source/queue.c **** 				{
 272:../../Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 273:../../Source/queue.c **** 				}
 274:../../Source/queue.c **** 			}
 275:../../Source/queue.c **** 		}
 276:../../Source/queue.c **** 		else
 277:../../Source/queue.c **** 		{
 278:../../Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 279:../../Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 280:../../Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 281:../../Source/queue.c **** 		}
 282:../../Source/queue.c **** 	}
 283:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 284:../../Source/queue.c **** 
 285:../../Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 286:../../Source/queue.c **** 	versions. */
 287:../../Source/queue.c **** 	return pdPASS;
 288:../../Source/queue.c **** }
 289:../../Source/queue.c **** /*-----------------------------------------------------------*/
 290:../../Source/queue.c **** 
 291:../../Source/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 292:../../Source/queue.c **** {
 293:../../Source/queue.c **** xQUEUE *pxNewQueue;
 294:../../Source/queue.c **** size_t xQueueSizeInBytes;
 295:../../Source/queue.c **** xQueueHandle xReturn = NULL;
 296:../../Source/queue.c **** 
 297:../../Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 298:../../Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 299:../../Source/queue.c **** 	( void ) ucQueueType;
 300:../../Source/queue.c **** 
 301:../../Source/queue.c **** 	/* Allocate the new queue structure. */
 302:../../Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 303:../../Source/queue.c **** 	{
 304:../../Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 305:../../Source/queue.c **** 		if( pxNewQueue != NULL )
 306:../../Source/queue.c **** 		{
 307:../../Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 308:../../Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 309:../../Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA
 310:../../Source/queue.c **** 
 311:../../Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 312:../../Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 313:../../Source/queue.c **** 			{
 314:../../Source/queue.c **** 				/* Initialise the queue members as described above where the
 315:../../Source/queue.c **** 				queue type is defined. */
 316:../../Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 317:../../Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 318:../../Source/queue.c **** 				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 319:../../Source/queue.c **** 
 320:../../Source/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 321:../../Source/queue.c **** 				{
 322:../../Source/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 323:../../Source/queue.c **** 				}
 324:../../Source/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 325:../../Source/queue.c **** 
 326:../../Source/queue.c **** 				#if( configUSE_QUEUE_SETS == 1 )
 327:../../Source/queue.c **** 				{
 328:../../Source/queue.c **** 					pxNewQueue->pxQueueSetContainer = NULL;
 329:../../Source/queue.c **** 				}
 330:../../Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 331:../../Source/queue.c **** 
 332:../../Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 333:../../Source/queue.c **** 				xReturn = pxNewQueue;
 334:../../Source/queue.c **** 			}
 335:../../Source/queue.c **** 			else
 336:../../Source/queue.c **** 			{
 337:../../Source/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 338:../../Source/queue.c **** 				vPortFree( pxNewQueue );
 339:../../Source/queue.c **** 			}
 340:../../Source/queue.c **** 		}
 341:../../Source/queue.c **** 	}
 342:../../Source/queue.c **** 
 343:../../Source/queue.c **** 	configASSERT( xReturn );
 344:../../Source/queue.c **** 
 345:../../Source/queue.c **** 	return xReturn;
 346:../../Source/queue.c **** }
 347:../../Source/queue.c **** /*-----------------------------------------------------------*/
 348:../../Source/queue.c **** 
 349:../../Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 350:../../Source/queue.c **** 
 351:../../Source/queue.c **** 	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
 352:../../Source/queue.c **** 	{
 353:../../Source/queue.c **** 	xQUEUE *pxNewQueue;
 354:../../Source/queue.c **** 
 355:../../Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 356:../../Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 357:../../Source/queue.c **** 		( void ) ucQueueType;
 358:../../Source/queue.c **** 
 359:../../Source/queue.c **** 		/* Allocate the new queue structure. */
 360:../../Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 361:../../Source/queue.c **** 		if( pxNewQueue != NULL )
 362:../../Source/queue.c **** 		{
 363:../../Source/queue.c **** 			/* Information required for priority inheritance. */
 364:../../Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 365:../../Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 366:../../Source/queue.c **** 
 367:../../Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 368:../../Source/queue.c **** 			of the queue. */
 369:../../Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 370:../../Source/queue.c **** 			pxNewQueue->u.pcReadFrom = NULL;
 371:../../Source/queue.c **** 
 372:../../Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 373:../../Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 374:../../Source/queue.c **** 			of the mutex. */
 375:../../Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 376:../../Source/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 377:../../Source/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 378:../../Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 379:../../Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 380:../../Source/queue.c **** 
 381:../../Source/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 382:../../Source/queue.c **** 			{
 383:../../Source/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 384:../../Source/queue.c **** 			}
 385:../../Source/queue.c **** 			#endif
 386:../../Source/queue.c **** 
 387:../../Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
 388:../../Source/queue.c **** 			{
 389:../../Source/queue.c **** 				pxNewQueue->pxQueueSetContainer = NULL;
 390:../../Source/queue.c **** 			}
 391:../../Source/queue.c **** 			#endif
 392:../../Source/queue.c **** 
 393:../../Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 394:../../Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 395:../../Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 396:../../Source/queue.c **** 
 397:../../Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 398:../../Source/queue.c **** 
 399:../../Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 400:../../Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 401:../../Source/queue.c **** 		}
 402:../../Source/queue.c **** 		else
 403:../../Source/queue.c **** 		{
 404:../../Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 405:../../Source/queue.c **** 		}
 406:../../Source/queue.c **** 
 407:../../Source/queue.c **** 		configASSERT( pxNewQueue );
 408:../../Source/queue.c **** 		return pxNewQueue;
 409:../../Source/queue.c **** 	}
 410:../../Source/queue.c **** 
 411:../../Source/queue.c **** #endif /* configUSE_MUTEXES */
 412:../../Source/queue.c **** /*-----------------------------------------------------------*/
 413:../../Source/queue.c **** 
 414:../../Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 415:../../Source/queue.c **** 
 416:../../Source/queue.c **** 	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
 417:../../Source/queue.c **** 	{
 418:../../Source/queue.c **** 	void *pxReturn;
 419:../../Source/queue.c **** 
 420:../../Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 421:../../Source/queue.c **** 		be called directly.  Note:  This is is a good way of determining if the
 422:../../Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 423:../../Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 424:../../Source/queue.c **** 		following critical section exiting and the function returning. */
 425:../../Source/queue.c **** 		taskENTER_CRITICAL();
 426:../../Source/queue.c **** 		{
 427:../../Source/queue.c **** 			if( ( ( xQUEUE * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 428:../../Source/queue.c **** 			{
 429:../../Source/queue.c **** 				pxReturn = ( void * ) ( ( xQUEUE * ) xSemaphore )->pxMutexHolder;
 430:../../Source/queue.c **** 			}
 431:../../Source/queue.c **** 			else
 432:../../Source/queue.c **** 			{
 433:../../Source/queue.c **** 				pxReturn = NULL;
 434:../../Source/queue.c **** 			}
 435:../../Source/queue.c **** 		}
 436:../../Source/queue.c **** 		taskEXIT_CRITICAL();
 437:../../Source/queue.c **** 
 438:../../Source/queue.c **** 		return pxReturn;
 439:../../Source/queue.c **** 	}
 440:../../Source/queue.c **** 
 441:../../Source/queue.c **** #endif
 442:../../Source/queue.c **** /*-----------------------------------------------------------*/
 443:../../Source/queue.c **** 
 444:../../Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 445:../../Source/queue.c **** 
 446:../../Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex )
 447:../../Source/queue.c **** 	{
 448:../../Source/queue.c **** 	portBASE_TYPE xReturn;
 449:../../Source/queue.c **** 	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
 450:../../Source/queue.c **** 
 451:../../Source/queue.c **** 		configASSERT( pxMutex );
 452:../../Source/queue.c **** 
 453:../../Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 454:../../Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 455:../../Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 456:../../Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 457:../../Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 458:../../Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 459:../../Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 460:../../Source/queue.c **** 		{
 461:../../Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 462:../../Source/queue.c **** 
 463:../../Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 464:../../Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 465:../../Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 466:../../Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 467:../../Source/queue.c **** 			uxRecursiveCallCount member. */
 468:../../Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 469:../../Source/queue.c **** 
 470:../../Source/queue.c **** 			/* Have we unwound the call count? */
 471:../../Source/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( unsigned portBASE_TYPE ) 0 )
 472:../../Source/queue.c **** 			{
 473:../../Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 474:../../Source/queue.c **** 				task that might be waiting to access the mutex. */
 475:../../Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 476:../../Source/queue.c **** 			}
 477:../../Source/queue.c **** 
 478:../../Source/queue.c **** 			xReturn = pdPASS;
 479:../../Source/queue.c **** 		}
 480:../../Source/queue.c **** 		else
 481:../../Source/queue.c **** 		{
 482:../../Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 483:../../Source/queue.c **** 			xReturn = pdFAIL;
 484:../../Source/queue.c **** 
 485:../../Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 486:../../Source/queue.c **** 		}
 487:../../Source/queue.c **** 
 488:../../Source/queue.c **** 		return xReturn;
 489:../../Source/queue.c **** 	}
 490:../../Source/queue.c **** 
 491:../../Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 492:../../Source/queue.c **** /*-----------------------------------------------------------*/
 493:../../Source/queue.c **** 
 494:../../Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 495:../../Source/queue.c **** 
 496:../../Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime )
 497:../../Source/queue.c **** 	{
 498:../../Source/queue.c **** 	portBASE_TYPE xReturn;
 499:../../Source/queue.c **** 	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
 500:../../Source/queue.c **** 
 501:../../Source/queue.c **** 		configASSERT( pxMutex );
 502:../../Source/queue.c **** 
 503:../../Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 504:../../Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 505:../../Source/queue.c **** 
 506:../../Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 507:../../Source/queue.c **** 
 508:../../Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 509:../../Source/queue.c **** 		{
 510:../../Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 511:../../Source/queue.c **** 			xReturn = pdPASS;
 512:../../Source/queue.c **** 		}
 513:../../Source/queue.c **** 		else
 514:../../Source/queue.c **** 		{
 515:../../Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 516:../../Source/queue.c **** 
 517:../../Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 518:../../Source/queue.c **** 			we may have blocked to reach here. */
 519:../../Source/queue.c **** 			if( xReturn == pdPASS )
 520:../../Source/queue.c **** 			{
 521:../../Source/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 522:../../Source/queue.c **** 			}
 523:../../Source/queue.c **** 			else
 524:../../Source/queue.c **** 			{
 525:../../Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 526:../../Source/queue.c **** 			}
 527:../../Source/queue.c **** 		}
 528:../../Source/queue.c **** 
 529:../../Source/queue.c **** 		return xReturn;
 530:../../Source/queue.c **** 	}
 531:../../Source/queue.c **** 
 532:../../Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 533:../../Source/queue.c **** /*-----------------------------------------------------------*/
 534:../../Source/queue.c **** 
 535:../../Source/queue.c **** #if ( configUSE_COUNTING_SEMAPHORES == 1 )
 536:../../Source/queue.c **** 
 537:../../Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxMaxCount, unsigned portBASE_T
 538:../../Source/queue.c **** 	{
 539:../../Source/queue.c **** 	xQueueHandle xHandle;
 540:../../Source/queue.c **** 
 541:../../Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 542:../../Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 543:../../Source/queue.c **** 
 544:../../Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 545:../../Source/queue.c **** 
 546:../../Source/queue.c **** 		if( xHandle != NULL )
 547:../../Source/queue.c **** 		{
 548:../../Source/queue.c **** 			( ( xQUEUE * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 549:../../Source/queue.c **** 
 550:../../Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 551:../../Source/queue.c **** 		}
 552:../../Source/queue.c **** 		else
 553:../../Source/queue.c **** 		{
 554:../../Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 555:../../Source/queue.c **** 		}
 556:../../Source/queue.c **** 
 557:../../Source/queue.c **** 		configASSERT( xHandle );
 558:../../Source/queue.c **** 		return xHandle;
 559:../../Source/queue.c **** 	}
 560:../../Source/queue.c **** 
 561:../../Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 562:../../Source/queue.c **** /*-----------------------------------------------------------*/
 563:../../Source/queue.c **** 
 564:../../Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 565:../../Source/queue.c **** {
 566:../../Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 567:../../Source/queue.c **** xTimeOutType xTimeOut;
 568:../../Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 569:../../Source/queue.c **** 
 570:../../Source/queue.c **** 	configASSERT( pxQueue );
 571:../../Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 572:../../Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 573:../../Source/queue.c **** 
 574:../../Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 575:../../Source/queue.c **** 	statements within the function itself.  This is done in the interest
 576:../../Source/queue.c **** 	of execution time efficiency. */
 577:../../Source/queue.c **** 	for( ;; )
 578:../../Source/queue.c **** 	{
 579:../../Source/queue.c **** 		taskENTER_CRITICAL();
 580:../../Source/queue.c **** 		{
 581:../../Source/queue.c **** 			/* Is there room on the queue now?  The running task must be
 582:../../Source/queue.c **** 			the highest priority task wanting to access the queue.  If
 583:../../Source/queue.c **** 			the head item in the queue is to be overwritten then it does
 584:../../Source/queue.c **** 			not matter if the queue is full. */
 585:../../Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 586:../../Source/queue.c **** 			{
 587:../../Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 588:../../Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 589:../../Source/queue.c **** 
 590:../../Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 591:../../Source/queue.c **** 				{
 592:../../Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 593:../../Source/queue.c **** 					{
 594:../../Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 595:../../Source/queue.c **** 						{
 596:../../Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 597:../../Source/queue.c **** 							to the queue set caused a higher priority task to
 598:../../Source/queue.c **** 							unblock. A context switch is required. */
 599:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 600:../../Source/queue.c **** 						}
 601:../../Source/queue.c **** 					}
 602:../../Source/queue.c **** 					else
 603:../../Source/queue.c **** 					{
 604:../../Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 605:../../Source/queue.c **** 						queue then unblock it now. */
 606:../../Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 607:../../Source/queue.c **** 						{
 608:../../Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 609:../../Source/queue.c **** 							{
 610:../../Source/queue.c **** 								/* The unblocked task has a priority higher than
 611:../../Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 612:../../Source/queue.c **** 								do this from within the critical section - the
 613:../../Source/queue.c **** 								kernel takes care of that. */
 614:../../Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 615:../../Source/queue.c **** 							}
 616:../../Source/queue.c **** 						}
 617:../../Source/queue.c **** 					}
 618:../../Source/queue.c **** 				}
 619:../../Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 620:../../Source/queue.c **** 				{
 621:../../Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 622:../../Source/queue.c **** 					queue then unblock it now. */
 623:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 624:../../Source/queue.c **** 					{
 625:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 626:../../Source/queue.c **** 						{
 627:../../Source/queue.c **** 							/* The unblocked task has a priority higher than
 628:../../Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 629:../../Source/queue.c **** 							this from within the critical section - the kernel
 630:../../Source/queue.c **** 							takes care of that. */
 631:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 632:../../Source/queue.c **** 						}
 633:../../Source/queue.c **** 					}
 634:../../Source/queue.c **** 				}
 635:../../Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 636:../../Source/queue.c **** 
 637:../../Source/queue.c **** 				taskEXIT_CRITICAL();
 638:../../Source/queue.c **** 
 639:../../Source/queue.c **** 				/* Return to the original privilege level before exiting the
 640:../../Source/queue.c **** 				function. */
 641:../../Source/queue.c **** 				return pdPASS;
 642:../../Source/queue.c **** 			}
 643:../../Source/queue.c **** 			else
 644:../../Source/queue.c **** 			{
 645:../../Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 646:../../Source/queue.c **** 				{
 647:../../Source/queue.c **** 					/* The queue was full and no block time is specified (or
 648:../../Source/queue.c **** 					the block time has expired) so leave now. */
 649:../../Source/queue.c **** 					taskEXIT_CRITICAL();
 650:../../Source/queue.c **** 
 651:../../Source/queue.c **** 					/* Return to the original privilege level before exiting
 652:../../Source/queue.c **** 					the function. */
 653:../../Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 654:../../Source/queue.c **** 					return errQUEUE_FULL;
 655:../../Source/queue.c **** 				}
 656:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 657:../../Source/queue.c **** 				{
 658:../../Source/queue.c **** 					/* The queue was full and a block time was specified so
 659:../../Source/queue.c **** 					configure the timeout structure. */
 660:../../Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 661:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 662:../../Source/queue.c **** 				}
 663:../../Source/queue.c **** 				else
 664:../../Source/queue.c **** 				{
 665:../../Source/queue.c **** 					/* Entry time was already set. */
 666:../../Source/queue.c **** 				}
 667:../../Source/queue.c **** 			}
 668:../../Source/queue.c **** 		}
 669:../../Source/queue.c **** 		taskEXIT_CRITICAL();
 670:../../Source/queue.c **** 
 671:../../Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 672:../../Source/queue.c **** 		now the critical section has been exited. */
 673:../../Source/queue.c **** 
 674:../../Source/queue.c **** 		vTaskSuspendAll();
 675:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 676:../../Source/queue.c **** 
 677:../../Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 678:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 679:../../Source/queue.c **** 		{
 680:../../Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 681:../../Source/queue.c **** 			{
 682:../../Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 683:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 684:../../Source/queue.c **** 
 685:../../Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 686:../../Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 687:../../Source/queue.c **** 				remove this task from the event	list again - but as the
 688:../../Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 689:../../Source/queue.c **** 				ready last instead of the actual ready list. */
 690:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 691:../../Source/queue.c **** 
 692:../../Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 693:../../Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 694:../../Source/queue.c **** 				task is already in a ready list before it yields - in which
 695:../../Source/queue.c **** 				case the yield will not cause a context switch unless there
 696:../../Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 697:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 698:../../Source/queue.c **** 				{
 699:../../Source/queue.c **** 					portYIELD_WITHIN_API();
 700:../../Source/queue.c **** 				}
 701:../../Source/queue.c **** 			}
 702:../../Source/queue.c **** 			else
 703:../../Source/queue.c **** 			{
 704:../../Source/queue.c **** 				/* Try again. */
 705:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 706:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 707:../../Source/queue.c **** 			}
 708:../../Source/queue.c **** 		}
 709:../../Source/queue.c **** 		else
 710:../../Source/queue.c **** 		{
 711:../../Source/queue.c **** 			/* The timeout has expired. */
 712:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
 713:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 714:../../Source/queue.c **** 
 715:../../Source/queue.c **** 			/* Return to the original privilege level before exiting the
 716:../../Source/queue.c **** 			function. */
 717:../../Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 718:../../Source/queue.c **** 			return errQUEUE_FULL;
 719:../../Source/queue.c **** 		}
 720:../../Source/queue.c **** 	}
 721:../../Source/queue.c **** }
 722:../../Source/queue.c **** /*-----------------------------------------------------------*/
 723:../../Source/queue.c **** 
 724:../../Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 725:../../Source/queue.c **** 
 726:../../Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, 
 727:../../Source/queue.c **** 	{
 728:../../Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 729:../../Source/queue.c **** 	xTimeOutType xTimeOut;
 730:../../Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 731:../../Source/queue.c **** 
 732:../../Source/queue.c **** 		configASSERT( pxQueue );
 733:../../Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 734:../../Source/queue.c **** 
 735:../../Source/queue.c **** 		for( ;; )
 736:../../Source/queue.c **** 		{
 737:../../Source/queue.c **** 			taskENTER_CRITICAL();
 738:../../Source/queue.c **** 			{
 739:../../Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 740:../../Source/queue.c **** 				the highest priority task wanting to access the queue. */
 741:../../Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 742:../../Source/queue.c **** 				{
 743:../../Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 744:../../Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 745:../../Source/queue.c **** 
 746:../../Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 747:../../Source/queue.c **** 					queue then unblock it now. */
 748:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 749:../../Source/queue.c **** 					{
 750:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 751:../../Source/queue.c **** 						{
 752:../../Source/queue.c **** 							/* The unblocked task has a priority higher than
 753:../../Source/queue.c **** 							our own so yield immediately. */
 754:../../Source/queue.c **** 							portYIELD_WITHIN_API();
 755:../../Source/queue.c **** 						}
 756:../../Source/queue.c **** 					}
 757:../../Source/queue.c **** 
 758:../../Source/queue.c **** 					taskEXIT_CRITICAL();
 759:../../Source/queue.c **** 					return pdPASS;
 760:../../Source/queue.c **** 				}
 761:../../Source/queue.c **** 				else
 762:../../Source/queue.c **** 				{
 763:../../Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 764:../../Source/queue.c **** 					{
 765:../../Source/queue.c **** 						taskEXIT_CRITICAL();
 766:../../Source/queue.c **** 						return errQUEUE_FULL;
 767:../../Source/queue.c **** 					}
 768:../../Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 769:../../Source/queue.c **** 					{
 770:../../Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 771:../../Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 772:../../Source/queue.c **** 					}
 773:../../Source/queue.c **** 				}
 774:../../Source/queue.c **** 			}
 775:../../Source/queue.c **** 			taskEXIT_CRITICAL();
 776:../../Source/queue.c **** 
 777:../../Source/queue.c **** 			taskENTER_CRITICAL();
 778:../../Source/queue.c **** 			{
 779:../../Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 780:../../Source/queue.c **** 				{
 781:../../Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 782:../../Source/queue.c **** 					{
 783:../../Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 784:../../Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 785:../../Source/queue.c **** 						portYIELD_WITHIN_API();
 786:../../Source/queue.c **** 					}
 787:../../Source/queue.c **** 				}
 788:../../Source/queue.c **** 				else
 789:../../Source/queue.c **** 				{
 790:../../Source/queue.c **** 					taskEXIT_CRITICAL();
 791:../../Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 792:../../Source/queue.c **** 					return errQUEUE_FULL;
 793:../../Source/queue.c **** 				}
 794:../../Source/queue.c **** 			}
 795:../../Source/queue.c **** 			taskEXIT_CRITICAL();
 796:../../Source/queue.c **** 		}
 797:../../Source/queue.c **** 	}
 798:../../Source/queue.c **** 
 799:../../Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 800:../../Source/queue.c **** /*-----------------------------------------------------------*/
 801:../../Source/queue.c **** 
 802:../../Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 803:../../Source/queue.c **** 
 804:../../Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTick
 805:../../Source/queue.c **** 	{
 806:../../Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 807:../../Source/queue.c **** 	xTimeOutType xTimeOut;
 808:../../Source/queue.c **** 	signed char *pcOriginalReadPosition;
 809:../../Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 810:../../Source/queue.c **** 
 811:../../Source/queue.c **** 		configASSERT( pxQueue );
 812:../../Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 813:../../Source/queue.c **** 
 814:../../Source/queue.c **** 		for( ;; )
 815:../../Source/queue.c **** 		{
 816:../../Source/queue.c **** 			taskENTER_CRITICAL();
 817:../../Source/queue.c **** 			{
 818:../../Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 819:../../Source/queue.c **** 				{
 820:../../Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 821:../../Source/queue.c **** 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 822:../../Source/queue.c **** 
 823:../../Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 824:../../Source/queue.c **** 
 825:../../Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 826:../../Source/queue.c **** 					{
 827:../../Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 828:../../Source/queue.c **** 
 829:../../Source/queue.c **** 						/* Data is actually being removed (not just peeked). */
 830:../../Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 831:../../Source/queue.c **** 
 832:../../Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 833:../../Source/queue.c **** 						{
 834:../../Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 835:../../Source/queue.c **** 							{
 836:../../Source/queue.c **** 								/* Record the information required to implement
 837:../../Source/queue.c **** 								priority inheritance should it become necessary. */
 838:../../Source/queue.c **** 								pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle();
 839:../../Source/queue.c **** 							}
 840:../../Source/queue.c **** 						}
 841:../../Source/queue.c **** 						#endif
 842:../../Source/queue.c **** 
 843:../../Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 844:../../Source/queue.c **** 						{
 845:../../Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 846:../../Source/queue.c **** 							{
 847:../../Source/queue.c **** 								portYIELD_WITHIN_API();
 848:../../Source/queue.c **** 							}
 849:../../Source/queue.c **** 						}
 850:../../Source/queue.c **** 					}
 851:../../Source/queue.c **** 					else
 852:../../Source/queue.c **** 					{
 853:../../Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 854:../../Source/queue.c **** 
 855:../../Source/queue.c **** 						/* We are not removing the data, so reset our read
 856:../../Source/queue.c **** 						pointer. */
 857:../../Source/queue.c **** 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 858:../../Source/queue.c **** 
 859:../../Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 860:../../Source/queue.c **** 						any other tasks waiting for the data. */
 861:../../Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 862:../../Source/queue.c **** 						{
 863:../../Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 864:../../Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 865:../../Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 866:../../Source/queue.c **** 							{
 867:../../Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 868:../../Source/queue.c **** 								portYIELD_WITHIN_API();
 869:../../Source/queue.c **** 							}
 870:../../Source/queue.c **** 						}
 871:../../Source/queue.c **** 
 872:../../Source/queue.c **** 					}
 873:../../Source/queue.c **** 
 874:../../Source/queue.c **** 					taskEXIT_CRITICAL();
 875:../../Source/queue.c **** 					return pdPASS;
 876:../../Source/queue.c **** 				}
 877:../../Source/queue.c **** 				else
 878:../../Source/queue.c **** 				{
 879:../../Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 880:../../Source/queue.c **** 					{
 881:../../Source/queue.c **** 						taskEXIT_CRITICAL();
 882:../../Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 883:../../Source/queue.c **** 						return errQUEUE_EMPTY;
 884:../../Source/queue.c **** 					}
 885:../../Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 886:../../Source/queue.c **** 					{
 887:../../Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 888:../../Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 889:../../Source/queue.c **** 					}
 890:../../Source/queue.c **** 				}
 891:../../Source/queue.c **** 			}
 892:../../Source/queue.c **** 			taskEXIT_CRITICAL();
 893:../../Source/queue.c **** 
 894:../../Source/queue.c **** 			taskENTER_CRITICAL();
 895:../../Source/queue.c **** 			{
 896:../../Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 897:../../Source/queue.c **** 				{
 898:../../Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 899:../../Source/queue.c **** 					{
 900:../../Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 901:../../Source/queue.c **** 
 902:../../Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 903:../../Source/queue.c **** 						{
 904:../../Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 905:../../Source/queue.c **** 							{
 906:../../Source/queue.c **** 								portENTER_CRITICAL();
 907:../../Source/queue.c **** 								{
 908:../../Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 909:../../Source/queue.c **** 								}
 910:../../Source/queue.c **** 								portEXIT_CRITICAL();
 911:../../Source/queue.c **** 							}
 912:../../Source/queue.c **** 						}
 913:../../Source/queue.c **** 						#endif
 914:../../Source/queue.c **** 
 915:../../Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 916:../../Source/queue.c **** 						portYIELD_WITHIN_API();
 917:../../Source/queue.c **** 					}
 918:../../Source/queue.c **** 				}
 919:../../Source/queue.c **** 				else
 920:../../Source/queue.c **** 				{
 921:../../Source/queue.c **** 					taskEXIT_CRITICAL();
 922:../../Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 923:../../Source/queue.c **** 					return errQUEUE_EMPTY;
 924:../../Source/queue.c **** 				}
 925:../../Source/queue.c **** 			}
 926:../../Source/queue.c **** 			taskEXIT_CRITICAL();
 927:../../Source/queue.c **** 		}
 928:../../Source/queue.c **** 	}
 929:../../Source/queue.c **** 
 930:../../Source/queue.c **** 
 931:../../Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 932:../../Source/queue.c **** /*-----------------------------------------------------------*/
 933:../../Source/queue.c **** 
 934:../../Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueu
 935:../../Source/queue.c **** {
 936:../../Source/queue.c **** signed portBASE_TYPE xReturn;
 937:../../Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 938:../../Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 939:../../Source/queue.c **** 
 940:../../Source/queue.c **** 	configASSERT( pxQueue );
 941:../../Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 942:../../Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 943:../../Source/queue.c **** 
 944:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 945:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 946:../../Source/queue.c **** 	above the maximum system call priority are keep permanently enabled, even
 947:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 948:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 949:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 950:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 951:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 952:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 953:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 954:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 955:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 956:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 957:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 958:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 959:../../Source/queue.c **** 
 960:../../Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 961:../../Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 962:../../Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 963:../../Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 964:../../Source/queue.c **** 	by this	post). */
 965:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 966:../../Source/queue.c **** 	{
 967:../../Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 968:../../Source/queue.c **** 		{
 969:../../Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 970:../../Source/queue.c **** 
 971:../../Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 972:../../Source/queue.c **** 
 973:../../Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 974:../../Source/queue.c **** 			be done when the queue is unlocked later. */
 975:../../Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 976:../../Source/queue.c **** 			{
 977:../../Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 978:../../Source/queue.c **** 				{
 979:../../Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 980:../../Source/queue.c **** 					{
 981:../../Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 982:../../Source/queue.c **** 						{
 983:../../Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 984:../../Source/queue.c **** 							to the queue set caused a higher priority task to
 985:../../Source/queue.c **** 							unblock.  A context switch is required. */
 986:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 987:../../Source/queue.c **** 							{
 988:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 989:../../Source/queue.c **** 							}
 990:../../Source/queue.c **** 						}
 991:../../Source/queue.c **** 					}
 992:../../Source/queue.c **** 					else
 993:../../Source/queue.c **** 					{
 994:../../Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 995:../../Source/queue.c **** 						{
 996:../../Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 997:../../Source/queue.c **** 							{
 998:../../Source/queue.c **** 								/* The task waiting has a higher priority so record that a
 999:../../Source/queue.c **** 								context	switch is required. */
1000:../../Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1001:../../Source/queue.c **** 								{
1002:../../Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1003:../../Source/queue.c **** 								}
1004:../../Source/queue.c **** 							}
1005:../../Source/queue.c **** 						}
1006:../../Source/queue.c **** 					}
1007:../../Source/queue.c **** 				}
1008:../../Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1009:../../Source/queue.c **** 				{
1010:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1011:../../Source/queue.c **** 					{
1012:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1013:../../Source/queue.c **** 						{
1014:../../Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1015:../../Source/queue.c **** 							context	switch is required. */
1016:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1017:../../Source/queue.c **** 							{
1018:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1019:../../Source/queue.c **** 							}
1020:../../Source/queue.c **** 						}
1021:../../Source/queue.c **** 					}
1022:../../Source/queue.c **** 				}
1023:../../Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1024:../../Source/queue.c **** 			}
1025:../../Source/queue.c **** 			else
1026:../../Source/queue.c **** 			{
1027:../../Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1028:../../Source/queue.c **** 				knows that data was posted while it was locked. */
1029:../../Source/queue.c **** 				++( pxQueue->xTxLock );
1030:../../Source/queue.c **** 			}
1031:../../Source/queue.c **** 
1032:../../Source/queue.c **** 			xReturn = pdPASS;
1033:../../Source/queue.c **** 		}
1034:../../Source/queue.c **** 		else
1035:../../Source/queue.c **** 		{
1036:../../Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1037:../../Source/queue.c **** 			xReturn = errQUEUE_FULL;
1038:../../Source/queue.c **** 		}
1039:../../Source/queue.c **** 	}
1040:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1041:../../Source/queue.c **** 
1042:../../Source/queue.c **** 	return xReturn;
1043:../../Source/queue.c **** }
1044:../../Source/queue.c **** /*-----------------------------------------------------------*/
1045:../../Source/queue.c **** 
1046:../../Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType
1047:../../Source/queue.c **** {
1048:../../Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
1049:../../Source/queue.c **** xTimeOutType xTimeOut;
1050:../../Source/queue.c **** signed char *pcOriginalReadPosition;
1051:../../Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1052:../../Source/queue.c **** 
1053:../../Source/queue.c **** 	configASSERT( pxQueue );
1054:../../Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
1055:../../Source/queue.c **** 
1056:../../Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1057:../../Source/queue.c **** 	statements within the function itself.  This is done in the interest
1058:../../Source/queue.c **** 	of execution time efficiency. */
1059:../../Source/queue.c **** 
1060:../../Source/queue.c **** 	for( ;; )
1061:../../Source/queue.c **** 	{
1062:../../Source/queue.c **** 		taskENTER_CRITICAL();
1063:../../Source/queue.c **** 		{
1064:../../Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
1065:../../Source/queue.c **** 			the highest priority task wanting to access the queue. */
1066:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1067:../../Source/queue.c **** 			{
1068:../../Source/queue.c **** 				/* Remember the read position in case the queue is only being
1069:../../Source/queue.c **** 				peeked. */
1070:../../Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1071:../../Source/queue.c **** 
1072:../../Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1073:../../Source/queue.c **** 
1074:../../Source/queue.c **** 				if( xJustPeeking == pdFALSE )
1075:../../Source/queue.c **** 				{
1076:../../Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1077:../../Source/queue.c **** 
1078:../../Source/queue.c **** 					/* Actually removing data, not just peeking. */
1079:../../Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
1080:../../Source/queue.c **** 
1081:../../Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1082:../../Source/queue.c **** 					{
1083:../../Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1084:../../Source/queue.c **** 						{
1085:../../Source/queue.c **** 							/* Record the information required to implement
1086:../../Source/queue.c **** 							priority inheritance should it become necessary. */
1087:../../Source/queue.c **** 							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is
1088:../../Source/queue.c **** 						}
1089:../../Source/queue.c **** 					}
1090:../../Source/queue.c **** 					#endif
1091:../../Source/queue.c **** 
1092:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1093:../../Source/queue.c **** 					{
1094:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
1095:../../Source/queue.c **** 						{
1096:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
1097:../../Source/queue.c **** 						}
1098:../../Source/queue.c **** 					}
1099:../../Source/queue.c **** 				}
1100:../../Source/queue.c **** 				else
1101:../../Source/queue.c **** 				{
1102:../../Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1103:../../Source/queue.c **** 
1104:../../Source/queue.c **** 					/* The data is not being removed, so reset the read
1105:../../Source/queue.c **** 					pointer. */
1106:../../Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1107:../../Source/queue.c **** 
1108:../../Source/queue.c **** 					/* The data is being left in the queue, so see if there are
1109:../../Source/queue.c **** 					any other tasks waiting for the data. */
1110:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1111:../../Source/queue.c **** 					{
1112:../../Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
1113:../../Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
1114:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1115:../../Source/queue.c **** 						{
1116:../../Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
1117:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
1118:../../Source/queue.c **** 						}
1119:../../Source/queue.c **** 					}
1120:../../Source/queue.c **** 				}
1121:../../Source/queue.c **** 
1122:../../Source/queue.c **** 				taskEXIT_CRITICAL();
1123:../../Source/queue.c **** 				return pdPASS;
1124:../../Source/queue.c **** 			}
1125:../../Source/queue.c **** 			else
1126:../../Source/queue.c **** 			{
1127:../../Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
1128:../../Source/queue.c **** 				{
1129:../../Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1130:../../Source/queue.c **** 					the block time has expired) so leave now. */
1131:../../Source/queue.c **** 					taskEXIT_CRITICAL();
1132:../../Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1133:../../Source/queue.c **** 					return errQUEUE_EMPTY;
1134:../../Source/queue.c **** 				}
1135:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1136:../../Source/queue.c **** 				{
1137:../../Source/queue.c **** 					/* The queue was empty and a block time was specified so
1138:../../Source/queue.c **** 					configure the timeout structure. */
1139:../../Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
1140:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1141:../../Source/queue.c **** 				}
1142:../../Source/queue.c **** 				else
1143:../../Source/queue.c **** 				{
1144:../../Source/queue.c **** 					/* Entry time was already set. */
1145:../../Source/queue.c **** 				}
1146:../../Source/queue.c **** 			}
1147:../../Source/queue.c **** 		}
1148:../../Source/queue.c **** 		taskEXIT_CRITICAL();
1149:../../Source/queue.c **** 
1150:../../Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1151:../../Source/queue.c **** 		now the critical section has been exited. */
1152:../../Source/queue.c **** 
1153:../../Source/queue.c **** 		vTaskSuspendAll();
1154:../../Source/queue.c **** 		prvLockQueue( pxQueue );
1155:../../Source/queue.c **** 
1156:../../Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1157:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1158:../../Source/queue.c **** 		{
1159:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1160:../../Source/queue.c **** 			{
1161:../../Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1162:../../Source/queue.c **** 
1163:../../Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1164:../../Source/queue.c **** 				{
1165:../../Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1166:../../Source/queue.c **** 					{
1167:../../Source/queue.c **** 						portENTER_CRITICAL();
1168:../../Source/queue.c **** 						{
1169:../../Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1170:../../Source/queue.c **** 						}
1171:../../Source/queue.c **** 						portEXIT_CRITICAL();
1172:../../Source/queue.c **** 					}
1173:../../Source/queue.c **** 				}
1174:../../Source/queue.c **** 				#endif
1175:../../Source/queue.c **** 
1176:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1177:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1178:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1179:../../Source/queue.c **** 				{
1180:../../Source/queue.c **** 					portYIELD_WITHIN_API();
1181:../../Source/queue.c **** 				}
1182:../../Source/queue.c **** 			}
1183:../../Source/queue.c **** 			else
1184:../../Source/queue.c **** 			{
1185:../../Source/queue.c **** 				/* Try again. */
1186:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1187:../../Source/queue.c **** 				( void ) xTaskResumeAll();
1188:../../Source/queue.c **** 			}
1189:../../Source/queue.c **** 		}
1190:../../Source/queue.c **** 		else
1191:../../Source/queue.c **** 		{
1192:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
1193:../../Source/queue.c **** 			( void ) xTaskResumeAll();
1194:../../Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1195:../../Source/queue.c **** 			return errQUEUE_EMPTY;
1196:../../Source/queue.c **** 		}
1197:../../Source/queue.c **** 	}
1198:../../Source/queue.c **** }
1199:../../Source/queue.c **** /*-----------------------------------------------------------*/
1200:../../Source/queue.c **** 
1201:../../Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portB
1202:../../Source/queue.c **** {
1203:../../Source/queue.c **** signed portBASE_TYPE xReturn;
1204:../../Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1205:../../Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1206:../../Source/queue.c **** 
1207:../../Source/queue.c **** 	configASSERT( pxQueue );
1208:../../Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
1209:../../Source/queue.c **** 
1210:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1211:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1212:../../Source/queue.c **** 	above the maximum system call priority are keep permanently enabled, even
1213:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1214:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1215:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1216:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1217:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1218:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1219:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1220:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1221:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1222:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1223:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1224:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1225:../../Source/queue.c **** 
1226:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1227:../../Source/queue.c **** 	{
1228:../../Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1229:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1230:../../Source/queue.c **** 		{
1231:../../Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1232:../../Source/queue.c **** 
1233:../../Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1234:../../Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1235:../../Source/queue.c **** 
1236:../../Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1237:../../Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1238:../../Source/queue.c **** 			will know that an ISR has removed data while the queue was
1239:../../Source/queue.c **** 			locked. */
1240:../../Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
1241:../../Source/queue.c **** 			{
1242:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1243:../../Source/queue.c **** 				{
1244:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1245:../../Source/queue.c **** 					{
1246:../../Source/queue.c **** 						/* The task waiting has a higher priority than us so
1247:../../Source/queue.c **** 						force a context switch. */
1248:../../Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
1249:../../Source/queue.c **** 						{
1250:../../Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
1251:../../Source/queue.c **** 						}
1252:../../Source/queue.c **** 					}
1253:../../Source/queue.c **** 				}
1254:../../Source/queue.c **** 			}
1255:../../Source/queue.c **** 			else
1256:../../Source/queue.c **** 			{
1257:../../Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1258:../../Source/queue.c **** 				knows that data was removed while it was locked. */
1259:../../Source/queue.c **** 				++( pxQueue->xRxLock );
1260:../../Source/queue.c **** 			}
1261:../../Source/queue.c **** 
1262:../../Source/queue.c **** 			xReturn = pdPASS;
1263:../../Source/queue.c **** 		}
1264:../../Source/queue.c **** 		else
1265:../../Source/queue.c **** 		{
1266:../../Source/queue.c **** 			xReturn = pdFAIL;
1267:../../Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1268:../../Source/queue.c **** 		}
1269:../../Source/queue.c **** 	}
1270:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1271:../../Source/queue.c **** 
1272:../../Source/queue.c **** 	return xReturn;
1273:../../Source/queue.c **** }
1274:../../Source/queue.c **** /*-----------------------------------------------------------*/
1275:../../Source/queue.c **** 
1276:../../Source/queue.c **** signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue,  void * const pvBuffer )
1277:../../Source/queue.c **** {
1278:../../Source/queue.c **** signed portBASE_TYPE xReturn;
1279:../../Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1280:../../Source/queue.c **** signed char *pcOriginalReadPosition;
1281:../../Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1282:../../Source/queue.c **** 
1283:../../Source/queue.c **** 	configASSERT( pxQueue );
1284:../../Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
1285:../../Source/queue.c **** 
1286:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1287:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1288:../../Source/queue.c **** 	above the maximum system call priority are keep permanently enabled, even
1289:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1290:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1291:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1292:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1293:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1294:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1295:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1296:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1297:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1298:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1299:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1300:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1301:../../Source/queue.c **** 
1302:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1303:../../Source/queue.c **** 	{
1304:../../Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1305:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1306:../../Source/queue.c **** 		{
1307:../../Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1308:../../Source/queue.c **** 
1309:../../Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1310:../../Source/queue.c **** 			actually being removed from the queue. */
1311:../../Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1312:../../Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1313:../../Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1314:../../Source/queue.c **** 
1315:../../Source/queue.c **** 			xReturn = pdPASS;
1316:../../Source/queue.c **** 		}
1317:../../Source/queue.c **** 		else
1318:../../Source/queue.c **** 		{
1319:../../Source/queue.c **** 			xReturn = pdFAIL;
1320:../../Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1321:../../Source/queue.c **** 		}
1322:../../Source/queue.c **** 	}
1323:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1324:../../Source/queue.c **** 
1325:../../Source/queue.c **** 	return xReturn;
1326:../../Source/queue.c **** }
1327:../../Source/queue.c **** /*-----------------------------------------------------------*/
1328:../../Source/queue.c **** 
1329:../../Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
1330:../../Source/queue.c **** {
1331:../../Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1332:../../Source/queue.c **** 
1333:../../Source/queue.c **** 	configASSERT( xQueue );
1334:../../Source/queue.c **** 
1335:../../Source/queue.c **** 	taskENTER_CRITICAL();
1336:../../Source/queue.c **** 		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
1337:../../Source/queue.c **** 	taskEXIT_CRITICAL();
1338:../../Source/queue.c **** 
1339:../../Source/queue.c **** 	return uxReturn;
1340:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1341:../../Source/queue.c **** /*-----------------------------------------------------------*/
1342:../../Source/queue.c **** 
1343:../../Source/queue.c **** unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
1344:../../Source/queue.c **** {
1345:../../Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1346:../../Source/queue.c **** xQUEUE *pxQueue;
1347:../../Source/queue.c **** 
1348:../../Source/queue.c **** 	pxQueue = ( xQUEUE * ) xQueue;
1349:../../Source/queue.c **** 	configASSERT( pxQueue );
1350:../../Source/queue.c **** 
1351:../../Source/queue.c **** 	taskENTER_CRITICAL();
1352:../../Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1353:../../Source/queue.c **** 	taskEXIT_CRITICAL();
1354:../../Source/queue.c **** 
1355:../../Source/queue.c **** 	return uxReturn;
1356:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1357:../../Source/queue.c **** /*-----------------------------------------------------------*/
1358:../../Source/queue.c **** 
1359:../../Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
1360:../../Source/queue.c **** {
1361:../../Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1362:../../Source/queue.c **** 
1363:../../Source/queue.c **** 	configASSERT( xQueue );
1364:../../Source/queue.c **** 
1365:../../Source/queue.c **** 	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
1366:../../Source/queue.c **** 
1367:../../Source/queue.c **** 	return uxReturn;
1368:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1369:../../Source/queue.c **** /*-----------------------------------------------------------*/
1370:../../Source/queue.c **** 
1371:../../Source/queue.c **** void vQueueDelete( xQueueHandle xQueue )
1372:../../Source/queue.c **** {
1373:../../Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1374:../../Source/queue.c **** 
1375:../../Source/queue.c **** 	configASSERT( pxQueue );
1376:../../Source/queue.c **** 
1377:../../Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1378:../../Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1379:../../Source/queue.c **** 	{
1380:../../Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1381:../../Source/queue.c **** 	}
1382:../../Source/queue.c **** 	#endif
1383:../../Source/queue.c **** 	vPortFree( pxQueue->pcHead );
1384:../../Source/queue.c **** 	vPortFree( pxQueue );
1385:../../Source/queue.c **** }
1386:../../Source/queue.c **** /*-----------------------------------------------------------*/
1387:../../Source/queue.c **** 
1388:../../Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1389:../../Source/queue.c **** 
1390:../../Source/queue.c **** 	unsigned char ucQueueGetQueueNumber( xQueueHandle xQueue )
1391:../../Source/queue.c **** 	{
1392:../../Source/queue.c **** 		return ( ( xQUEUE * ) xQueue )->ucQueueNumber;
1393:../../Source/queue.c **** 	}
1394:../../Source/queue.c **** 
1395:../../Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1396:../../Source/queue.c **** /*-----------------------------------------------------------*/
1397:../../Source/queue.c **** 
1398:../../Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1399:../../Source/queue.c **** 
1400:../../Source/queue.c **** 	void vQueueSetQueueNumber( xQueueHandle xQueue, unsigned char ucQueueNumber )
1401:../../Source/queue.c **** 	{
1402:../../Source/queue.c **** 		( ( xQUEUE * ) xQueue )->ucQueueNumber = ucQueueNumber;
1403:../../Source/queue.c **** 	}
1404:../../Source/queue.c **** 
1405:../../Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1406:../../Source/queue.c **** /*-----------------------------------------------------------*/
1407:../../Source/queue.c **** 
1408:../../Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1409:../../Source/queue.c **** 
1410:../../Source/queue.c **** 	unsigned char ucQueueGetQueueType( xQueueHandle xQueue )
1411:../../Source/queue.c **** 	{
1412:../../Source/queue.c **** 		return ( ( xQUEUE * ) xQueue )->ucQueueType;
1413:../../Source/queue.c **** 	}
1414:../../Source/queue.c **** 
1415:../../Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1416:../../Source/queue.c **** /*-----------------------------------------------------------*/
1417:../../Source/queue.c **** 
1418:../../Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1419:../../Source/queue.c **** {
 138               	.LM0:
 139               	.LFBB1:
 140 0000 1F93      		push r17
 141 0002 CF93      		push r28
 142 0004 DF93      		push r29
 143               	/* prologue: function */
 144               	/* frame size = 0 */
 145               	/* stack size = 3 */
 146               	.L__stack_usage = 3
 147 0006 EC01      		movw r28,r24
 148 0008 142F      		mov r17,r20
1420:../../Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 150               	.LM1:
 151 000a 4C8D      		ldd r20,Y+28
 152 000c 4423      		tst r20
 153 000e 01F0      		breq .L3
1421:../../Source/queue.c **** 	{
1422:../../Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1423:../../Source/queue.c **** 		{
1424:../../Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1425:../../Source/queue.c **** 			{
1426:../../Source/queue.c **** 				/* The mutex is no longer being held. */
1427:../../Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
1428:../../Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
1429:../../Source/queue.c **** 			}
1430:../../Source/queue.c **** 		}
1431:../../Source/queue.c **** 		#endif /* configUSE_MUTEXES */
1432:../../Source/queue.c **** 	}
1433:../../Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
1434:../../Source/queue.c **** 	{
1435:../../Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 155               	.LM2:
 156 0010 50E0      		ldi r21,0
1433:../../Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 158               	.LM3:
 159 0012 1111      		cpse r17,__zero_reg__
 160 0014 00C0      		rjmp .L4
 162               	.LM4:
 163 0016 8C81      		ldd r24,Y+4
 164 0018 9D81      		ldd r25,Y+5
 165 001a 0E94 0000 		call memcpy
1436:../../Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 167               	.LM5:
 168 001e 2C8D      		ldd r18,Y+28
 169 0020 8C81      		ldd r24,Y+4
 170 0022 9D81      		ldd r25,Y+5
 171 0024 820F      		add r24,r18
 172 0026 911D      		adc r25,__zero_reg__
 173 0028 9D83      		std Y+5,r25
 174 002a 8C83      		std Y+4,r24
1437:../../Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 176               	.LM6:
 177 002c 2A81      		ldd r18,Y+2
 178 002e 3B81      		ldd r19,Y+3
 179 0030 8217      		cp r24,r18
 180 0032 9307      		cpc r25,r19
 181 0034 00F0      		brlo .L3
1438:../../Source/queue.c **** 		{
1439:../../Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 183               	.LM7:
 184 0036 8881      		ld r24,Y
 185 0038 9981      		ldd r25,Y+1
 186 003a 9D83      		std Y+5,r25
 187 003c 8C83      		std Y+4,r24
 188 003e 00C0      		rjmp .L3
 189               	.L4:
1440:../../Source/queue.c **** 		}
1441:../../Source/queue.c **** 	}
1442:../../Source/queue.c **** 	else
1443:../../Source/queue.c **** 	{
1444:../../Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 191               	.LM8:
 192 0040 8E81      		ldd r24,Y+6
 193 0042 9F81      		ldd r25,Y+7
 194 0044 0E94 0000 		call memcpy
1445:../../Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 196               	.LM9:
 197 0048 2C8D      		ldd r18,Y+28
 198 004a 30E0      		ldi r19,0
 199 004c 3195      		neg r19
 200 004e 2195      		neg r18
 201 0050 3109      		sbc r19,__zero_reg__
 202 0052 8E81      		ldd r24,Y+6
 203 0054 9F81      		ldd r25,Y+7
 204 0056 820F      		add r24,r18
 205 0058 931F      		adc r25,r19
 206 005a 9F83      		std Y+7,r25
 207 005c 8E83      		std Y+6,r24
1446:../../Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 209               	.LM10:
 210 005e 6881      		ld r22,Y
 211 0060 7981      		ldd r23,Y+1
 212 0062 8617      		cp r24,r22
 213 0064 9707      		cpc r25,r23
 214 0066 00F4      		brsh .L6
1447:../../Source/queue.c **** 		{
1448:../../Source/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 216               	.LM11:
 217 0068 8A81      		ldd r24,Y+2
 218 006a 9B81      		ldd r25,Y+3
 219 006c 820F      		add r24,r18
 220 006e 931F      		adc r25,r19
 221 0070 9F83      		std Y+7,r25
 222 0072 8E83      		std Y+6,r24
 223               	.L6:
1449:../../Source/queue.c **** 		}
1450:../../Source/queue.c **** 
1451:../../Source/queue.c **** 		if( xPosition == queueOVERWRITE )
 225               	.LM12:
 226 0074 1230      		cpi r17,lo8(2)
 227 0076 01F4      		brne .L3
1452:../../Source/queue.c **** 		{
1453:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 229               	.LM13:
 230 0078 8A8D      		ldd r24,Y+26
 231 007a 8823      		tst r24
 232 007c 01F0      		breq .L3
1454:../../Source/queue.c **** 			{
1455:../../Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
1456:../../Source/queue.c **** 				one from the recorded number of items in the queue so when
1457:../../Source/queue.c **** 				one is added again below the number of recorded items remains
1458:../../Source/queue.c **** 				correct. */
1459:../../Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 234               	.LM14:
 235 007e 8A8D      		ldd r24,Y+26
 236 0080 8150      		subi r24,lo8(-(-1))
 237 0082 8A8F      		std Y+26,r24
 238               	.L3:
1460:../../Source/queue.c **** 			}
1461:../../Source/queue.c **** 		}
1462:../../Source/queue.c **** 	}
1463:../../Source/queue.c **** 
1464:../../Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 240               	.LM15:
 241 0084 8A8D      		ldd r24,Y+26
 242 0086 8F5F      		subi r24,lo8(-(1))
 243 0088 8A8F      		std Y+26,r24
 244               	/* epilogue start */
1465:../../Source/queue.c **** }
 246               	.LM16:
 247 008a DF91      		pop r29
 248 008c CF91      		pop r28
 249 008e 1F91      		pop r17
 250 0090 0895      		ret
 252               	.Lscope1:
 254               		.stabd	78,0,0
 258               	prvCopyDataFromQueue:
 259               		.stabd	46,0,0
1466:../../Source/queue.c **** /*-----------------------------------------------------------*/
1467:../../Source/queue.c **** 
1468:../../Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
1469:../../Source/queue.c **** {
 261               	.LM17:
 262               	.LFBB2:
 263 0092 CF93      		push r28
 264 0094 DF93      		push r29
 265               	/* prologue: function */
 266               	/* frame size = 0 */
 267               	/* stack size = 2 */
 268               	.L__stack_usage = 2
 269 0096 FC01      		movw r30,r24
 270 0098 CB01      		movw r24,r22
1470:../../Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 272               	.LM18:
 273 009a A081      		ld r26,Z
 274 009c B181      		ldd r27,Z+1
 275 009e 1097      		sbiw r26,0
 276 00a0 01F0      		breq .L10
1471:../../Source/queue.c **** 	{
1472:../../Source/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 278               	.LM19:
 279 00a2 448D      		ldd r20,Z+28
 280 00a4 2681      		ldd r18,Z+6
 281 00a6 3781      		ldd r19,Z+7
 282 00a8 240F      		add r18,r20
 283 00aa 311D      		adc r19,__zero_reg__
 284 00ac 3783      		std Z+7,r19
 285 00ae 2683      		std Z+6,r18
1473:../../Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 287               	.LM20:
 288 00b0 C281      		ldd r28,Z+2
 289 00b2 D381      		ldd r29,Z+3
 290 00b4 2C17      		cp r18,r28
 291 00b6 3D07      		cpc r19,r29
 292 00b8 00F0      		brlo .L12
1474:../../Source/queue.c **** 		{
1475:../../Source/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 294               	.LM21:
 295 00ba B783      		std Z+7,r27
 296 00bc A683      		std Z+6,r26
 297               	.L12:
1476:../../Source/queue.c **** 		}
1477:../../Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 299               	.LM22:
 300 00be 6681      		ldd r22,Z+6
 301 00c0 7781      		ldd r23,Z+7
 302 00c2 50E0      		ldi r21,0
 303               	/* epilogue start */
1478:../../Source/queue.c **** 	}
1479:../../Source/queue.c **** }
 305               	.LM23:
 306 00c4 DF91      		pop r29
 307 00c6 CF91      		pop r28
1477:../../Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 309               	.LM24:
 310 00c8 0C94 0000 		jmp memcpy
 311               	.L10:
 312               	/* epilogue start */
 314               	.LM25:
 315 00cc DF91      		pop r29
 316 00ce CF91      		pop r28
 317 00d0 0895      		ret
 319               	.Lscope2:
 321               		.stabd	78,0,0
 325               	prvUnlockQueue:
 326               		.stabd	46,0,0
1480:../../Source/queue.c **** /*-----------------------------------------------------------*/
1481:../../Source/queue.c **** 
1482:../../Source/queue.c **** static void prvUnlockQueue( xQUEUE *pxQueue )
1483:../../Source/queue.c **** {
 328               	.LM26:
 329               	.LFBB3:
 330 00d2 0F93      		push r16
 331 00d4 1F93      		push r17
 332 00d6 CF93      		push r28
 333 00d8 DF93      		push r29
 334               	/* prologue: function */
 335               	/* frame size = 0 */
 336               	/* stack size = 4 */
 337               	.L__stack_usage = 4
 338 00da EC01      		movw r28,r24
1484:../../Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1485:../../Source/queue.c **** 
1486:../../Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1487:../../Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1488:../../Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1489:../../Source/queue.c **** 	updated. */
1490:../../Source/queue.c **** 	taskENTER_CRITICAL();
 340               	.LM27:
 341               	/* #APP */
 342               	 ;  1490 "../../Source/queue.c" 1
 343 00dc 0FB6      		in		__tmp_reg__, __SREG__
 344               	 ;  0 "" 2
 345               	 ;  1490 "../../Source/queue.c" 1
 346 00de F894      		cli
 347               	 ;  0 "" 2
 348               	 ;  1490 "../../Source/queue.c" 1
 349 00e0 0F92      		push	__tmp_reg__
 350               	 ;  0 "" 2
1491:../../Source/queue.c **** 	{
1492:../../Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1493:../../Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
1494:../../Source/queue.c **** 		{
1495:../../Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1496:../../Source/queue.c **** 			blocked waiting for data to become available? */
1497:../../Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1498:../../Source/queue.c **** 			{
1499:../../Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1500:../../Source/queue.c **** 				{
1501:../../Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1502:../../Source/queue.c **** 					{
1503:../../Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
1504:../../Source/queue.c **** 						the queue set caused a higher priority task to unblock.
1505:../../Source/queue.c **** 						A context switch is required. */
1506:../../Source/queue.c **** 						vTaskMissedYield();
1507:../../Source/queue.c **** 					}
1508:../../Source/queue.c **** 				}
1509:../../Source/queue.c **** 				else
1510:../../Source/queue.c **** 				{
1511:../../Source/queue.c **** 					/* Tasks that are removed from the event list will get added to
1512:../../Source/queue.c **** 					the pending ready list as the scheduler is still suspended. */
1513:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1514:../../Source/queue.c **** 					{
1515:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1516:../../Source/queue.c **** 						{
1517:../../Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1518:../../Source/queue.c **** 							context	switch is required. */
1519:../../Source/queue.c **** 							vTaskMissedYield();
1520:../../Source/queue.c **** 						}
1521:../../Source/queue.c **** 					}
1522:../../Source/queue.c **** 					else
1523:../../Source/queue.c **** 					{
1524:../../Source/queue.c **** 						break;
1525:../../Source/queue.c **** 					}
1526:../../Source/queue.c **** 				}
1527:../../Source/queue.c **** 			}
1528:../../Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1529:../../Source/queue.c **** 			{
1530:../../Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1531:../../Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1532:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1533:../../Source/queue.c **** 				{
1534:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 352               	.LM28:
 353               	/* #NOAPP */
 354 00e2 8C01      		movw r16,r24
 355 00e4 0F5E      		subi r16,-17
 356 00e6 1F4F      		sbci r17,-1
1493:../../Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 358               	.LM29:
 359 00e8 00C0      		rjmp .L14
 360               	.L17:
1532:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 362               	.LM30:
 363 00ea 8989      		ldd r24,Y+17
 364 00ec 8823      		tst r24
 365 00ee 01F0      		breq .L15
 367               	.LM31:
 368 00f0 C801      		movw r24,r16
 369 00f2 0E94 0000 		call xTaskRemoveFromEventList
 370 00f6 8111      		cpse r24,__zero_reg__
1535:../../Source/queue.c **** 					{
1536:../../Source/queue.c **** 						/* The task waiting has a higher priority so record that a
1537:../../Source/queue.c **** 						context	switch is required. */
1538:../../Source/queue.c **** 						vTaskMissedYield();
 372               	.LM32:
 373 00f8 0E94 0000 		call vTaskMissedYield
 374               	.L16:
1539:../../Source/queue.c **** 					}
1540:../../Source/queue.c **** 				}
1541:../../Source/queue.c **** 				else
1542:../../Source/queue.c **** 				{
1543:../../Source/queue.c **** 					break;
1544:../../Source/queue.c **** 				}
1545:../../Source/queue.c **** 			}
1546:../../Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1547:../../Source/queue.c **** 
1548:../../Source/queue.c **** 			--( pxQueue->xTxLock );
 376               	.LM33:
 377 00fc 8E8D      		ldd r24,Y+30
 378 00fe 8150      		subi r24,lo8(-(-1))
 379 0100 8E8F      		std Y+30,r24
 380               	.L14:
1493:../../Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 382               	.LM34:
 383 0102 8E8D      		ldd r24,Y+30
 384 0104 1816      		cp __zero_reg__,r24
 385 0106 04F0      		brlt .L17
 386               	.L15:
1549:../../Source/queue.c **** 		}
1550:../../Source/queue.c **** 
1551:../../Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 388               	.LM35:
 389 0108 8FEF      		ldi r24,lo8(-1)
 390 010a 8E8F      		std Y+30,r24
1552:../../Source/queue.c **** 	}
1553:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 392               	.LM36:
 393               	/* #APP */
 394               	 ;  1553 "../../Source/queue.c" 1
 395 010c 0F90      		pop		__tmp_reg__
 396               	 ;  0 "" 2
 397               	 ;  1553 "../../Source/queue.c" 1
 398 010e 0FBE      		out		__SREG__, __tmp_reg__
 399               	 ;  0 "" 2
1554:../../Source/queue.c **** 
1555:../../Source/queue.c **** 	/* Do the same for the Rx lock. */
1556:../../Source/queue.c **** 	taskENTER_CRITICAL();
 401               	.LM37:
 402               	 ;  1556 "../../Source/queue.c" 1
 403 0110 0FB6      		in		__tmp_reg__, __SREG__
 404               	 ;  0 "" 2
 405               	 ;  1556 "../../Source/queue.c" 1
 406 0112 F894      		cli
 407               	 ;  0 "" 2
 408               	 ;  1556 "../../Source/queue.c" 1
 409 0114 0F92      		push	__tmp_reg__
 410               	 ;  0 "" 2
1557:../../Source/queue.c **** 	{
1558:../../Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
1559:../../Source/queue.c **** 		{
1560:../../Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1561:../../Source/queue.c **** 			{
1562:../../Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 412               	.LM38:
 413               	/* #NOAPP */
 414 0116 8E01      		movw r16,r28
 415 0118 085F      		subi r16,-8
 416 011a 1F4F      		sbci r17,-1
1558:../../Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 418               	.LM39:
 419 011c 00C0      		rjmp .L18
 420               	.L21:
1560:../../Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 422               	.LM40:
 423 011e 8885      		ldd r24,Y+8
 424 0120 8823      		tst r24
 425 0122 01F0      		breq .L19
 427               	.LM41:
 428 0124 C801      		movw r24,r16
 429 0126 0E94 0000 		call xTaskRemoveFromEventList
 430 012a 8111      		cpse r24,__zero_reg__
1563:../../Source/queue.c **** 				{
1564:../../Source/queue.c **** 					vTaskMissedYield();
 432               	.LM42:
 433 012c 0E94 0000 		call vTaskMissedYield
 434               	.L20:
1565:../../Source/queue.c **** 				}
1566:../../Source/queue.c **** 
1567:../../Source/queue.c **** 				--( pxQueue->xRxLock );
 436               	.LM43:
 437 0130 8D8D      		ldd r24,Y+29
 438 0132 8150      		subi r24,lo8(-(-1))
 439 0134 8D8F      		std Y+29,r24
 440               	.L18:
1558:../../Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 442               	.LM44:
 443 0136 8D8D      		ldd r24,Y+29
 444 0138 1816      		cp __zero_reg__,r24
 445 013a 04F0      		brlt .L21
 446               	.L19:
1568:../../Source/queue.c **** 			}
1569:../../Source/queue.c **** 			else
1570:../../Source/queue.c **** 			{
1571:../../Source/queue.c **** 				break;
1572:../../Source/queue.c **** 			}
1573:../../Source/queue.c **** 		}
1574:../../Source/queue.c **** 
1575:../../Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 448               	.LM45:
 449 013c 8FEF      		ldi r24,lo8(-1)
 450 013e 8D8F      		std Y+29,r24
1576:../../Source/queue.c **** 	}
1577:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 452               	.LM46:
 453               	/* #APP */
 454               	 ;  1577 "../../Source/queue.c" 1
 455 0140 0F90      		pop		__tmp_reg__
 456               	 ;  0 "" 2
 457               	 ;  1577 "../../Source/queue.c" 1
 458 0142 0FBE      		out		__SREG__, __tmp_reg__
 459               	 ;  0 "" 2
 460               	/* epilogue start */
1578:../../Source/queue.c **** }
 462               	.LM47:
 463               	/* #NOAPP */
 464 0144 DF91      		pop r29
 465 0146 CF91      		pop r28
 466 0148 1F91      		pop r17
 467 014a 0F91      		pop r16
 468 014c 0895      		ret
 470               	.Lscope3:
 472               		.stabd	78,0,0
 476               	.global	xQueueGenericReset
 478               	xQueueGenericReset:
 479               		.stabd	46,0,0
 247:../../Source/queue.c **** {
 481               	.LM48:
 482               	.LFBB4:
 483 014e CF93      		push r28
 484 0150 DF93      		push r29
 485               	/* prologue: function */
 486               	/* frame size = 0 */
 487               	/* stack size = 2 */
 488               	.L__stack_usage = 2
 489 0152 EC01      		movw r28,r24
 252:../../Source/queue.c **** 	taskENTER_CRITICAL();
 491               	.LM49:
 492               	/* #APP */
 493               	 ;  252 "../../Source/queue.c" 1
 494 0154 0FB6      		in		__tmp_reg__, __SREG__
 495               	 ;  0 "" 2
 496               	 ;  252 "../../Source/queue.c" 1
 497 0156 F894      		cli
 498               	 ;  0 "" 2
 499               	 ;  252 "../../Source/queue.c" 1
 500 0158 0F92      		push	__tmp_reg__
 501               	 ;  0 "" 2
 254:../../Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 503               	.LM50:
 504               	/* #NOAPP */
 505 015a 2881      		ld r18,Y
 506 015c 3981      		ldd r19,Y+1
 507 015e 4B8D      		ldd r20,Y+27
 508 0160 7C8D      		ldd r23,Y+28
 509 0162 C901      		movw r24,r18
 510 0164 479F      		mul r20,r23
 511 0166 800D      		add r24,r0
 512 0168 911D      		adc r25,r1
 513 016a 1124      		clr __zero_reg__
 514 016c 9B83      		std Y+3,r25
 515 016e 8A83      		std Y+2,r24
 255:../../Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 517               	.LM51:
 518 0170 1A8E      		std Y+26,__zero_reg__
 256:../../Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 520               	.LM52:
 521 0172 3D83      		std Y+5,r19
 522 0174 2C83      		std Y+4,r18
 254:../../Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 524               	.LM53:
 525 0176 50E0      		ldi r21,0
 257:../../Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U )
 527               	.LM54:
 528 0178 4150      		subi r20,1
 529 017a 5109      		sbc r21,__zero_reg__
 530 017c 749F      		mul r23,r20
 531 017e C001      		movw r24,r0
 532 0180 759F      		mul r23,r21
 533 0182 900D      		add r25,r0
 534 0184 1124      		clr __zero_reg__
 535 0186 820F      		add r24,r18
 536 0188 931F      		adc r25,r19
 537 018a 9F83      		std Y+7,r25
 538 018c 8E83      		std Y+6,r24
 258:../../Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 540               	.LM55:
 541 018e 8FEF      		ldi r24,lo8(-1)
 542 0190 8D8F      		std Y+29,r24
 259:../../Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 544               	.LM56:
 545 0192 8E8F      		std Y+30,r24
 261:../../Source/queue.c **** 		if( xNewQueue == pdFALSE )
 547               	.LM57:
 548 0194 6111      		cpse r22,__zero_reg__
 549 0196 00C0      		rjmp .L35
 268:../../Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 551               	.LM58:
 552 0198 8885      		ldd r24,Y+8
 553 019a 8823      		tst r24
 554 019c 01F0      		breq .L37
 270:../../Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 556               	.LM59:
 557 019e CE01      		movw r24,r28
 558 01a0 0896      		adiw r24,8
 559 01a2 0E94 0000 		call xTaskRemoveFromEventList
 560 01a6 8130      		cpi r24,lo8(1)
 561 01a8 01F4      		brne .L37
 272:../../Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 563               	.LM60:
 564 01aa 0E94 0000 		call vPortYield
 565 01ae 00C0      		rjmp .L37
 566               	.L35:
 279:../../Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 568               	.LM61:
 569 01b0 CE01      		movw r24,r28
 570 01b2 0896      		adiw r24,8
 571 01b4 0E94 0000 		call vListInitialise
 280:../../Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 573               	.LM62:
 574 01b8 CE01      		movw r24,r28
 575 01ba 4196      		adiw r24,17
 576 01bc 0E94 0000 		call vListInitialise
 577               	.L37:
 283:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 579               	.LM63:
 580               	/* #APP */
 581               	 ;  283 "../../Source/queue.c" 1
 582 01c0 0F90      		pop		__tmp_reg__
 583               	 ;  0 "" 2
 584               	 ;  283 "../../Source/queue.c" 1
 585 01c2 0FBE      		out		__SREG__, __tmp_reg__
 586               	 ;  0 "" 2
 288:../../Source/queue.c **** }
 588               	.LM64:
 589               	/* #NOAPP */
 590 01c4 81E0      		ldi r24,lo8(1)
 591               	/* epilogue start */
 592 01c6 DF91      		pop r29
 593 01c8 CF91      		pop r28
 594 01ca 0895      		ret
 596               	.Lscope4:
 598               		.stabd	78,0,0
 603               	.global	xQueueGenericCreate
 605               	xQueueGenericCreate:
 606               		.stabd	46,0,0
 292:../../Source/queue.c **** {
 608               	.LM65:
 609               	.LFBB5:
 610 01cc 0F93      		push r16
 611 01ce 1F93      		push r17
 612 01d0 CF93      		push r28
 613 01d2 DF93      		push r29
 614               	/* prologue: function */
 615               	/* frame size = 0 */
 616               	/* stack size = 4 */
 617               	.L__stack_usage = 4
 618 01d4 182F      		mov r17,r24
 619 01d6 062F      		mov r16,r22
 302:../../Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 621               	.LM66:
 622 01d8 8111      		cpse r24,__zero_reg__
 623 01da 00C0      		rjmp .L40
 624 01dc 00C0      		rjmp .L47
 625               	.L40:
 304:../../Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 627               	.LM67:
 628 01de 8FE1      		ldi r24,lo8(31)
 629 01e0 90E0      		ldi r25,0
 630 01e2 0E94 0000 		call pvPortMalloc
 631 01e6 EC01      		movw r28,r24
 305:../../Source/queue.c **** 		if( pxNewQueue != NULL )
 633               	.LM68:
 634 01e8 0097      		sbiw r24,0
 635 01ea 01F0      		breq .L47
 309:../../Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA
 637               	.LM69:
 638 01ec 109F      		mul r17,r16
 639 01ee C001      		movw r24,r0
 640 01f0 1124      		clr __zero_reg__
 311:../../Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 642               	.LM70:
 643 01f2 0196      		adiw r24,1
 644 01f4 0E94 0000 		call pvPortMalloc
 645 01f8 9983      		std Y+1,r25
 646 01fa 8883      		st Y,r24
 312:../../Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 648               	.LM71:
 649 01fc 892B      		or r24,r25
 650 01fe 01F0      		breq .L43
 316:../../Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 652               	.LM72:
 653 0200 1B8F      		std Y+27,r17
 317:../../Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 655               	.LM73:
 656 0202 0C8F      		std Y+28,r16
 318:../../Source/queue.c **** 				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 658               	.LM74:
 659 0204 61E0      		ldi r22,lo8(1)
 660 0206 CE01      		movw r24,r28
 661 0208 0E94 0000 		call xQueueGenericReset
 662 020c 00C0      		rjmp .L41
 663               	.L43:
 338:../../Source/queue.c **** 				vPortFree( pxNewQueue );
 665               	.LM75:
 666 020e CE01      		movw r24,r28
 667 0210 0E94 0000 		call vPortFree
 668               	.L47:
 295:../../Source/queue.c **** xQueueHandle xReturn = NULL;
 670               	.LM76:
 671 0214 C0E0      		ldi r28,0
 672 0216 D0E0      		ldi r29,0
 673               	.L41:
 346:../../Source/queue.c **** }
 675               	.LM77:
 676 0218 CE01      		movw r24,r28
 677               	/* epilogue start */
 678 021a DF91      		pop r29
 679 021c CF91      		pop r28
 680 021e 1F91      		pop r17
 681 0220 0F91      		pop r16
 682 0222 0895      		ret
 688               	.Lscope5:
 690               		.stabd	78,0,0
 696               	.global	xQueueGenericSend
 698               	xQueueGenericSend:
 699               		.stabd	46,0,0
 565:../../Source/queue.c **** {
 701               	.LM78:
 702               	.LFBB6:
 703 0224 BF92      		push r11
 704 0226 CF92      		push r12
 705 0228 DF92      		push r13
 706 022a EF92      		push r14
 707 022c FF92      		push r15
 708 022e 0F93      		push r16
 709 0230 1F93      		push r17
 710 0232 CF93      		push r28
 711 0234 DF93      		push r29
 712 0236 00D0      		rcall .
 713 0238 00D0      		rcall .
 714 023a 1F92      		push __zero_reg__
 715 023c CDB7      		in r28,__SP_L__
 716 023e DEB7      		in r29,__SP_H__
 717               	/* prologue: function */
 718               	/* frame size = 5 */
 719               	/* stack size = 14 */
 720               	.L__stack_usage = 14
 721 0240 8C01      		movw r16,r24
 722 0242 6B01      		movw r12,r22
 723 0244 5D83      		std Y+5,r21
 724 0246 4C83      		std Y+4,r20
 725 0248 B22E      		mov r11,r18
 566:../../Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 727               	.LM79:
 728 024a 20E0      		ldi r18,0
 683:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 730               	.LM80:
 731 024c 7C01      		movw r14,r24
 732 024e 88E0      		ldi r24,8
 733 0250 E80E      		add r14,r24
 734 0252 F11C      		adc r15,__zero_reg__
 735 0254 00C0      		rjmp .L49
 736               	.L62:
 737 0256 21E0      		ldi r18,lo8(1)
 738               	.L49:
 579:../../Source/queue.c **** 		taskENTER_CRITICAL();
 740               	.LM81:
 741               	/* #APP */
 742               	 ;  579 "../../Source/queue.c" 1
 743 0258 0FB6      		in		__tmp_reg__, __SREG__
 744               	 ;  0 "" 2
 745               	 ;  579 "../../Source/queue.c" 1
 746 025a F894      		cli
 747               	 ;  0 "" 2
 748               	 ;  579 "../../Source/queue.c" 1
 749 025c 0F92      		push	__tmp_reg__
 750               	 ;  0 "" 2
 585:../../Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 752               	.LM82:
 753               	/* #NOAPP */
 754 025e F801      		movw r30,r16
 755 0260 928D      		ldd r25,Z+26
 756 0262 838D      		ldd r24,Z+27
 757 0264 9817      		cp r25,r24
 758 0266 00F0      		brlo .L50
 585:../../Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 760               	.LM83:
 761 0268 F2E0      		ldi r31,lo8(2)
 762 026a BF12      		cpse r11,r31
 763 026c 00C0      		rjmp .L51
 764               	.L50:
 588:../../Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 766               	.LM84:
 767 026e 4B2D      		mov r20,r11
 768 0270 B601      		movw r22,r12
 769 0272 C801      		movw r24,r16
 770 0274 0E94 0000 		call prvCopyDataToQueue
 623:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 772               	.LM85:
 773 0278 F801      		movw r30,r16
 774 027a 8189      		ldd r24,Z+17
 775 027c 8823      		tst r24
 776 027e 01F0      		breq .L53
 625:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 778               	.LM86:
 779 0280 C801      		movw r24,r16
 780 0282 4196      		adiw r24,17
 781 0284 0E94 0000 		call xTaskRemoveFromEventList
 782 0288 8130      		cpi r24,lo8(1)
 783 028a 01F4      		brne .L53
 631:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 785               	.LM87:
 786 028c 0E94 0000 		call vPortYield
 787               	.L53:
 637:../../Source/queue.c **** 				taskEXIT_CRITICAL();
 789               	.LM88:
 790               	/* #APP */
 791               	 ;  637 "../../Source/queue.c" 1
 792 0290 0F90      		pop		__tmp_reg__
 793               	 ;  0 "" 2
 794               	 ;  637 "../../Source/queue.c" 1
 795 0292 0FBE      		out		__SREG__, __tmp_reg__
 796               	 ;  0 "" 2
 641:../../Source/queue.c **** 				return pdPASS;
 798               	.LM89:
 799               	/* #NOAPP */
 800 0294 81E0      		ldi r24,lo8(1)
 801 0296 00C0      		rjmp .L55
 802               	.L51:
 645:../../Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 804               	.LM90:
 805 0298 8C81      		ldd r24,Y+4
 806 029a 9D81      		ldd r25,Y+5
 807 029c 892B      		or r24,r25
 808 029e 01F4      		brne .L56
 649:../../Source/queue.c **** 					taskEXIT_CRITICAL();
 810               	.LM91:
 811               	/* #APP */
 812               	 ;  649 "../../Source/queue.c" 1
 813 02a0 0F90      		pop		__tmp_reg__
 814               	 ;  0 "" 2
 815               	 ;  649 "../../Source/queue.c" 1
 816 02a2 0FBE      		out		__SREG__, __tmp_reg__
 817               	 ;  0 "" 2
 818               	/* #NOAPP */
 819 02a4 00C0      		rjmp .L63
 820               	.L56:
 656:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 822               	.LM92:
 823 02a6 2111      		cpse r18,__zero_reg__
 824 02a8 00C0      		rjmp .L57
 660:../../Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 826               	.LM93:
 827 02aa CE01      		movw r24,r28
 828 02ac 0196      		adiw r24,1
 829 02ae 0E94 0000 		call vTaskSetTimeOutState
 830               	.L57:
 669:../../Source/queue.c **** 		taskEXIT_CRITICAL();
 832               	.LM94:
 833               	/* #APP */
 834               	 ;  669 "../../Source/queue.c" 1
 835 02b2 0F90      		pop		__tmp_reg__
 836               	 ;  0 "" 2
 837               	 ;  669 "../../Source/queue.c" 1
 838 02b4 0FBE      		out		__SREG__, __tmp_reg__
 839               	 ;  0 "" 2
 674:../../Source/queue.c **** 		vTaskSuspendAll();
 841               	.LM95:
 842               	/* #NOAPP */
 843 02b6 0E94 0000 		call vTaskSuspendAll
 675:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 845               	.LM96:
 846               	/* #APP */
 847               	 ;  675 "../../Source/queue.c" 1
 848 02ba 0FB6      		in		__tmp_reg__, __SREG__
 849               	 ;  0 "" 2
 850               	 ;  675 "../../Source/queue.c" 1
 851 02bc F894      		cli
 852               	 ;  0 "" 2
 853               	 ;  675 "../../Source/queue.c" 1
 854 02be 0F92      		push	__tmp_reg__
 855               	 ;  0 "" 2
 856               	/* #NOAPP */
 857 02c0 F801      		movw r30,r16
 858 02c2 858D      		ldd r24,Z+29
 859 02c4 8F3F      		cpi r24,lo8(-1)
 860 02c6 01F4      		brne .L58
 675:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 862               	.LM97:
 863 02c8 158E      		std Z+29,__zero_reg__
 864               	.L58:
 675:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 866               	.LM98:
 867 02ca F801      		movw r30,r16
 868 02cc 868D      		ldd r24,Z+30
 869 02ce 8F3F      		cpi r24,lo8(-1)
 870 02d0 01F4      		brne .L59
 675:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 872               	.LM99:
 873 02d2 168E      		std Z+30,__zero_reg__
 874               	.L59:
 675:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 876               	.LM100:
 877               	/* #APP */
 878               	 ;  675 "../../Source/queue.c" 1
 879 02d4 0F90      		pop		__tmp_reg__
 880               	 ;  0 "" 2
 881               	 ;  675 "../../Source/queue.c" 1
 882 02d6 0FBE      		out		__SREG__, __tmp_reg__
 883               	 ;  0 "" 2
 678:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 885               	.LM101:
 886               	/* #NOAPP */
 887 02d8 BE01      		movw r22,r28
 888 02da 6C5F      		subi r22,-4
 889 02dc 7F4F      		sbci r23,-1
 890 02de CE01      		movw r24,r28
 891 02e0 0196      		adiw r24,1
 892 02e2 0E94 0000 		call xTaskCheckForTimeOut
 893 02e6 8111      		cpse r24,__zero_reg__
 894 02e8 00C0      		rjmp .L60
 895               	.LBB4:
 896               	.LBB5:
1579:../../Source/queue.c **** /*-----------------------------------------------------------*/
1580:../../Source/queue.c **** 
1581:../../Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
1582:../../Source/queue.c **** {
1583:../../Source/queue.c **** signed portBASE_TYPE xReturn;
1584:../../Source/queue.c **** 
1585:../../Source/queue.c **** 	taskENTER_CRITICAL();
1586:../../Source/queue.c **** 	{
1587:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
1588:../../Source/queue.c **** 		{
1589:../../Source/queue.c **** 			xReturn = pdTRUE;
1590:../../Source/queue.c **** 		}
1591:../../Source/queue.c **** 		else
1592:../../Source/queue.c **** 		{
1593:../../Source/queue.c **** 			xReturn = pdFALSE;
1594:../../Source/queue.c **** 		}
1595:../../Source/queue.c **** 	}
1596:../../Source/queue.c **** 	taskEXIT_CRITICAL();
1597:../../Source/queue.c **** 
1598:../../Source/queue.c **** 	return xReturn;
1599:../../Source/queue.c **** }
1600:../../Source/queue.c **** /*-----------------------------------------------------------*/
1601:../../Source/queue.c **** 
1602:../../Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
1603:../../Source/queue.c **** {
1604:../../Source/queue.c **** signed portBASE_TYPE xReturn;
1605:../../Source/queue.c **** 
1606:../../Source/queue.c **** 	configASSERT( xQueue );
1607:../../Source/queue.c **** 	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1608:../../Source/queue.c **** 	{
1609:../../Source/queue.c **** 		xReturn = pdTRUE;
1610:../../Source/queue.c **** 	}
1611:../../Source/queue.c **** 	else
1612:../../Source/queue.c **** 	{
1613:../../Source/queue.c **** 		xReturn = pdFALSE;
1614:../../Source/queue.c **** 	}
1615:../../Source/queue.c **** 
1616:../../Source/queue.c **** 	return xReturn;
1617:../../Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
1618:../../Source/queue.c **** /*-----------------------------------------------------------*/
1619:../../Source/queue.c **** 
1620:../../Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
1621:../../Source/queue.c **** {
1622:../../Source/queue.c **** signed portBASE_TYPE xReturn;
1623:../../Source/queue.c **** 
1624:../../Source/queue.c **** 	taskENTER_CRITICAL();
 898               	.LM102:
 899               	/* #APP */
 900               	 ;  1624 "../../Source/queue.c" 1
 901 02ea 0FB6      		in		__tmp_reg__, __SREG__
 902               	 ;  0 "" 2
 903               	 ;  1624 "../../Source/queue.c" 1
 904 02ec F894      		cli
 905               	 ;  0 "" 2
 906               	 ;  1624 "../../Source/queue.c" 1
 907 02ee 0F92      		push	__tmp_reg__
 908               	 ;  0 "" 2
1625:../../Source/queue.c **** 	{
1626:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 910               	.LM103:
 911               	/* #NOAPP */
 912 02f0 F801      		movw r30,r16
 913 02f2 928D      		ldd r25,Z+26
1627:../../Source/queue.c **** 		{
1628:../../Source/queue.c **** 			xReturn = pdTRUE;
1629:../../Source/queue.c **** 		}
1630:../../Source/queue.c **** 		else
1631:../../Source/queue.c **** 		{
1632:../../Source/queue.c **** 			xReturn = pdFALSE;
1633:../../Source/queue.c **** 		}
1634:../../Source/queue.c **** 	}
1635:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 915               	.LM104:
 916               	/* #APP */
 917               	 ;  1635 "../../Source/queue.c" 1
 918 02f4 0F90      		pop		__tmp_reg__
 919               	 ;  0 "" 2
 920               	 ;  1635 "../../Source/queue.c" 1
 921 02f6 0FBE      		out		__SREG__, __tmp_reg__
 922               	 ;  0 "" 2
 923               	/* #NOAPP */
 924               	.LBE5:
 925               	.LBE4:
 680:../../Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 927               	.LM105:
 928 02f8 F801      		movw r30,r16
 929 02fa 838D      		ldd r24,Z+27
 930 02fc 9813      		cpse r25,r24
 931 02fe 00C0      		rjmp .L61
 683:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 933               	.LM106:
 934 0300 6C81      		ldd r22,Y+4
 935 0302 7D81      		ldd r23,Y+5
 936 0304 C701      		movw r24,r14
 937 0306 0E94 0000 		call vTaskPlaceOnEventList
 690:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 939               	.LM107:
 940 030a C801      		movw r24,r16
 941 030c 0E94 0000 		call prvUnlockQueue
 697:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 943               	.LM108:
 944 0310 0E94 0000 		call xTaskResumeAll
 945 0314 8111      		cpse r24,__zero_reg__
 946 0316 00C0      		rjmp .L62
 699:../../Source/queue.c **** 					portYIELD_WITHIN_API();
 948               	.LM109:
 949 0318 0E94 0000 		call vPortYield
 950 031c 00C0      		rjmp .L62
 951               	.L61:
 705:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 953               	.LM110:
 954 031e C801      		movw r24,r16
 955 0320 0E94 0000 		call prvUnlockQueue
 706:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 957               	.LM111:
 958 0324 0E94 0000 		call xTaskResumeAll
 959 0328 00C0      		rjmp .L62
 960               	.L60:
 712:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
 962               	.LM112:
 963 032a C801      		movw r24,r16
 964 032c 0E94 0000 		call prvUnlockQueue
 713:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 966               	.LM113:
 967 0330 0E94 0000 		call xTaskResumeAll
 968               	.L63:
 718:../../Source/queue.c **** 			return errQUEUE_FULL;
 970               	.LM114:
 971 0334 80E0      		ldi r24,0
 972               	.L55:
 973               	/* epilogue start */
 721:../../Source/queue.c **** }
 975               	.LM115:
 976 0336 0F90      		pop __tmp_reg__
 977 0338 0F90      		pop __tmp_reg__
 978 033a 0F90      		pop __tmp_reg__
 979 033c 0F90      		pop __tmp_reg__
 980 033e 0F90      		pop __tmp_reg__
 981 0340 DF91      		pop r29
 982 0342 CF91      		pop r28
 983 0344 1F91      		pop r17
 984 0346 0F91      		pop r16
 985 0348 FF90      		pop r15
 986 034a EF90      		pop r14
 987 034c DF90      		pop r13
 988 034e CF90      		pop r12
 989 0350 BF90      		pop r11
 990 0352 0895      		ret
 996               	.Lscope6:
 998               		.stabd	78,0,0
 1004               	.global	xQueueGenericSendFromISR
 1006               	xQueueGenericSendFromISR:
 1007               		.stabd	46,0,0
 935:../../Source/queue.c **** {
 1009               	.LM116:
 1010               	.LFBB7:
 1011 0354 0F93      		push r16
 1012 0356 1F93      		push r17
 1013 0358 CF93      		push r28
 1014 035a DF93      		push r29
 1015               	/* prologue: function */
 1016               	/* frame size = 0 */
 1017               	/* stack size = 4 */
 1018               	.L__stack_usage = 4
 1019 035c EC01      		movw r28,r24
 1020 035e 8A01      		movw r16,r20
 967:../../Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1022               	.LM117:
 1023 0360 9A8D      		ldd r25,Y+26
 1024 0362 8B8D      		ldd r24,Y+27
 1025 0364 9817      		cp r25,r24
 1026 0366 00F0      		brlo .L65
 967:../../Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1028               	.LM118:
 1029 0368 2230      		cpi r18,lo8(2)
 1030 036a 01F4      		brne .L70
 1031               	.L65:
 971:../../Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1033               	.LM119:
 1034 036c 422F      		mov r20,r18
 1035 036e CE01      		movw r24,r28
 1036 0370 0E94 0000 		call prvCopyDataToQueue
 975:../../Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 1038               	.LM120:
 1039 0374 8E8D      		ldd r24,Y+30
 1040 0376 8F3F      		cpi r24,lo8(-1)
 1041 0378 01F4      		brne .L67
1010:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1043               	.LM121:
 1044 037a 8989      		ldd r24,Y+17
 1045 037c 8111      		cpse r24,__zero_reg__
 1046 037e 00C0      		rjmp .L68
 1047 0380 00C0      		rjmp .L77
 1048               	.L68:
1012:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1050               	.LM122:
 1051 0382 CE01      		movw r24,r28
 1052 0384 4196      		adiw r24,17
 1053 0386 0E94 0000 		call xTaskRemoveFromEventList
 1054 038a 8823      		tst r24
 1055 038c 01F0      		breq .L77
1016:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1057               	.LM123:
 1058 038e 0115      		cp r16,__zero_reg__
 1059 0390 1105      		cpc r17,__zero_reg__
 1060 0392 01F0      		breq .L77
1018:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1062               	.LM124:
 1063 0394 81E0      		ldi r24,lo8(1)
 1064 0396 F801      		movw r30,r16
 1065 0398 8083      		st Z,r24
 1066 039a 00C0      		rjmp .L66
 1067               	.L67:
1029:../../Source/queue.c **** 				++( pxQueue->xTxLock );
 1069               	.LM125:
 1070 039c 8E8D      		ldd r24,Y+30
 1071 039e 8F5F      		subi r24,lo8(-(1))
 1072 03a0 8E8F      		std Y+30,r24
 1073               	.L77:
1032:../../Source/queue.c **** 			xReturn = pdPASS;
 1075               	.LM126:
 1076 03a2 81E0      		ldi r24,lo8(1)
 1077 03a4 00C0      		rjmp .L66
 1078               	.L70:
1037:../../Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1080               	.LM127:
 1081 03a6 80E0      		ldi r24,0
 1082               	.L66:
 1083               	/* epilogue start */
1043:../../Source/queue.c **** }
 1085               	.LM128:
 1086 03a8 DF91      		pop r29
 1087 03aa CF91      		pop r28
 1088 03ac 1F91      		pop r17
 1089 03ae 0F91      		pop r16
 1090 03b0 0895      		ret
 1095               	.Lscope7:
 1097               		.stabd	78,0,0
 1103               	.global	xQueueGenericReceive
 1105               	xQueueGenericReceive:
 1106               		.stabd	46,0,0
1047:../../Source/queue.c **** {
 1108               	.LM129:
 1109               	.LFBB8:
 1110 03b2 BF92      		push r11
 1111 03b4 CF92      		push r12
 1112 03b6 DF92      		push r13
 1113 03b8 EF92      		push r14
 1114 03ba FF92      		push r15
 1115 03bc 0F93      		push r16
 1116 03be 1F93      		push r17
 1117 03c0 CF93      		push r28
 1118 03c2 DF93      		push r29
 1119 03c4 00D0      		rcall .
 1120 03c6 00D0      		rcall .
 1121 03c8 1F92      		push __zero_reg__
 1122 03ca CDB7      		in r28,__SP_L__
 1123 03cc DEB7      		in r29,__SP_H__
 1124               	/* prologue: function */
 1125               	/* frame size = 5 */
 1126               	/* stack size = 14 */
 1127               	.L__stack_usage = 14
 1128 03ce 8C01      		movw r16,r24
 1129 03d0 6B01      		movw r12,r22
 1130 03d2 5D83      		std Y+5,r21
 1131 03d4 4C83      		std Y+4,r20
 1132 03d6 B22E      		mov r11,r18
1048:../../Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 1134               	.LM130:
 1135 03d8 30E0      		ldi r19,0
1176:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1137               	.LM131:
 1138 03da 7C01      		movw r14,r24
 1139 03dc 81E1      		ldi r24,17
 1140 03de E80E      		add r14,r24
 1141 03e0 F11C      		adc r15,__zero_reg__
 1142 03e2 00C0      		rjmp .L79
 1143               	.L93:
 1144 03e4 31E0      		ldi r19,lo8(1)
 1145               	.L79:
1062:../../Source/queue.c **** 		taskENTER_CRITICAL();
 1147               	.LM132:
 1148               	/* #APP */
 1149               	 ;  1062 "../../Source/queue.c" 1
 1150 03e6 0FB6      		in		__tmp_reg__, __SREG__
 1151               	 ;  0 "" 2
 1152               	 ;  1062 "../../Source/queue.c" 1
 1153 03e8 F894      		cli
 1154               	 ;  0 "" 2
 1155               	 ;  1062 "../../Source/queue.c" 1
 1156 03ea 0F92      		push	__tmp_reg__
 1157               	 ;  0 "" 2
1066:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1159               	.LM133:
 1160               	/* #NOAPP */
 1161 03ec F801      		movw r30,r16
 1162 03ee 828D      		ldd r24,Z+26
 1163 03f0 8823      		tst r24
 1164 03f2 01F0      		breq .L80
1070:../../Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1166               	.LM134:
 1167 03f4 E680      		ldd r14,Z+6
 1168 03f6 F780      		ldd r15,Z+7
1072:../../Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1170               	.LM135:
 1171 03f8 B601      		movw r22,r12
 1172 03fa C801      		movw r24,r16
 1173 03fc 0E94 0000 		call prvCopyDataFromQueue
1079:../../Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1175               	.LM136:
 1176 0400 F801      		movw r30,r16
1074:../../Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 1178               	.LM137:
 1179 0402 B110      		cpse r11,__zero_reg__
 1180 0404 00C0      		rjmp .L81
1079:../../Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1182               	.LM138:
 1183 0406 828D      		ldd r24,Z+26
 1184 0408 8150      		subi r24,lo8(-(-1))
 1185 040a 828F      		std Z+26,r24
1092:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1187               	.LM139:
 1188 040c 8085      		ldd r24,Z+8
 1189 040e 8823      		tst r24
 1190 0410 01F0      		breq .L83
1094:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 1192               	.LM140:
 1193 0412 C801      		movw r24,r16
 1194 0414 0896      		adiw r24,8
 1195 0416 0E94 0000 		call xTaskRemoveFromEventList
 1196 041a 8130      		cpi r24,lo8(1)
 1197 041c 01F4      		brne .L83
 1198               	.L85:
1096:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1200               	.LM141:
 1201 041e 0E94 0000 		call vPortYield
 1202 0422 00C0      		rjmp .L83
 1203               	.L81:
1106:../../Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1205               	.LM142:
 1206 0424 F782      		std Z+7,r15
 1207 0426 E682      		std Z+6,r14
1110:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1209               	.LM143:
 1210 0428 8189      		ldd r24,Z+17
 1211 042a 8823      		tst r24
 1212 042c 01F0      		breq .L83
1114:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1214               	.LM144:
 1215 042e C801      		movw r24,r16
 1216 0430 4196      		adiw r24,17
 1217 0432 0E94 0000 		call xTaskRemoveFromEventList
 1218 0436 8111      		cpse r24,__zero_reg__
 1219 0438 00C0      		rjmp .L85
 1220               	.L83:
1122:../../Source/queue.c **** 				taskEXIT_CRITICAL();
 1222               	.LM145:
 1223               	/* #APP */
 1224               	 ;  1122 "../../Source/queue.c" 1
 1225 043a 0F90      		pop		__tmp_reg__
 1226               	 ;  0 "" 2
 1227               	 ;  1122 "../../Source/queue.c" 1
 1228 043c 0FBE      		out		__SREG__, __tmp_reg__
 1229               	 ;  0 "" 2
1123:../../Source/queue.c **** 				return pdPASS;
 1231               	.LM146:
 1232               	/* #NOAPP */
 1233 043e 81E0      		ldi r24,lo8(1)
 1234 0440 00C0      		rjmp .L86
 1235               	.L80:
1127:../../Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 1237               	.LM147:
 1238 0442 8C81      		ldd r24,Y+4
 1239 0444 9D81      		ldd r25,Y+5
 1240 0446 892B      		or r24,r25
 1241 0448 01F4      		brne .L87
1131:../../Source/queue.c **** 					taskEXIT_CRITICAL();
 1243               	.LM148:
 1244               	/* #APP */
 1245               	 ;  1131 "../../Source/queue.c" 1
 1246 044a 0F90      		pop		__tmp_reg__
 1247               	 ;  0 "" 2
 1248               	 ;  1131 "../../Source/queue.c" 1
 1249 044c 0FBE      		out		__SREG__, __tmp_reg__
 1250               	 ;  0 "" 2
 1251               	/* #NOAPP */
 1252 044e 00C0      		rjmp .L97
 1253               	.L87:
1135:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1255               	.LM149:
 1256 0450 3111      		cpse r19,__zero_reg__
 1257 0452 00C0      		rjmp .L88
1139:../../Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1259               	.LM150:
 1260 0454 CE01      		movw r24,r28
 1261 0456 0196      		adiw r24,1
 1262 0458 0E94 0000 		call vTaskSetTimeOutState
 1263               	.L88:
1148:../../Source/queue.c **** 		taskEXIT_CRITICAL();
 1265               	.LM151:
 1266               	/* #APP */
 1267               	 ;  1148 "../../Source/queue.c" 1
 1268 045c 0F90      		pop		__tmp_reg__
 1269               	 ;  0 "" 2
 1270               	 ;  1148 "../../Source/queue.c" 1
 1271 045e 0FBE      		out		__SREG__, __tmp_reg__
 1272               	 ;  0 "" 2
1153:../../Source/queue.c **** 		vTaskSuspendAll();
 1274               	.LM152:
 1275               	/* #NOAPP */
 1276 0460 0E94 0000 		call vTaskSuspendAll
1154:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 1278               	.LM153:
 1279               	/* #APP */
 1280               	 ;  1154 "../../Source/queue.c" 1
 1281 0464 0FB6      		in		__tmp_reg__, __SREG__
 1282               	 ;  0 "" 2
 1283               	 ;  1154 "../../Source/queue.c" 1
 1284 0466 F894      		cli
 1285               	 ;  0 "" 2
 1286               	 ;  1154 "../../Source/queue.c" 1
 1287 0468 0F92      		push	__tmp_reg__
 1288               	 ;  0 "" 2
 1289               	/* #NOAPP */
 1290 046a F801      		movw r30,r16
 1291 046c 858D      		ldd r24,Z+29
 1292 046e 8F3F      		cpi r24,lo8(-1)
 1293 0470 01F4      		brne .L89
1154:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 1295               	.LM154:
 1296 0472 158E      		std Z+29,__zero_reg__
 1297               	.L89:
1154:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 1299               	.LM155:
 1300 0474 F801      		movw r30,r16
 1301 0476 868D      		ldd r24,Z+30
 1302 0478 8F3F      		cpi r24,lo8(-1)
 1303 047a 01F4      		brne .L90
1154:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 1305               	.LM156:
 1306 047c 168E      		std Z+30,__zero_reg__
 1307               	.L90:
1154:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 1309               	.LM157:
 1310               	/* #APP */
 1311               	 ;  1154 "../../Source/queue.c" 1
 1312 047e 0F90      		pop		__tmp_reg__
 1313               	 ;  0 "" 2
 1314               	 ;  1154 "../../Source/queue.c" 1
 1315 0480 0FBE      		out		__SREG__, __tmp_reg__
 1316               	 ;  0 "" 2
1157:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1318               	.LM158:
 1319               	/* #NOAPP */
 1320 0482 BE01      		movw r22,r28
 1321 0484 6C5F      		subi r22,-4
 1322 0486 7F4F      		sbci r23,-1
 1323 0488 CE01      		movw r24,r28
 1324 048a 0196      		adiw r24,1
 1325 048c 0E94 0000 		call xTaskCheckForTimeOut
 1326 0490 8111      		cpse r24,__zero_reg__
 1327 0492 00C0      		rjmp .L91
 1328               	.LBB8:
 1329               	.LBB9:
1585:../../Source/queue.c **** 	taskENTER_CRITICAL();
 1331               	.LM159:
 1332               	/* #APP */
 1333               	 ;  1585 "../../Source/queue.c" 1
 1334 0494 0FB6      		in		__tmp_reg__, __SREG__
 1335               	 ;  0 "" 2
 1336               	 ;  1585 "../../Source/queue.c" 1
 1337 0496 F894      		cli
 1338               	 ;  0 "" 2
 1339               	 ;  1585 "../../Source/queue.c" 1
 1340 0498 0F92      		push	__tmp_reg__
 1341               	 ;  0 "" 2
1587:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
 1343               	.LM160:
 1344               	/* #NOAPP */
 1345 049a F801      		movw r30,r16
 1346 049c 828D      		ldd r24,Z+26
1596:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 1348               	.LM161:
 1349               	/* #APP */
 1350               	 ;  1596 "../../Source/queue.c" 1
 1351 049e 0F90      		pop		__tmp_reg__
 1352               	 ;  0 "" 2
 1353               	 ;  1596 "../../Source/queue.c" 1
 1354 04a0 0FBE      		out		__SREG__, __tmp_reg__
 1355               	 ;  0 "" 2
 1356               	/* #NOAPP */
 1357               	.LBE9:
 1358               	.LBE8:
1159:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1360               	.LM162:
 1361 04a2 8111      		cpse r24,__zero_reg__
 1362 04a4 00C0      		rjmp .L92
1176:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1364               	.LM163:
 1365 04a6 6C81      		ldd r22,Y+4
 1366 04a8 7D81      		ldd r23,Y+5
 1367 04aa C701      		movw r24,r14
 1368 04ac 0E94 0000 		call vTaskPlaceOnEventList
1177:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1370               	.LM164:
 1371 04b0 C801      		movw r24,r16
 1372 04b2 0E94 0000 		call prvUnlockQueue
1178:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1374               	.LM165:
 1375 04b6 0E94 0000 		call xTaskResumeAll
 1376 04ba 8111      		cpse r24,__zero_reg__
 1377 04bc 00C0      		rjmp .L93
1180:../../Source/queue.c **** 					portYIELD_WITHIN_API();
 1379               	.LM166:
 1380 04be 0E94 0000 		call vPortYield
 1381 04c2 00C0      		rjmp .L93
 1382               	.L92:
1186:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1384               	.LM167:
 1385 04c4 C801      		movw r24,r16
 1386 04c6 0E94 0000 		call prvUnlockQueue
1187:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 1388               	.LM168:
 1389 04ca 0E94 0000 		call xTaskResumeAll
 1390 04ce 00C0      		rjmp .L93
 1391               	.L91:
1192:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1393               	.LM169:
 1394 04d0 C801      		movw r24,r16
 1395 04d2 0E94 0000 		call prvUnlockQueue
1193:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 1397               	.LM170:
 1398 04d6 0E94 0000 		call xTaskResumeAll
 1399               	.L97:
1195:../../Source/queue.c **** 			return errQUEUE_EMPTY;
 1401               	.LM171:
 1402 04da 80E0      		ldi r24,0
 1403               	.L86:
 1404               	/* epilogue start */
1198:../../Source/queue.c **** }
 1406               	.LM172:
 1407 04dc 0F90      		pop __tmp_reg__
 1408 04de 0F90      		pop __tmp_reg__
 1409 04e0 0F90      		pop __tmp_reg__
 1410 04e2 0F90      		pop __tmp_reg__
 1411 04e4 0F90      		pop __tmp_reg__
 1412 04e6 DF91      		pop r29
 1413 04e8 CF91      		pop r28
 1414 04ea 1F91      		pop r17
 1415 04ec 0F91      		pop r16
 1416 04ee FF90      		pop r15
 1417 04f0 EF90      		pop r14
 1418 04f2 DF90      		pop r13
 1419 04f4 CF90      		pop r12
 1420 04f6 BF90      		pop r11
 1421 04f8 0895      		ret
 1428               	.Lscope8:
 1430               		.stabd	78,0,0
 1435               	.global	xQueueReceiveFromISR
 1437               	xQueueReceiveFromISR:
 1438               		.stabd	46,0,0
1202:../../Source/queue.c **** {
 1440               	.LM173:
 1441               	.LFBB9:
 1442 04fa 0F93      		push r16
 1443 04fc 1F93      		push r17
 1444 04fe CF93      		push r28
 1445 0500 DF93      		push r29
 1446               	/* prologue: function */
 1447               	/* frame size = 0 */
 1448               	/* stack size = 4 */
 1449               	.L__stack_usage = 4
 1450 0502 EC01      		movw r28,r24
 1451 0504 8A01      		movw r16,r20
1229:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1453               	.LM174:
 1454 0506 8A8D      		ldd r24,Y+26
 1455 0508 8823      		tst r24
 1456 050a 01F0      		breq .L103
1233:../../Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1458               	.LM175:
 1459 050c CE01      		movw r24,r28
 1460 050e 0E94 0000 		call prvCopyDataFromQueue
1234:../../Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1462               	.LM176:
 1463 0512 8A8D      		ldd r24,Y+26
 1464 0514 8150      		subi r24,lo8(-(-1))
 1465 0516 8A8F      		std Y+26,r24
1240:../../Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1467               	.LM177:
 1468 0518 8D8D      		ldd r24,Y+29
 1469 051a 8F3F      		cpi r24,lo8(-1)
 1470 051c 01F4      		brne .L100
1242:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1472               	.LM178:
 1473 051e 8885      		ldd r24,Y+8
 1474 0520 8111      		cpse r24,__zero_reg__
 1475 0522 00C0      		rjmp .L101
 1476 0524 00C0      		rjmp .L110
 1477               	.L101:
1244:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1479               	.LM179:
 1480 0526 CE01      		movw r24,r28
 1481 0528 0896      		adiw r24,8
 1482 052a 0E94 0000 		call xTaskRemoveFromEventList
 1483 052e 8823      		tst r24
 1484 0530 01F0      		breq .L110
1248:../../Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1486               	.LM180:
 1487 0532 0115      		cp r16,__zero_reg__
 1488 0534 1105      		cpc r17,__zero_reg__
 1489 0536 01F0      		breq .L110
1250:../../Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1491               	.LM181:
 1492 0538 81E0      		ldi r24,lo8(1)
 1493 053a F801      		movw r30,r16
 1494 053c 8083      		st Z,r24
 1495 053e 00C0      		rjmp .L99
 1496               	.L100:
1259:../../Source/queue.c **** 				++( pxQueue->xRxLock );
 1498               	.LM182:
 1499 0540 8D8D      		ldd r24,Y+29
 1500 0542 8F5F      		subi r24,lo8(-(1))
 1501 0544 8D8F      		std Y+29,r24
 1502               	.L110:
1262:../../Source/queue.c **** 			xReturn = pdPASS;
 1504               	.LM183:
 1505 0546 81E0      		ldi r24,lo8(1)
 1506 0548 00C0      		rjmp .L99
 1507               	.L103:
1266:../../Source/queue.c **** 			xReturn = pdFAIL;
 1509               	.LM184:
 1510 054a 80E0      		ldi r24,0
 1511               	.L99:
 1512               	/* epilogue start */
1273:../../Source/queue.c **** }
 1514               	.LM185:
 1515 054c DF91      		pop r29
 1516 054e CF91      		pop r28
 1517 0550 1F91      		pop r17
 1518 0552 0F91      		pop r16
 1519 0554 0895      		ret
 1524               	.Lscope9:
 1526               		.stabd	78,0,0
 1530               	.global	xQueuePeekFromISR
 1532               	xQueuePeekFromISR:
 1533               		.stabd	46,0,0
1277:../../Source/queue.c **** {
 1535               	.LM186:
 1536               	.LFBB10:
 1537 0556 0F93      		push r16
 1538 0558 1F93      		push r17
 1539 055a CF93      		push r28
 1540 055c DF93      		push r29
 1541               	/* prologue: function */
 1542               	/* frame size = 0 */
 1543               	/* stack size = 4 */
 1544               	.L__stack_usage = 4
 1545 055e EC01      		movw r28,r24
1305:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1547               	.LM187:
 1548 0560 8A8D      		ldd r24,Y+26
 1549 0562 8823      		tst r24
 1550 0564 01F0      		breq .L113
1311:../../Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1552               	.LM188:
 1553 0566 0E81      		ldd r16,Y+6
 1554 0568 1F81      		ldd r17,Y+7
1312:../../Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1556               	.LM189:
 1557 056a CE01      		movw r24,r28
 1558 056c 0E94 0000 		call prvCopyDataFromQueue
1313:../../Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1560               	.LM190:
 1561 0570 1F83      		std Y+7,r17
 1562 0572 0E83      		std Y+6,r16
1315:../../Source/queue.c **** 			xReturn = pdPASS;
 1564               	.LM191:
 1565 0574 81E0      		ldi r24,lo8(1)
 1566 0576 00C0      		rjmp .L112
 1567               	.L113:
1319:../../Source/queue.c **** 			xReturn = pdFAIL;
 1569               	.LM192:
 1570 0578 80E0      		ldi r24,0
 1571               	.L112:
 1572               	/* epilogue start */
1326:../../Source/queue.c **** }
 1574               	.LM193:
 1575 057a DF91      		pop r29
 1576 057c CF91      		pop r28
 1577 057e 1F91      		pop r17
 1578 0580 0F91      		pop r16
 1579 0582 0895      		ret
 1585               	.Lscope10:
 1587               		.stabd	78,0,0
 1590               	.global	uxQueueMessagesWaiting
 1592               	uxQueueMessagesWaiting:
 1593               		.stabd	46,0,0
1330:../../Source/queue.c **** {
 1595               	.LM194:
 1596               	.LFBB11:
 1597               	/* prologue: function */
 1598               	/* frame size = 0 */
 1599               	/* stack size = 0 */
 1600               	.L__stack_usage = 0
1335:../../Source/queue.c **** 	taskENTER_CRITICAL();
 1602               	.LM195:
 1603               	/* #APP */
 1604               	 ;  1335 "../../Source/queue.c" 1
 1605 0584 0FB6      		in		__tmp_reg__, __SREG__
 1606               	 ;  0 "" 2
 1607               	 ;  1335 "../../Source/queue.c" 1
 1608 0586 F894      		cli
 1609               	 ;  0 "" 2
 1610               	 ;  1335 "../../Source/queue.c" 1
 1611 0588 0F92      		push	__tmp_reg__
 1612               	 ;  0 "" 2
1336:../../Source/queue.c **** 		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 1614               	.LM196:
 1615               	/* #NOAPP */
 1616 058a FC01      		movw r30,r24
 1617 058c 828D      		ldd r24,Z+26
1337:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 1619               	.LM197:
 1620               	/* #APP */
 1621               	 ;  1337 "../../Source/queue.c" 1
 1622 058e 0F90      		pop		__tmp_reg__
 1623               	 ;  0 "" 2
 1624               	 ;  1337 "../../Source/queue.c" 1
 1625 0590 0FBE      		out		__SREG__, __tmp_reg__
 1626               	 ;  0 "" 2
1340:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1628               	.LM198:
 1629               	/* #NOAPP */
 1630 0592 0895      		ret
 1635               	.Lscope11:
 1637               		.stabd	78,0,0
 1640               	.global	uxQueueSpacesAvailable
 1642               	uxQueueSpacesAvailable:
 1643               		.stabd	46,0,0
1344:../../Source/queue.c **** {
 1645               	.LM199:
 1646               	.LFBB12:
 1647               	/* prologue: function */
 1648               	/* frame size = 0 */
 1649               	/* stack size = 0 */
 1650               	.L__stack_usage = 0
1351:../../Source/queue.c **** 	taskENTER_CRITICAL();
 1652               	.LM200:
 1653               	/* #APP */
 1654               	 ;  1351 "../../Source/queue.c" 1
 1655 0594 0FB6      		in		__tmp_reg__, __SREG__
 1656               	 ;  0 "" 2
 1657               	 ;  1351 "../../Source/queue.c" 1
 1658 0596 F894      		cli
 1659               	 ;  0 "" 2
 1660               	 ;  1351 "../../Source/queue.c" 1
 1661 0598 0F92      		push	__tmp_reg__
 1662               	 ;  0 "" 2
1352:../../Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1664               	.LM201:
 1665               	/* #NOAPP */
 1666 059a FC01      		movw r30,r24
 1667 059c 228D      		ldd r18,Z+26
1353:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 1669               	.LM202:
 1670               	/* #APP */
 1671               	 ;  1353 "../../Source/queue.c" 1
 1672 059e 0F90      		pop		__tmp_reg__
 1673               	 ;  0 "" 2
 1674               	 ;  1353 "../../Source/queue.c" 1
 1675 05a0 0FBE      		out		__SREG__, __tmp_reg__
 1676               	 ;  0 "" 2
1352:../../Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1678               	.LM203:
 1679               	/* #NOAPP */
 1680 05a2 FC01      		movw r30,r24
 1681 05a4 838D      		ldd r24,Z+27
1356:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1683               	.LM204:
 1684 05a6 821B      		sub r24,r18
 1685 05a8 0895      		ret
 1687               	.Lscope12:
 1689               		.stabd	78,0,0
 1692               	.global	uxQueueMessagesWaitingFromISR
 1694               	uxQueueMessagesWaitingFromISR:
 1695               		.stabd	46,0,0
1360:../../Source/queue.c **** {
 1697               	.LM205:
 1698               	.LFBB13:
 1699               	/* prologue: function */
 1700               	/* frame size = 0 */
 1701               	/* stack size = 0 */
 1702               	.L__stack_usage = 0
1365:../../Source/queue.c **** 	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 1704               	.LM206:
 1705 05aa FC01      		movw r30,r24
 1706 05ac 828D      		ldd r24,Z+26
1368:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1708               	.LM207:
 1709 05ae 0895      		ret
 1714               	.Lscope13:
 1716               		.stabd	78,0,0
 1719               	.global	vQueueDelete
 1721               	vQueueDelete:
 1722               		.stabd	46,0,0
1372:../../Source/queue.c **** {
 1724               	.LM208:
 1725               	.LFBB14:
 1726 05b0 CF93      		push r28
 1727 05b2 DF93      		push r29
 1728               	/* prologue: function */
 1729               	/* frame size = 0 */
 1730               	/* stack size = 2 */
 1731               	.L__stack_usage = 2
 1732 05b4 EC01      		movw r28,r24
1383:../../Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 1734               	.LM209:
 1735 05b6 8881      		ld r24,Y
 1736 05b8 9981      		ldd r25,Y+1
 1737 05ba 0E94 0000 		call vPortFree
1384:../../Source/queue.c **** 	vPortFree( pxQueue );
 1739               	.LM210:
 1740 05be CE01      		movw r24,r28
 1741               	/* epilogue start */
1385:../../Source/queue.c **** }
 1743               	.LM211:
 1744 05c0 DF91      		pop r29
 1745 05c2 CF91      		pop r28
1384:../../Source/queue.c **** 	vPortFree( pxQueue );
 1747               	.LM212:
 1748 05c4 0C94 0000 		jmp vPortFree
 1750               	.Lscope14:
 1752               		.stabd	78,0,0
 1755               	.global	xQueueIsQueueEmptyFromISR
 1757               	xQueueIsQueueEmptyFromISR:
 1758               		.stabd	46,0,0
1603:../../Source/queue.c **** {
 1760               	.LM213:
 1761               	.LFBB15:
 1762               	/* prologue: function */
 1763               	/* frame size = 0 */
 1764               	/* stack size = 0 */
 1765               	.L__stack_usage = 0
1607:../../Source/queue.c **** 	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
 1767               	.LM214:
 1768 05c8 FC01      		movw r30,r24
 1769 05ca 928D      		ldd r25,Z+26
 1770 05cc 81E0      		ldi r24,lo8(1)
 1771 05ce 9111      		cpse r25,__zero_reg__
 1772 05d0 80E0      		ldi r24,0
 1773               	.L119:
1617:../../Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 1775               	.LM215:
 1776 05d2 0895      		ret
 1778               	.Lscope15:
 1780               		.stabd	78,0,0
 1783               	.global	xQueueIsQueueFullFromISR
 1785               	xQueueIsQueueFullFromISR:
 1786               		.stabd	46,0,0
1636:../../Source/queue.c **** 
1637:../../Source/queue.c **** 	return xReturn;
1638:../../Source/queue.c **** }
1639:../../Source/queue.c **** /*-----------------------------------------------------------*/
1640:../../Source/queue.c **** 
1641:../../Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
1642:../../Source/queue.c **** {
 1788               	.LM216:
 1789               	.LFBB16:
 1790               	/* prologue: function */
 1791               	/* frame size = 0 */
 1792               	/* stack size = 0 */
 1793               	.L__stack_usage = 0
 1794 05d4 FC01      		movw r30,r24
1643:../../Source/queue.c **** signed portBASE_TYPE xReturn;
1644:../../Source/queue.c **** 
1645:../../Source/queue.c **** 	configASSERT( xQueue );
1646:../../Source/queue.c **** 	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
 1796               	.LM217:
 1797 05d6 228D      		ldd r18,Z+26
 1798 05d8 81E0      		ldi r24,lo8(1)
 1799 05da 938D      		ldd r25,Z+27
 1800 05dc 2913      		cpse r18,r25
 1801 05de 80E0      		ldi r24,0
 1802               	.L124:
1647:../../Source/queue.c **** 	{
1648:../../Source/queue.c **** 		xReturn = pdTRUE;
1649:../../Source/queue.c **** 	}
1650:../../Source/queue.c **** 	else
1651:../../Source/queue.c **** 	{
1652:../../Source/queue.c **** 		xReturn = pdFALSE;
1653:../../Source/queue.c **** 	}
1654:../../Source/queue.c **** 
1655:../../Source/queue.c **** 	return xReturn;
1656:../../Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 1804               	.LM218:
 1805 05e0 0895      		ret
 1807               	.Lscope16:
 1809               		.stabd	78,0,0
 1814               	.global	xQueueCRSend
 1816               	xQueueCRSend:
 1817               		.stabd	46,0,0
1657:../../Source/queue.c **** /*-----------------------------------------------------------*/
1658:../../Source/queue.c **** 
1659:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1660:../../Source/queue.c **** 
1661:../../Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xT
1662:../../Source/queue.c **** 	{
 1819               	.LM219:
 1820               	.LFBB17:
 1821 05e2 CF93      		push r28
 1822 05e4 DF93      		push r29
 1823               	/* prologue: function */
 1824               	/* frame size = 0 */
 1825               	/* stack size = 2 */
 1826               	.L__stack_usage = 2
 1827 05e6 EC01      		movw r28,r24
 1828 05e8 CA01      		movw r24,r20
1663:../../Source/queue.c **** 	signed portBASE_TYPE xReturn;
1664:../../Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1665:../../Source/queue.c **** 
1666:../../Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
1667:../../Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
1668:../../Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
1669:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 1830               	.LM220:
 1831               	/* #APP */
 1832               	 ;  1669 "../../Source/queue.c" 1
 1833 05ea F894      		cli
 1834               	 ;  0 "" 2
 1835               	/* #NOAPP */
 1836               	.LBB12:
 1837               	.LBB13:
1624:../../Source/queue.c **** 	taskENTER_CRITICAL();
 1839               	.LM221:
 1840               	/* #APP */
 1841               	 ;  1624 "../../Source/queue.c" 1
 1842 05ec 0FB6      		in		__tmp_reg__, __SREG__
 1843               	 ;  0 "" 2
 1844               	 ;  1624 "../../Source/queue.c" 1
 1845 05ee F894      		cli
 1846               	 ;  0 "" 2
 1847               	 ;  1624 "../../Source/queue.c" 1
 1848 05f0 0F92      		push	__tmp_reg__
 1849               	 ;  0 "" 2
1626:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1851               	.LM222:
 1852               	/* #NOAPP */
 1853 05f2 3A8D      		ldd r19,Y+26
 1854 05f4 2B8D      		ldd r18,Y+27
1635:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 1856               	.LM223:
 1857               	/* #APP */
 1858               	 ;  1635 "../../Source/queue.c" 1
 1859 05f6 0F90      		pop		__tmp_reg__
 1860               	 ;  0 "" 2
 1861               	 ;  1635 "../../Source/queue.c" 1
 1862 05f8 0FBE      		out		__SREG__, __tmp_reg__
 1863               	 ;  0 "" 2
 1864               	/* #NOAPP */
 1865               	.LBE13:
 1866               	.LBE12:
1670:../../Source/queue.c **** 		{
1671:../../Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 1868               	.LM224:
 1869 05fa 3213      		cpse r19,r18
 1870 05fc 00C0      		rjmp .L126
1672:../../Source/queue.c **** 			{
1673:../../Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
1674:../../Source/queue.c **** 				posting? */
1675:../../Source/queue.c **** 				if( xTicksToWait > ( portTickType ) 0 )
 1872               	.LM225:
 1873 05fe 0097      		sbiw r24,0
 1874 0600 01F0      		breq .L127
1676:../../Source/queue.c **** 				{
1677:../../Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
1678:../../Source/queue.c **** 					return indicating that we need to block. */
1679:../../Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 1876               	.LM226:
 1877 0602 BE01      		movw r22,r28
 1878 0604 685F      		subi r22,-8
 1879 0606 7F4F      		sbci r23,-1
 1880 0608 0E94 0000 		call vCoRoutineAddToDelayedList
1680:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 1882               	.LM227:
 1883               	/* #APP */
 1884               	 ;  1680 "../../Source/queue.c" 1
 1885 060c 7894      		sei
 1886               	 ;  0 "" 2
1681:../../Source/queue.c **** 					return errQUEUE_BLOCKED;
 1888               	.LM228:
 1889               	/* #NOAPP */
 1890 060e 8CEF      		ldi r24,lo8(-4)
 1891 0610 00C0      		rjmp .L128
 1892               	.L127:
1682:../../Source/queue.c **** 				}
1683:../../Source/queue.c **** 				else
1684:../../Source/queue.c **** 				{
1685:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 1894               	.LM229:
 1895               	/* #APP */
 1896               	 ;  1685 "../../Source/queue.c" 1
 1897 0612 7894      		sei
 1898               	 ;  0 "" 2
1686:../../Source/queue.c **** 					return errQUEUE_FULL;
 1900               	.LM230:
 1901               	/* #NOAPP */
 1902 0614 80E0      		ldi r24,0
 1903 0616 00C0      		rjmp .L128
 1904               	.L126:
1687:../../Source/queue.c **** 				}
1688:../../Source/queue.c **** 			}
1689:../../Source/queue.c **** 		}
1690:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 1906               	.LM231:
 1907               	/* #APP */
 1908               	 ;  1690 "../../Source/queue.c" 1
 1909 0618 7894      		sei
 1910               	 ;  0 "" 2
1691:../../Source/queue.c **** 
1692:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 1912               	.LM232:
 1913               	 ;  1692 "../../Source/queue.c" 1
 1914 061a F894      		cli
 1915               	 ;  0 "" 2
1693:../../Source/queue.c **** 		{
1694:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 1917               	.LM233:
 1918               	/* #NOAPP */
 1919 061c 8A8D      		ldd r24,Y+26
 1920 061e 8217      		cp r24,r18
 1921 0620 00F4      		brsh .L132
1695:../../Source/queue.c **** 			{
1696:../../Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
1697:../../Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 1923               	.LM234:
 1924 0622 40E0      		ldi r20,0
 1925 0624 CE01      		movw r24,r28
 1926 0626 0E94 0000 		call prvCopyDataToQueue
1698:../../Source/queue.c **** 				xReturn = pdPASS;
1699:../../Source/queue.c **** 
1700:../../Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
1701:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1928               	.LM235:
 1929 062a 8989      		ldd r24,Y+17
 1930 062c 8111      		cpse r24,__zero_reg__
 1931 062e 00C0      		rjmp .L130
 1932               	.L131:
1698:../../Source/queue.c **** 				xReturn = pdPASS;
 1934               	.LM236:
 1935 0630 81E0      		ldi r24,lo8(1)
 1936 0632 00C0      		rjmp .L129
 1937               	.L130:
1702:../../Source/queue.c **** 				{
1703:../../Source/queue.c **** 					/* In this instance the co-routine could be placed directly
1704:../../Source/queue.c **** 					into the ready list as we are within a critical section.
1705:../../Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
1706:../../Source/queue.c **** 					the event were caused from within an interrupt. */
1707:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1939               	.LM237:
 1940 0634 CE01      		movw r24,r28
 1941 0636 4196      		adiw r24,17
 1942 0638 0E94 0000 		call xCoRoutineRemoveFromEventList
 1943 063c 8823      		tst r24
 1944 063e 01F0      		breq .L131
1708:../../Source/queue.c **** 					{
1709:../../Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
1710:../../Source/queue.c **** 						that a yield might be appropriate. */
1711:../../Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 1946               	.LM238:
 1947 0640 8BEF      		ldi r24,lo8(-5)
 1948 0642 00C0      		rjmp .L129
 1949               	.L132:
1712:../../Source/queue.c **** 					}
1713:../../Source/queue.c **** 				}
1714:../../Source/queue.c **** 			}
1715:../../Source/queue.c **** 			else
1716:../../Source/queue.c **** 			{
1717:../../Source/queue.c **** 				xReturn = errQUEUE_FULL;
 1951               	.LM239:
 1952 0644 80E0      		ldi r24,0
 1953               	.L129:
1718:../../Source/queue.c **** 			}
1719:../../Source/queue.c **** 		}
1720:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 1955               	.LM240:
 1956               	/* #APP */
 1957               	 ;  1720 "../../Source/queue.c" 1
 1958 0646 7894      		sei
 1959               	 ;  0 "" 2
 1960               	/* #NOAPP */
 1961               	.L128:
 1962               	/* epilogue start */
1721:../../Source/queue.c **** 
1722:../../Source/queue.c **** 		return xReturn;
1723:../../Source/queue.c **** 	}
 1964               	.LM241:
 1965 0648 DF91      		pop r29
 1966 064a CF91      		pop r28
 1967 064c 0895      		ret
 1972               	.Lscope17:
 1974               		.stabd	78,0,0
 1978               	.global	xQueueCRReceive
 1980               	xQueueCRReceive:
 1981               		.stabd	46,0,0
1724:../../Source/queue.c **** 
1725:../../Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1726:../../Source/queue.c **** /*-----------------------------------------------------------*/
1727:../../Source/queue.c **** 
1728:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1729:../../Source/queue.c **** 
1730:../../Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWa
1731:../../Source/queue.c **** 	{
 1983               	.LM242:
 1984               	.LFBB18:
 1985 064e CF93      		push r28
 1986 0650 DF93      		push r29
 1987               	/* prologue: function */
 1988               	/* frame size = 0 */
 1989               	/* stack size = 2 */
 1990               	.L__stack_usage = 2
 1991 0652 EC01      		movw r28,r24
 1992 0654 CB01      		movw r24,r22
1732:../../Source/queue.c **** 	signed portBASE_TYPE xReturn;
1733:../../Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1734:../../Source/queue.c **** 
1735:../../Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
1736:../../Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
1737:../../Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
1738:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 1994               	.LM243:
 1995               	/* #APP */
 1996               	 ;  1738 "../../Source/queue.c" 1
 1997 0656 F894      		cli
 1998               	 ;  0 "" 2
1739:../../Source/queue.c **** 		{
1740:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
 2000               	.LM244:
 2001               	/* #NOAPP */
 2002 0658 2A8D      		ldd r18,Y+26
 2003 065a 2111      		cpse r18,__zero_reg__
 2004 065c 00C0      		rjmp .L137
1741:../../Source/queue.c **** 			{
1742:../../Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
1743:../../Source/queue.c **** 				leave with nothing? */
1744:../../Source/queue.c **** 				if( xTicksToWait > ( portTickType ) 0 )
 2006               	.LM245:
 2007 065e 4115      		cp r20,__zero_reg__
 2008 0660 5105      		cpc r21,__zero_reg__
 2009 0662 01F0      		breq .L138
1745:../../Source/queue.c **** 				{
1746:../../Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
1747:../../Source/queue.c **** 					indicating that we need to block. */
1748:../../Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 2011               	.LM246:
 2012 0664 BE01      		movw r22,r28
 2013 0666 6F5E      		subi r22,-17
 2014 0668 7F4F      		sbci r23,-1
 2015 066a CA01      		movw r24,r20
 2016 066c 0E94 0000 		call vCoRoutineAddToDelayedList
1749:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 2018               	.LM247:
 2019               	/* #APP */
 2020               	 ;  1749 "../../Source/queue.c" 1
 2021 0670 7894      		sei
 2022               	 ;  0 "" 2
1750:../../Source/queue.c **** 					return errQUEUE_BLOCKED;
 2024               	.LM248:
 2025               	/* #NOAPP */
 2026 0672 8CEF      		ldi r24,lo8(-4)
 2027 0674 00C0      		rjmp .L139
 2028               	.L138:
1751:../../Source/queue.c **** 				}
1752:../../Source/queue.c **** 				else
1753:../../Source/queue.c **** 				{
1754:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 2030               	.LM249:
 2031               	/* #APP */
 2032               	 ;  1754 "../../Source/queue.c" 1
 2033 0676 7894      		sei
 2034               	 ;  0 "" 2
1755:../../Source/queue.c **** 					return errQUEUE_FULL;
 2036               	.LM250:
 2037               	/* #NOAPP */
 2038 0678 80E0      		ldi r24,0
 2039 067a 00C0      		rjmp .L139
 2040               	.L137:
1756:../../Source/queue.c **** 				}
1757:../../Source/queue.c **** 			}
1758:../../Source/queue.c **** 		}
1759:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 2042               	.LM251:
 2043               	/* #APP */
 2044               	 ;  1759 "../../Source/queue.c" 1
 2045 067c 7894      		sei
 2046               	 ;  0 "" 2
1760:../../Source/queue.c **** 
1761:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2048               	.LM252:
 2049               	 ;  1761 "../../Source/queue.c" 1
 2050 067e F894      		cli
 2051               	 ;  0 "" 2
1762:../../Source/queue.c **** 		{
1763:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 2053               	.LM253:
 2054               	/* #NOAPP */
 2055 0680 2A8D      		ldd r18,Y+26
 2056 0682 2223      		tst r18
 2057 0684 01F0      		breq .L144
1764:../../Source/queue.c **** 			{
1765:../../Source/queue.c **** 				/* Data is available from the queue. */
1766:../../Source/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2059               	.LM254:
 2060 0686 4C8D      		ldd r20,Y+28
 2061 0688 2E81      		ldd r18,Y+6
 2062 068a 3F81      		ldd r19,Y+7
 2063 068c 240F      		add r18,r20
 2064 068e 311D      		adc r19,__zero_reg__
 2065 0690 3F83      		std Y+7,r19
 2066 0692 2E83      		std Y+6,r18
1767:../../Source/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
 2068               	.LM255:
 2069 0694 EA81      		ldd r30,Y+2
 2070 0696 FB81      		ldd r31,Y+3
 2071 0698 2E17      		cp r18,r30
 2072 069a 3F07      		cpc r19,r31
 2073 069c 00F0      		brlo .L141
1768:../../Source/queue.c **** 				{
1769:../../Source/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2075               	.LM256:
 2076 069e 2881      		ld r18,Y
 2077 06a0 3981      		ldd r19,Y+1
 2078 06a2 3F83      		std Y+7,r19
 2079 06a4 2E83      		std Y+6,r18
 2080               	.L141:
1770:../../Source/queue.c **** 				}
1771:../../Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 2082               	.LM257:
 2083 06a6 2A8D      		ldd r18,Y+26
 2084 06a8 2150      		subi r18,lo8(-(-1))
 2085 06aa 2A8F      		std Y+26,r18
1772:../../Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
 2087               	.LM258:
 2088 06ac 6E81      		ldd r22,Y+6
 2089 06ae 7F81      		ldd r23,Y+7
 2090 06b0 50E0      		ldi r21,0
 2091 06b2 0E94 0000 		call memcpy
1773:../../Source/queue.c **** 
1774:../../Source/queue.c **** 				xReturn = pdPASS;
1775:../../Source/queue.c **** 
1776:../../Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
1777:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2093               	.LM259:
 2094 06b6 8885      		ldd r24,Y+8
 2095 06b8 8111      		cpse r24,__zero_reg__
 2096 06ba 00C0      		rjmp .L142
 2097               	.L143:
1774:../../Source/queue.c **** 				xReturn = pdPASS;
 2099               	.LM260:
 2100 06bc 81E0      		ldi r24,lo8(1)
 2101 06be 00C0      		rjmp .L140
 2102               	.L142:
1778:../../Source/queue.c **** 				{
1779:../../Source/queue.c **** 					/* In this instance the co-routine could be placed directly
1780:../../Source/queue.c **** 					into the ready list as we are within a critical section.
1781:../../Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
1782:../../Source/queue.c **** 					the event were caused from within an interrupt. */
1783:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2104               	.LM261:
 2105 06c0 CE01      		movw r24,r28
 2106 06c2 0896      		adiw r24,8
 2107 06c4 0E94 0000 		call xCoRoutineRemoveFromEventList
 2108 06c8 8823      		tst r24
 2109 06ca 01F0      		breq .L143
1784:../../Source/queue.c **** 					{
1785:../../Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2111               	.LM262:
 2112 06cc 8BEF      		ldi r24,lo8(-5)
 2113 06ce 00C0      		rjmp .L140
 2114               	.L144:
1786:../../Source/queue.c **** 					}
1787:../../Source/queue.c **** 				}
1788:../../Source/queue.c **** 			}
1789:../../Source/queue.c **** 			else
1790:../../Source/queue.c **** 			{
1791:../../Source/queue.c **** 				xReturn = pdFAIL;
 2116               	.LM263:
 2117 06d0 80E0      		ldi r24,0
 2118               	.L140:
1792:../../Source/queue.c **** 			}
1793:../../Source/queue.c **** 		}
1794:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 2120               	.LM264:
 2121               	/* #APP */
 2122               	 ;  1794 "../../Source/queue.c" 1
 2123 06d2 7894      		sei
 2124               	 ;  0 "" 2
 2125               	/* #NOAPP */
 2126               	.L139:
 2127               	/* epilogue start */
1795:../../Source/queue.c **** 
1796:../../Source/queue.c **** 		return xReturn;
1797:../../Source/queue.c **** 	}
 2129               	.LM265:
 2130 06d4 DF91      		pop r29
 2131 06d6 CF91      		pop r28
 2132 06d8 0895      		ret
 2137               	.Lscope18:
 2139               		.stabd	78,0,0
 2144               	.global	xQueueCRSendFromISR
 2146               	xQueueCRSendFromISR:
 2147               		.stabd	46,0,0
1798:../../Source/queue.c **** 
1799:../../Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1800:../../Source/queue.c **** /*-----------------------------------------------------------*/
1801:../../Source/queue.c **** 
1802:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1803:../../Source/queue.c **** 
1804:../../Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed p
1805:../../Source/queue.c **** 	{
 2149               	.LM266:
 2150               	.LFBB19:
 2151 06da 1F93      		push r17
 2152 06dc CF93      		push r28
 2153 06de DF93      		push r29
 2154               	/* prologue: function */
 2155               	/* frame size = 0 */
 2156               	/* stack size = 3 */
 2157               	.L__stack_usage = 3
 2158 06e0 EC01      		movw r28,r24
 2159 06e2 142F      		mov r17,r20
1806:../../Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1807:../../Source/queue.c **** 
1808:../../Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
1809:../../Source/queue.c **** 		exit without doing anything. */
1810:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2161               	.LM267:
 2162 06e4 9A8D      		ldd r25,Y+26
 2163 06e6 8B8D      		ldd r24,Y+27
 2164 06e8 9817      		cp r25,r24
 2165 06ea 00F4      		brsh .L150
1811:../../Source/queue.c **** 		{
1812:../../Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2167               	.LM268:
 2168 06ec 40E0      		ldi r20,0
 2169 06ee CE01      		movw r24,r28
 2170 06f0 0E94 0000 		call prvCopyDataToQueue
1813:../../Source/queue.c **** 
1814:../../Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
1815:../../Source/queue.c **** 			co-routine has not already been woken. */
1816:../../Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
 2172               	.LM269:
 2173 06f4 1111      		cpse r17,__zero_reg__
 2174 06f6 00C0      		rjmp .L150
1817:../../Source/queue.c **** 			{
1818:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2176               	.LM270:
 2177 06f8 8989      		ldd r24,Y+17
 2178 06fa 8823      		tst r24
 2179 06fc 01F0      		breq .L150
1819:../../Source/queue.c **** 				{
1820:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2181               	.LM271:
 2182 06fe CE01      		movw r24,r28
 2183 0700 4196      		adiw r24,17
 2184 0702 0E94 0000 		call xCoRoutineRemoveFromEventList
 2185 0706 11E0      		ldi r17,lo8(1)
 2186 0708 8111      		cpse r24,__zero_reg__
 2187 070a 00C0      		rjmp .L150
 2188 070c 10E0      		ldi r17,0
 2189               	.L150:
1821:../../Source/queue.c **** 					{
1822:../../Source/queue.c **** 						return pdTRUE;
1823:../../Source/queue.c **** 					}
1824:../../Source/queue.c **** 				}
1825:../../Source/queue.c **** 			}
1826:../../Source/queue.c **** 		}
1827:../../Source/queue.c **** 
1828:../../Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
1829:../../Source/queue.c **** 	}
 2191               	.LM272:
 2192 070e 812F      		mov r24,r17
 2193               	/* epilogue start */
 2194 0710 DF91      		pop r29
 2195 0712 CF91      		pop r28
 2196 0714 1F91      		pop r17
 2197 0716 0895      		ret
 2199               	.Lscope19:
 2201               		.stabd	78,0,0
 2205               	.global	xQueueCRReceiveFromISR
 2207               	xQueueCRReceiveFromISR:
 2208               		.stabd	46,0,0
1830:../../Source/queue.c **** 
1831:../../Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1832:../../Source/queue.c **** /*-----------------------------------------------------------*/
1833:../../Source/queue.c **** 
1834:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1835:../../Source/queue.c **** 
1836:../../Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_
1837:../../Source/queue.c **** 	{
 2210               	.LM273:
 2211               	.LFBB20:
 2212 0718 0F93      		push r16
 2213 071a 1F93      		push r17
 2214 071c CF93      		push r28
 2215 071e DF93      		push r29
 2216               	/* prologue: function */
 2217               	/* frame size = 0 */
 2218               	/* stack size = 4 */
 2219               	.L__stack_usage = 4
 2220 0720 EC01      		movw r28,r24
 2221 0722 CB01      		movw r24,r22
 2222 0724 8A01      		movw r16,r20
1838:../../Source/queue.c **** 	signed portBASE_TYPE xReturn;
1839:../../Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1840:../../Source/queue.c **** 
1841:../../Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
1842:../../Source/queue.c **** 		not then just leave without doing anything. */
1843:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 2224               	.LM274:
 2225 0726 2A8D      		ldd r18,Y+26
 2226 0728 2223      		tst r18
 2227 072a 01F0      		breq .L161
1844:../../Source/queue.c **** 		{
1845:../../Source/queue.c **** 			/* Copy the data from the queue. */
1846:../../Source/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2229               	.LM275:
 2230 072c 4C8D      		ldd r20,Y+28
 2231 072e 2E81      		ldd r18,Y+6
 2232 0730 3F81      		ldd r19,Y+7
 2233 0732 240F      		add r18,r20
 2234 0734 311D      		adc r19,__zero_reg__
 2235 0736 3F83      		std Y+7,r19
 2236 0738 2E83      		std Y+6,r18
1847:../../Source/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
 2238               	.LM276:
 2239 073a EA81      		ldd r30,Y+2
 2240 073c FB81      		ldd r31,Y+3
 2241 073e 2E17      		cp r18,r30
 2242 0740 3F07      		cpc r19,r31
 2243 0742 00F0      		brlo .L158
1848:../../Source/queue.c **** 			{
1849:../../Source/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2245               	.LM277:
 2246 0744 2881      		ld r18,Y
 2247 0746 3981      		ldd r19,Y+1
 2248 0748 3F83      		std Y+7,r19
 2249 074a 2E83      		std Y+6,r18
 2250               	.L158:
1850:../../Source/queue.c **** 			}
1851:../../Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 2252               	.LM278:
 2253 074c 2A8D      		ldd r18,Y+26
 2254 074e 2150      		subi r18,lo8(-(-1))
 2255 0750 2A8F      		std Y+26,r18
1852:../../Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
 2257               	.LM279:
 2258 0752 6E81      		ldd r22,Y+6
 2259 0754 7F81      		ldd r23,Y+7
 2260 0756 50E0      		ldi r21,0
 2261 0758 0E94 0000 		call memcpy
1853:../../Source/queue.c **** 
1854:../../Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
 2263               	.LM280:
 2264 075c F801      		movw r30,r16
 2265 075e 8081      		ld r24,Z
 2266 0760 8823      		tst r24
 2267 0762 01F0      		breq .L159
 2268               	.L160:
1855:../../Source/queue.c **** 			{
1856:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1857:../../Source/queue.c **** 				{
1858:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1859:../../Source/queue.c **** 					{
1860:../../Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
1861:../../Source/queue.c **** 					}
1862:../../Source/queue.c **** 				}
1863:../../Source/queue.c **** 			}
1864:../../Source/queue.c **** 
1865:../../Source/queue.c **** 			xReturn = pdPASS;
 2270               	.LM281:
 2271 0764 81E0      		ldi r24,lo8(1)
 2272 0766 00C0      		rjmp .L157
 2273               	.L159:
1856:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2275               	.LM282:
 2276 0768 8885      		ldd r24,Y+8
 2277 076a 8823      		tst r24
 2278 076c 01F0      		breq .L160
1858:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2280               	.LM283:
 2281 076e CE01      		movw r24,r28
 2282 0770 0896      		adiw r24,8
 2283 0772 0E94 0000 		call xCoRoutineRemoveFromEventList
 2284 0776 8823      		tst r24
 2285 0778 01F0      		breq .L160
1860:../../Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
 2287               	.LM284:
 2288 077a 81E0      		ldi r24,lo8(1)
 2289 077c F801      		movw r30,r16
 2290 077e 8083      		st Z,r24
 2291 0780 00C0      		rjmp .L157
 2292               	.L161:
1866:../../Source/queue.c **** 		}
1867:../../Source/queue.c **** 		else
1868:../../Source/queue.c **** 		{
1869:../../Source/queue.c **** 			xReturn = pdFAIL;
 2294               	.LM285:
 2295 0782 80E0      		ldi r24,0
 2296               	.L157:
 2297               	/* epilogue start */
1870:../../Source/queue.c **** 		}
1871:../../Source/queue.c **** 
1872:../../Source/queue.c **** 		return xReturn;
1873:../../Source/queue.c **** 	}
 2299               	.LM286:
 2300 0784 DF91      		pop r29
 2301 0786 CF91      		pop r28
 2302 0788 1F91      		pop r17
 2303 078a 0F91      		pop r16
 2304 078c 0895      		ret
 2309               	.Lscope20:
 2311               		.stabd	78,0,0
 2313               	.Letext0:
 2314               		.ident	"GCC: (GNU) 4.7.2"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
     /tmp/ccnxNshT.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccnxNshT.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccnxNshT.s:4      *ABS*:0000003f __SREG__
     /tmp/ccnxNshT.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccnxNshT.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccnxNshT.s:135    .text:00000000 prvCopyDataToQueue
     /tmp/ccnxNshT.s:258    .text:00000092 prvCopyDataFromQueue
     /tmp/ccnxNshT.s:325    .text:000000d2 prvUnlockQueue
     /tmp/ccnxNshT.s:478    .text:0000014e xQueueGenericReset
     /tmp/ccnxNshT.s:605    .text:000001cc xQueueGenericCreate
     /tmp/ccnxNshT.s:698    .text:00000224 xQueueGenericSend
     /tmp/ccnxNshT.s:1006   .text:00000354 xQueueGenericSendFromISR
     /tmp/ccnxNshT.s:1105   .text:000003b2 xQueueGenericReceive
     /tmp/ccnxNshT.s:1437   .text:000004fa xQueueReceiveFromISR
     /tmp/ccnxNshT.s:1532   .text:00000556 xQueuePeekFromISR
     /tmp/ccnxNshT.s:1592   .text:00000584 uxQueueMessagesWaiting
     /tmp/ccnxNshT.s:1642   .text:00000594 uxQueueSpacesAvailable
     /tmp/ccnxNshT.s:1694   .text:000005aa uxQueueMessagesWaitingFromISR
     /tmp/ccnxNshT.s:1721   .text:000005b0 vQueueDelete
     /tmp/ccnxNshT.s:1757   .text:000005c8 xQueueIsQueueEmptyFromISR
     /tmp/ccnxNshT.s:1785   .text:000005d4 xQueueIsQueueFullFromISR
     /tmp/ccnxNshT.s:1816   .text:000005e2 xQueueCRSend
     /tmp/ccnxNshT.s:1980   .text:0000064e xQueueCRReceive
     /tmp/ccnxNshT.s:2146   .text:000006da xQueueCRSendFromISR
     /tmp/ccnxNshT.s:2207   .text:00000718 xQueueCRReceiveFromISR

UNDEFINED SYMBOLS
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
vPortYield
vListInitialise
pvPortMalloc
vPortFree
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vCoRoutineAddToDelayedList
xCoRoutineRemoveFromEventList
