   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 127               	prvAddCurrentTaskToDelayedList:
 128               		.stabd	46,0,0
   1:../../Source/tasks.c **** /*
   2:../../Source/tasks.c ****     FreeRTOS V7.6.0 - Copyright (C) 2013 Real Time Engineers Ltd.
   3:../../Source/tasks.c ****     All rights reserved
   4:../../Source/tasks.c **** 
   5:../../Source/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../../Source/tasks.c **** 
   7:../../Source/tasks.c ****     ***************************************************************************
   8:../../Source/tasks.c ****      *                                                                       *
   9:../../Source/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:../../Source/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:../../Source/tasks.c ****      *    platform software that has become a de facto standard.             *
  12:../../Source/tasks.c ****      *                                                                       *
  13:../../Source/tasks.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:../../Source/tasks.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:../../Source/tasks.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:../../Source/tasks.c ****      *                                                                       *
  17:../../Source/tasks.c ****      *    Thank you!                                                         *
  18:../../Source/tasks.c ****      *                                                                       *
  19:../../Source/tasks.c ****     ***************************************************************************
  20:../../Source/tasks.c **** 
  21:../../Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  22:../../Source/tasks.c **** 
  23:../../Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:../../Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:../../Source/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:../../Source/tasks.c **** 
  27:../../Source/tasks.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:../../Source/tasks.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:../../Source/tasks.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:../../Source/tasks.c ****     >>! kernel.
  31:../../Source/tasks.c **** 
  32:../../Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:../../Source/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:../../Source/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:../../Source/tasks.c ****     link: http://www.freertos.org/a00114.html
  36:../../Source/tasks.c **** 
  37:../../Source/tasks.c ****     1 tab == 4 spaces!
  38:../../Source/tasks.c **** 
  39:../../Source/tasks.c ****     ***************************************************************************
  40:../../Source/tasks.c ****      *                                                                       *
  41:../../Source/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:../../Source/tasks.c ****      *    not run, what could be wrong?"                                     *
  43:../../Source/tasks.c ****      *                                                                       *
  44:../../Source/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:../../Source/tasks.c ****      *                                                                       *
  46:../../Source/tasks.c ****     ***************************************************************************
  47:../../Source/tasks.c **** 
  48:../../Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:../../Source/tasks.c ****     license and Real Time Engineers Ltd. contact details.
  50:../../Source/tasks.c **** 
  51:../../Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:../../Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:../../Source/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:../../Source/tasks.c **** 
  55:../../Source/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:../../Source/tasks.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:../../Source/tasks.c ****     licenses offer ticketed support, indemnification and middleware.
  58:../../Source/tasks.c **** 
  59:../../Source/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:../../Source/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  61:../../Source/tasks.c ****     mission critical applications that require provable dependability.
  62:../../Source/tasks.c **** 
  63:../../Source/tasks.c ****     1 tab == 4 spaces!
  64:../../Source/tasks.c **** */
  65:../../Source/tasks.c **** 
  66:../../Source/tasks.c **** /* Standard includes. */
  67:../../Source/tasks.c **** #include <stdlib.h>
  68:../../Source/tasks.c **** #include <string.h>
  69:../../Source/tasks.c **** 
  70:../../Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  71:../../Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  72:../../Source/tasks.c **** task.h is included from an application file. */
  73:../../Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  74:../../Source/tasks.c **** 
  75:../../Source/tasks.c **** /* FreeRTOS includes. */
  76:../../Source/tasks.c **** #include "FreeRTOS.h"
  77:../../Source/tasks.c **** #include "task.h"
  78:../../Source/tasks.c **** #include "timers.h"
  79:../../Source/tasks.c **** #include "StackMacros.h"
  80:../../Source/tasks.c **** 
  81:../../Source/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  82:../../Source/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  83:../../Source/tasks.c **** header files above, but not in this file, in order to generate the correct
  84:../../Source/tasks.c **** privileged Vs unprivileged linkage and placement. */
  85:../../Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  86:../../Source/tasks.c **** 
  87:../../Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  88:../../Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  89:../../Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  90:../../Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  91:../../Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  92:../../Source/tasks.c **** 	#include <stdio.h>
  93:../../Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  94:../../Source/tasks.c **** 
  95:../../Source/tasks.c **** /* Sanity check the configuration. */
  96:../../Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
  97:../../Source/tasks.c **** 	#if INCLUDE_vTaskSuspend != 1
  98:../../Source/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
  99:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
 100:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 101:../../Source/tasks.c **** 
 102:../../Source/tasks.c **** /*
 103:../../Source/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 104:../../Source/tasks.c ****  */
 105:../../Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 106:../../Source/tasks.c **** 
 107:../../Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 108:../../Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 109:../../Source/tasks.c **** 	performed just because a higher priority task has been woken. */
 110:../../Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 111:../../Source/tasks.c **** #else
 112:../../Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 113:../../Source/tasks.c **** #endif
 114:../../Source/tasks.c **** 
 115:../../Source/tasks.c **** /*
 116:../../Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 117:../../Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 118:../../Source/tasks.c ****  * (the task's run time environment, including register values)
 119:../../Source/tasks.c ****  */
 120:../../Source/tasks.c **** typedef struct tskTaskControlBlock
 121:../../Source/tasks.c **** {
 122:../../Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
 123:../../Source/tasks.c **** 
 124:../../Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 125:../../Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
 126:../../Source/tasks.c **** 	#endif
 127:../../Source/tasks.c **** 
 128:../../Source/tasks.c **** 	xListItem				xGenericListItem;	/*< The list that the state list item of a task is reference from d
 129:../../Source/tasks.c **** 	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
 130:../../Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 131:../../Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
 132:../../Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
 133:../../Source/tasks.c **** 
 134:../../Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 135:../../Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the sta
 136:../../Source/tasks.c **** 	#endif
 137:../../Source/tasks.c **** 
 138:../../Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 139:../../Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports 
 140:../../Source/tasks.c **** 	#endif
 141:../../Source/tasks.c **** 
 142:../../Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 143:../../Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is create
 144:../../Source/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party tra
 145:../../Source/tasks.c **** 	#endif
 146:../../Source/tasks.c **** 
 147:../../Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 148:../../Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 149:../../Source/tasks.c **** 	#endif
 150:../../Source/tasks.c **** 
 151:../../Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 152:../../Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 153:../../Source/tasks.c **** 	#endif
 154:../../Source/tasks.c **** 
 155:../../Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 156:../../Source/tasks.c **** 		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running
 157:../../Source/tasks.c **** 	#endif
 158:../../Source/tasks.c **** 
 159:../../Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 160:../../Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 161:../../Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 162:../../Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 163:../../Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 164:../../Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 165:../../Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 166:../../Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 167:../../Source/tasks.c **** 		struct _reent xNewLib_reent;
 168:../../Source/tasks.c **** 	#endif
 169:../../Source/tasks.c **** 
 170:../../Source/tasks.c **** } tskTCB;
 171:../../Source/tasks.c **** 
 172:../../Source/tasks.c **** 
 173:../../Source/tasks.c **** /*
 174:../../Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 175:../../Source/tasks.c ****  * be global, rather than file scope.
 176:../../Source/tasks.c ****  */
 177:../../Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 178:../../Source/tasks.c **** 	#define static
 179:../../Source/tasks.c **** #endif
 180:../../Source/tasks.c **** 
 181:../../Source/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 182:../../Source/tasks.c **** static variables must be declared volatile. */
 183:../../Source/tasks.c **** 
 184:../../Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 185:../../Source/tasks.c **** 
 186:../../Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 187:../../Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 188:../../Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 189:../../Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 190:../../Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList;				/*< Points to the delayed task list c
 191:../../Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 192:../../Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 193:../../Source/tasks.c **** 
 194:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 195:../../Source/tasks.c **** 
 196:../../Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 197:../../Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 198:../../Source/tasks.c **** 
 199:../../Source/tasks.c **** #endif
 200:../../Source/tasks.c **** 
 201:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 202:../../Source/tasks.c **** 
 203:../../Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 204:../../Source/tasks.c **** 
 205:../../Source/tasks.c **** #endif
 206:../../Source/tasks.c **** 
 207:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 208:../../Source/tasks.c **** 
 209:../../Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task
 210:../../Source/tasks.c **** 
 211:../../Source/tasks.c **** #endif
 212:../../Source/tasks.c **** 
 213:../../Source/tasks.c **** /* Other file private variables. --------------------------------*/
 214:../../Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 215:../../Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 216:../../Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 217:../../Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 218:../../Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 219:../../Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxPendedTicks 			= ( unsigned portBASE_TYPE 
 220:../../Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xYieldPending 					= pdFALSE;
 221:../../Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 222:../../Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 223:../../Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= portMAX_DELAY;
 224:../../Source/tasks.c **** 
 225:../../Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 226:../../Source/tasks.c **** 
 227:../../Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 228:../../Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTotalRunTime = 0UL;			/*< Holds the total amount of executi
 229:../../Source/tasks.c **** 
 230:../../Source/tasks.c **** #endif
 231:../../Source/tasks.c **** 
 232:../../Source/tasks.c **** /*lint +e956 */
 233:../../Source/tasks.c **** 
 234:../../Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 235:../../Source/tasks.c **** 
 236:../../Source/tasks.c **** /*
 237:../../Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 238:../../Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 239:../../Source/tasks.c ****  */
 240:../../Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 241:../../Source/tasks.c **** 
 242:../../Source/tasks.c **** /*
 243:../../Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 244:../../Source/tasks.c ****  */
 245:../../Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 246:../../Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 247:../../Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 248:../../Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 249:../../Source/tasks.c **** 
 250:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 251:../../Source/tasks.c **** 
 252:../../Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 253:../../Source/tasks.c **** 
 254:../../Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 255:../../Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 256:../../Source/tasks.c **** 	microcontroller architecture. */
 257:../../Source/tasks.c **** 
 258:../../Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 259:../../Source/tasks.c **** 	state task. */
 260:../../Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
 261:../../Source/tasks.c **** 	{																													\
 262:../../Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )																		\
 263:../../Source/tasks.c **** 		{																												\
 264:../../Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );																		\
 265:../../Source/tasks.c **** 		}																												\
 266:../../Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 267:../../Source/tasks.c **** 
 268:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 269:../../Source/tasks.c **** 
 270:../../Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
 271:../../Source/tasks.c **** 	{																													\
 272:../../Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */												\
 273:../../Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
 274:../../Source/tasks.c **** 		{																												\
 275:../../Source/tasks.c **** 			configASSERT( uxTopReadyPriority );																			\
 276:../../Source/tasks.c **** 			--uxTopReadyPriority;																						\
 277:../../Source/tasks.c **** 		}																												\
 278:../../Source/tasks.c **** 																														\
 279:../../Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
 280:../../Source/tasks.c **** 		the	same priority get an equal share of the processor time. */													\
 281:../../Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
 282:../../Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 283:../../Source/tasks.c **** 
 284:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 285:../../Source/tasks.c **** 
 286:../../Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 287:../../Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 288:../../Source/tasks.c **** 	being used. */
 289:../../Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 290:../../Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 291:../../Source/tasks.c **** 
 292:../../Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 293:../../Source/tasks.c **** 
 294:../../Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 295:../../Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 296:../../Source/tasks.c **** 	architecture being used. */
 297:../../Source/tasks.c **** 
 298:../../Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 299:../../Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 300:../../Source/tasks.c **** 
 301:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 302:../../Source/tasks.c **** 
 303:../../Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 304:../../Source/tasks.c **** 	{																								\
 305:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTopPriority;															\
 306:../../Source/tasks.c **** 																									\
 307:../../Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 308:../../Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 309:../../Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 310:../../Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 311:../../Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 312:../../Source/tasks.c **** 
 313:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 314:../../Source/tasks.c **** 
 315:../../Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 316:../../Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 317:../../Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 318:../../Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 319:../../Source/tasks.c **** 	{																								\
 320:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 321:../../Source/tasks.c **** 		{																							\
 322:../../Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 323:../../Source/tasks.c **** 		}																							\
 324:../../Source/tasks.c **** 	}
 325:../../Source/tasks.c **** 
 326:../../Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 327:../../Source/tasks.c **** 
 328:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 329:../../Source/tasks.c **** 
 330:../../Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 331:../../Source/tasks.c **** count overflows. */
 332:../../Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 333:../../Source/tasks.c **** {																									\
 334:../../Source/tasks.c **** 	xList *pxTemp;																					\
 335:../../Source/tasks.c **** 																									\
 336:../../Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 337:../../Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 338:../../Source/tasks.c **** 																									\
 339:../../Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 340:../../Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 341:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 342:../../Source/tasks.c **** 	xNumOfOverflows++;																				\
 343:../../Source/tasks.c **** 																									\
 344:../../Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )											\
 345:../../Source/tasks.c **** 	{																								\
 346:../../Source/tasks.c **** 		/* The new current delayed list is empty.  Set												\
 347:../../Source/tasks.c **** 		xNextTaskUnblockTime to the maximum possible value so it is									\
 348:../../Source/tasks.c **** 		extremely unlikely that the																	\
 349:../../Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until								\
 350:../../Source/tasks.c **** 		there is an item in the delayed list. */													\
 351:../../Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;														\
 352:../../Source/tasks.c **** 	}																								\
 353:../../Source/tasks.c **** 	else																							\
 354:../../Source/tasks.c **** 	{																								\
 355:../../Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of								\
 356:../../Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at								\
 357:../../Source/tasks.c **** 		which the task at the head of the delayed list should be removed							\
 358:../../Source/tasks.c **** 		from the Blocked state. */																	\
 359:../../Source/tasks.c **** 		pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );						\
 360:../../Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );				\
 361:../../Source/tasks.c **** 	}																								\
 362:../../Source/tasks.c **** }
 363:../../Source/tasks.c **** 
 364:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 365:../../Source/tasks.c **** 
 366:../../Source/tasks.c **** /*
 367:../../Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 368:../../Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 369:../../Source/tasks.c ****  */
 370:../../Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																				\
 371:../../Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
 372:../../Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
 373:../../Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) 
 374:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 375:../../Source/tasks.c **** 
 376:../../Source/tasks.c **** /*
 377:../../Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 378:../../Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 379:../../Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 380:../../Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 381:../../Source/tasks.c ****  */
 382:../../Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 383:../../Source/tasks.c **** 
 384:../../Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 385:../../Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle xTask, signed char *pcTaskName );
 386:../../Source/tasks.c **** extern void vApplicationTickHook( void );
 387:../../Source/tasks.c **** 
 388:../../Source/tasks.c **** /* File private functions. --------------------------------*/
 389:../../Source/tasks.c **** 
 390:../../Source/tasks.c **** /*
 391:../../Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 392:../../Source/tasks.c ****  * into the TCB structure.
 393:../../Source/tasks.c ****  */
 394:../../Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 395:../../Source/tasks.c **** 
 396:../../Source/tasks.c **** /*
 397:../../Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 398:../../Source/tasks.c ****  * automatically upon the creation of the first task.
 399:../../Source/tasks.c ****  */
 400:../../Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 401:../../Source/tasks.c **** 
 402:../../Source/tasks.c **** /*
 403:../../Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 404:../../Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 405:../../Source/tasks.c ****  * creation of the first user task.
 406:../../Source/tasks.c ****  *
 407:../../Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 408:../../Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 409:../../Source/tasks.c ****  *
 410:../../Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 411:../../Source/tasks.c ****  *
 412:../../Source/tasks.c ****  */
 413:../../Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 414:../../Source/tasks.c **** 
 415:../../Source/tasks.c **** /*
 416:../../Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 417:../../Source/tasks.c ****  * including the stack pointed to by the TCB.
 418:../../Source/tasks.c ****  *
 419:../../Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 420:../../Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 421:../../Source/tasks.c ****  */
 422:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 423:../../Source/tasks.c **** 
 424:../../Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 425:../../Source/tasks.c **** 
 426:../../Source/tasks.c **** #endif
 427:../../Source/tasks.c **** 
 428:../../Source/tasks.c **** /*
 429:../../Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 430:../../Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 431:../../Source/tasks.c ****  * and its TCB deleted.
 432:../../Source/tasks.c ****  */
 433:../../Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 434:../../Source/tasks.c **** 
 435:../../Source/tasks.c **** /*
 436:../../Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 437:../../Source/tasks.c ****  * either the current or the overflow delayed task list.
 438:../../Source/tasks.c ****  */
 439:../../Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 440:../../Source/tasks.c **** 
 441:../../Source/tasks.c **** /*
 442:../../Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 443:../../Source/tasks.c ****  * allocation was successful.
 444:../../Source/tasks.c ****  */
 445:../../Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 446:../../Source/tasks.c **** 
 447:../../Source/tasks.c **** /*
 448:../../Source/tasks.c ****  * Fills an xTaskStatusType structure with information on each task that is
 449:../../Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 450:../../Source/tasks.c ****  * a suspended list, etc.).
 451:../../Source/tasks.c ****  *
 452:../../Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 453:../../Source/tasks.c ****  * NORMAL APPLICATION CODE.
 454:../../Source/tasks.c ****  */
 455:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 456:../../Source/tasks.c **** 
 457:../../Source/tasks.c **** 	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xLi
 458:../../Source/tasks.c **** 
 459:../../Source/tasks.c **** #endif
 460:../../Source/tasks.c **** 
 461:../../Source/tasks.c **** /*
 462:../../Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 463:../../Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 464:../../Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 465:../../Source/tasks.c ****  */
 466:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 467:../../Source/tasks.c **** 
 468:../../Source/tasks.c **** 	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_
 469:../../Source/tasks.c **** 
 470:../../Source/tasks.c **** #endif
 471:../../Source/tasks.c **** 
 472:../../Source/tasks.c **** /*
 473:../../Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 474:../../Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 475:../../Source/tasks.c ****  *
 476:../../Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 477:../../Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 478:../../Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 479:../../Source/tasks.c ****  * set to a value other than 1.
 480:../../Source/tasks.c ****  */
 481:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 482:../../Source/tasks.c **** 
 483:../../Source/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 484:../../Source/tasks.c **** 
 485:../../Source/tasks.c **** #endif
 486:../../Source/tasks.c **** 
 487:../../Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 488:../../Source/tasks.c **** {
 489:../../Source/tasks.c **** signed portBASE_TYPE xReturn;
 490:../../Source/tasks.c **** tskTCB * pxNewTCB;
 491:../../Source/tasks.c **** 
 492:../../Source/tasks.c **** 	configASSERT( pxTaskCode );
 493:../../Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 494:../../Source/tasks.c **** 
 495:../../Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 496:../../Source/tasks.c **** 	checking that the allocation was successful. */
 497:../../Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 498:../../Source/tasks.c **** 
 499:../../Source/tasks.c **** 	if( pxNewTCB != NULL )
 500:../../Source/tasks.c **** 	{
 501:../../Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 502:../../Source/tasks.c **** 
 503:../../Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 504:../../Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 505:../../Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 506:../../Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 507:../../Source/tasks.c **** 			{
 508:../../Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 509:../../Source/tasks.c **** 			}
 510:../../Source/tasks.c **** 			else
 511:../../Source/tasks.c **** 			{
 512:../../Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 513:../../Source/tasks.c **** 			}
 514:../../Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 515:../../Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 516:../../Source/tasks.c **** 
 517:../../Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 518:../../Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 519:../../Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 520:../../Source/tasks.c **** 		required by the port. */
 521:../../Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 522:../../Source/tasks.c **** 		{
 523:../../Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 524:../../Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 525:../../Source/tasks.c **** 
 526:../../Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 527:../../Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 528:../../Source/tasks.c **** 		}
 529:../../Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 530:../../Source/tasks.c **** 		{
 531:../../Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 532:../../Source/tasks.c **** 
 533:../../Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 534:../../Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 535:../../Source/tasks.c **** 
 536:../../Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 537:../../Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 538:../../Source/tasks.c **** 			other extreme of the stack space. */
 539:../../Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 540:../../Source/tasks.c **** 		}
 541:../../Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 542:../../Source/tasks.c **** 
 543:../../Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 544:../../Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 545:../../Source/tasks.c **** 
 546:../../Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 547:../../Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 548:../../Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 549:../../Source/tasks.c **** 		the	top of stack variable is updated. */
 550:../../Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 551:../../Source/tasks.c **** 		{
 552:../../Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 553:../../Source/tasks.c **** 		}
 554:../../Source/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 555:../../Source/tasks.c **** 		{
 556:../../Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 557:../../Source/tasks.c **** 		}
 558:../../Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 559:../../Source/tasks.c **** 
 560:../../Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 561:../../Source/tasks.c **** 		{
 562:../../Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 563:../../Source/tasks.c **** 			task can use this as a handle to delete the task later if
 564:../../Source/tasks.c **** 			required.*/
 565:../../Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 566:../../Source/tasks.c **** 		}
 567:../../Source/tasks.c **** 
 568:../../Source/tasks.c **** 		/* Ensure interrupts don't access the task lists while they are being
 569:../../Source/tasks.c **** 		updated. */
 570:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 571:../../Source/tasks.c **** 		{
 572:../../Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 573:../../Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 574:../../Source/tasks.c **** 			{
 575:../../Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 576:../../Source/tasks.c **** 				the suspended state - make this the current task. */
 577:../../Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 578:../../Source/tasks.c **** 
 579:../../Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 580:../../Source/tasks.c **** 				{
 581:../../Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 582:../../Source/tasks.c **** 					initialisation required.  We will not recover if this call
 583:../../Source/tasks.c **** 					fails, but we will report the failure. */
 584:../../Source/tasks.c **** 					prvInitialiseTaskLists();
 585:../../Source/tasks.c **** 				}
 586:../../Source/tasks.c **** 			}
 587:../../Source/tasks.c **** 			else
 588:../../Source/tasks.c **** 			{
 589:../../Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 590:../../Source/tasks.c **** 				current task if it is the highest priority task to be created
 591:../../Source/tasks.c **** 				so far. */
 592:../../Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 593:../../Source/tasks.c **** 				{
 594:../../Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 595:../../Source/tasks.c **** 					{
 596:../../Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 597:../../Source/tasks.c **** 					}
 598:../../Source/tasks.c **** 				}
 599:../../Source/tasks.c **** 			}
 600:../../Source/tasks.c **** 
 601:../../Source/tasks.c **** 			uxTaskNumber++;
 602:../../Source/tasks.c **** 
 603:../../Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 604:../../Source/tasks.c **** 			{
 605:../../Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 606:../../Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 607:../../Source/tasks.c **** 			}
 608:../../Source/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 609:../../Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 610:../../Source/tasks.c **** 
 611:../../Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 612:../../Source/tasks.c **** 
 613:../../Source/tasks.c **** 			xReturn = pdPASS;
 614:../../Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 615:../../Source/tasks.c **** 		}
 616:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
 617:../../Source/tasks.c **** 	}
 618:../../Source/tasks.c **** 	else
 619:../../Source/tasks.c **** 	{
 620:../../Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 621:../../Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 622:../../Source/tasks.c **** 	}
 623:../../Source/tasks.c **** 
 624:../../Source/tasks.c **** 	if( xReturn == pdPASS )
 625:../../Source/tasks.c **** 	{
 626:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 627:../../Source/tasks.c **** 		{
 628:../../Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 629:../../Source/tasks.c **** 			then it should run now. */
 630:../../Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 631:../../Source/tasks.c **** 			{
 632:../../Source/tasks.c **** 				taskYIELD_IF_USING_PREEMPTION();
 633:../../Source/tasks.c **** 			}
 634:../../Source/tasks.c **** 		}
 635:../../Source/tasks.c **** 	}
 636:../../Source/tasks.c **** 
 637:../../Source/tasks.c **** 	return xReturn;
 638:../../Source/tasks.c **** }
 639:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 640:../../Source/tasks.c **** 
 641:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 642:../../Source/tasks.c **** 
 643:../../Source/tasks.c **** 	void vTaskDelete( xTaskHandle xTaskToDelete )
 644:../../Source/tasks.c **** 	{
 645:../../Source/tasks.c **** 	tskTCB *pxTCB;
 646:../../Source/tasks.c **** 
 647:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 648:../../Source/tasks.c **** 		{
 649:../../Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 650:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 651:../../Source/tasks.c **** 
 652:../../Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 653:../../Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 654:../../Source/tasks.c **** 			the termination list and free up any memory allocated by the
 655:../../Source/tasks.c **** 			scheduler for the TCB and stack. */
 656:../../Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 657:../../Source/tasks.c **** 			{
 658:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 659:../../Source/tasks.c **** 			}
 660:../../Source/tasks.c **** 
 661:../../Source/tasks.c **** 			/* Is the task waiting on an event also? */
 662:../../Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 663:../../Source/tasks.c **** 			{
 664:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 665:../../Source/tasks.c **** 			}
 666:../../Source/tasks.c **** 
 667:../../Source/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 668:../../Source/tasks.c **** 
 669:../../Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 670:../../Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 671:../../Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 672:../../Source/tasks.c **** 			++uxTasksDeleted;
 673:../../Source/tasks.c **** 
 674:../../Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 675:../../Source/tasks.c **** 			can detect that the task lists need re-generating. */
 676:../../Source/tasks.c **** 			uxTaskNumber++;
 677:../../Source/tasks.c **** 
 678:../../Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 679:../../Source/tasks.c **** 		}
 680:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
 681:../../Source/tasks.c **** 
 682:../../Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 683:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 684:../../Source/tasks.c **** 		{
 685:../../Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 686:../../Source/tasks.c **** 			{
 687:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
 688:../../Source/tasks.c **** 			}
 689:../../Source/tasks.c **** 		}
 690:../../Source/tasks.c **** 	}
 691:../../Source/tasks.c **** 
 692:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 693:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 694:../../Source/tasks.c **** 
 695:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 696:../../Source/tasks.c **** 
 697:../../Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 698:../../Source/tasks.c **** 	{
 699:../../Source/tasks.c **** 	portTickType xTimeToWake;
 700:../../Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 701:../../Source/tasks.c **** 
 702:../../Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 703:../../Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 704:../../Source/tasks.c **** 
 705:../../Source/tasks.c **** 		vTaskSuspendAll();
 706:../../Source/tasks.c **** 		{
 707:../../Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
 708:../../Source/tasks.c **** 			block. */
 709:../../Source/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
 710:../../Source/tasks.c **** 
 711:../../Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 712:../../Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 713:../../Source/tasks.c **** 
 714:../../Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 715:../../Source/tasks.c **** 			{
 716:../../Source/tasks.c **** 				/* The tick count has overflowed since this function was
 717:../../Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 718:../../Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 719:../../Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 720:../../Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 721:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 722:../../Source/tasks.c **** 				{
 723:../../Source/tasks.c **** 					xShouldDelay = pdTRUE;
 724:../../Source/tasks.c **** 				}
 725:../../Source/tasks.c **** 			}
 726:../../Source/tasks.c **** 			else
 727:../../Source/tasks.c **** 			{
 728:../../Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 729:../../Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 730:../../Source/tasks.c **** 				tick time is less than the wake time. */
 731:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 732:../../Source/tasks.c **** 				{
 733:../../Source/tasks.c **** 					xShouldDelay = pdTRUE;
 734:../../Source/tasks.c **** 				}
 735:../../Source/tasks.c **** 			}
 736:../../Source/tasks.c **** 
 737:../../Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 738:../../Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 739:../../Source/tasks.c **** 
 740:../../Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 741:../../Source/tasks.c **** 			{
 742:../../Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 743:../../Source/tasks.c **** 
 744:../../Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 745:../../Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 746:../../Source/tasks.c **** 				both lists. */
 747:../../Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 748:../../Source/tasks.c **** 				{
 749:../../Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 750:../../Source/tasks.c **** 					no need to check, and the port reset macro can be called
 751:../../Source/tasks.c **** 					directly. */
 752:../../Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 753:../../Source/tasks.c **** 				}
 754:../../Source/tasks.c **** 
 755:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 756:../../Source/tasks.c **** 			}
 757:../../Source/tasks.c **** 		}
 758:../../Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 759:../../Source/tasks.c **** 
 760:../../Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 761:../../Source/tasks.c **** 		have put ourselves to sleep. */
 762:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 763:../../Source/tasks.c **** 		{
 764:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
 765:../../Source/tasks.c **** 		}
 766:../../Source/tasks.c **** 	}
 767:../../Source/tasks.c **** 
 768:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 769:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 770:../../Source/tasks.c **** 
 771:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 772:../../Source/tasks.c **** 
 773:../../Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 774:../../Source/tasks.c **** 	{
 775:../../Source/tasks.c **** 	portTickType xTimeToWake;
 776:../../Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 777:../../Source/tasks.c **** 
 778:../../Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 779:../../Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 780:../../Source/tasks.c **** 		{
 781:../../Source/tasks.c **** 			vTaskSuspendAll();
 782:../../Source/tasks.c **** 			{
 783:../../Source/tasks.c **** 				traceTASK_DELAY();
 784:../../Source/tasks.c **** 
 785:../../Source/tasks.c **** 				/* A task that is removed from the event list while the
 786:../../Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 787:../../Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 788:../../Source/tasks.c **** 				is resumed.
 789:../../Source/tasks.c **** 
 790:../../Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 791:../../Source/tasks.c **** 				executing task. */
 792:../../Source/tasks.c **** 
 793:../../Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 794:../../Source/tasks.c **** 				not a problem. */
 795:../../Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 796:../../Source/tasks.c **** 
 797:../../Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 798:../../Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 799:../../Source/tasks.c **** 				both lists. */
 800:../../Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 801:../../Source/tasks.c **** 				{
 802:../../Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 803:../../Source/tasks.c **** 					no need to check, and the port reset macro can be called
 804:../../Source/tasks.c **** 					directly. */
 805:../../Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 806:../../Source/tasks.c **** 				}
 807:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 808:../../Source/tasks.c **** 			}
 809:../../Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 810:../../Source/tasks.c **** 		}
 811:../../Source/tasks.c **** 
 812:../../Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 813:../../Source/tasks.c **** 		have put ourselves to sleep. */
 814:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 815:../../Source/tasks.c **** 		{
 816:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
 817:../../Source/tasks.c **** 		}
 818:../../Source/tasks.c **** 	}
 819:../../Source/tasks.c **** 
 820:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 821:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 822:../../Source/tasks.c **** 
 823:../../Source/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 824:../../Source/tasks.c **** 
 825:../../Source/tasks.c **** 	eTaskState eTaskGetState( xTaskHandle xTask )
 826:../../Source/tasks.c **** 	{
 827:../../Source/tasks.c **** 	eTaskState eReturn;
 828:../../Source/tasks.c **** 	xList *pxStateList;
 829:../../Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 830:../../Source/tasks.c **** 
 831:../../Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 832:../../Source/tasks.c **** 		{
 833:../../Source/tasks.c **** 			/* The task calling this function is querying its own state. */
 834:../../Source/tasks.c **** 			eReturn = eRunning;
 835:../../Source/tasks.c **** 		}
 836:../../Source/tasks.c **** 		else
 837:../../Source/tasks.c **** 		{
 838:../../Source/tasks.c **** 			taskENTER_CRITICAL();
 839:../../Source/tasks.c **** 			{
 840:../../Source/tasks.c **** 				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 841:../../Source/tasks.c **** 			}
 842:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
 843:../../Source/tasks.c **** 
 844:../../Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 845:../../Source/tasks.c **** 			{
 846:../../Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 847:../../Source/tasks.c **** 				lists. */
 848:../../Source/tasks.c **** 				eReturn = eBlocked;
 849:../../Source/tasks.c **** 			}
 850:../../Source/tasks.c **** 
 851:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 852:../../Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 853:../../Source/tasks.c **** 				{
 854:../../Source/tasks.c **** 					/* The task being queried is referenced from the suspended
 855:../../Source/tasks.c **** 					list.  Is it genuinely suspended or is it block
 856:../../Source/tasks.c **** 					indefinitely? */
 857:../../Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 858:../../Source/tasks.c **** 					{
 859:../../Source/tasks.c **** 						eReturn = eSuspended;
 860:../../Source/tasks.c **** 					}
 861:../../Source/tasks.c **** 					else
 862:../../Source/tasks.c **** 					{
 863:../../Source/tasks.c **** 						eReturn = eBlocked;
 864:../../Source/tasks.c **** 					}
 865:../../Source/tasks.c **** 				}
 866:../../Source/tasks.c **** 			#endif
 867:../../Source/tasks.c **** 
 868:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 869:../../Source/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 870:../../Source/tasks.c **** 				{
 871:../../Source/tasks.c **** 					/* The task being queried is referenced from the deleted
 872:../../Source/tasks.c **** 					tasks list. */
 873:../../Source/tasks.c **** 					eReturn = eDeleted;
 874:../../Source/tasks.c **** 				}
 875:../../Source/tasks.c **** 			#endif
 876:../../Source/tasks.c **** 
 877:../../Source/tasks.c **** 			else
 878:../../Source/tasks.c **** 			{
 879:../../Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
 880:../../Source/tasks.c **** 				Ready (including pending ready) state. */
 881:../../Source/tasks.c **** 				eReturn = eReady;
 882:../../Source/tasks.c **** 			}
 883:../../Source/tasks.c **** 		}
 884:../../Source/tasks.c **** 
 885:../../Source/tasks.c **** 		return eReturn;
 886:../../Source/tasks.c **** 	}
 887:../../Source/tasks.c **** 
 888:../../Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
 889:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 890:../../Source/tasks.c **** 
 891:../../Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 892:../../Source/tasks.c **** 
 893:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
 894:../../Source/tasks.c **** 	{
 895:../../Source/tasks.c **** 	tskTCB *pxTCB;
 896:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 897:../../Source/tasks.c **** 
 898:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 899:../../Source/tasks.c **** 		{
 900:../../Source/tasks.c **** 			/* If null is passed in here then we are changing the
 901:../../Source/tasks.c **** 			priority of the calling function. */
 902:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 903:../../Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 904:../../Source/tasks.c **** 		}
 905:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
 906:../../Source/tasks.c **** 
 907:../../Source/tasks.c **** 		return uxReturn;
 908:../../Source/tasks.c **** 	}
 909:../../Source/tasks.c **** 
 910:../../Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
 911:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 912:../../Source/tasks.c **** 
 913:../../Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 914:../../Source/tasks.c **** 
 915:../../Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
 916:../../Source/tasks.c **** 	{
 917:../../Source/tasks.c **** 	tskTCB *pxTCB;
 918:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
 919:../../Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 920:../../Source/tasks.c **** 
 921:../../Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 922:../../Source/tasks.c **** 
 923:../../Source/tasks.c **** 		/* Ensure the new priority is valid. */
 924:../../Source/tasks.c **** 		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
 925:../../Source/tasks.c **** 		{
 926:../../Source/tasks.c **** 			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 927:../../Source/tasks.c **** 		}
 928:../../Source/tasks.c **** 
 929:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 930:../../Source/tasks.c **** 		{
 931:../../Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
 932:../../Source/tasks.c **** 			task that is being changed. */
 933:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 934:../../Source/tasks.c **** 
 935:../../Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 936:../../Source/tasks.c **** 
 937:../../Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 938:../../Source/tasks.c **** 			{
 939:../../Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 940:../../Source/tasks.c **** 			}
 941:../../Source/tasks.c **** 			#else
 942:../../Source/tasks.c **** 			{
 943:../../Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
 944:../../Source/tasks.c **** 			}
 945:../../Source/tasks.c **** 			#endif
 946:../../Source/tasks.c **** 
 947:../../Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 948:../../Source/tasks.c **** 			{
 949:../../Source/tasks.c **** 				/* The priority change may have readied a task of higher
 950:../../Source/tasks.c **** 				priority than the calling task. */
 951:../../Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 952:../../Source/tasks.c **** 				{
 953:../../Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 954:../../Source/tasks.c **** 					{
 955:../../Source/tasks.c **** 						/* The priority of a task other than the currently
 956:../../Source/tasks.c **** 						running task is being raised.  Is the priority being
 957:../../Source/tasks.c **** 						raised above that of the running task? */
 958:../../Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 959:../../Source/tasks.c **** 						{
 960:../../Source/tasks.c **** 							xYieldRequired = pdTRUE;
 961:../../Source/tasks.c **** 						}
 962:../../Source/tasks.c **** 					}
 963:../../Source/tasks.c **** 					else
 964:../../Source/tasks.c **** 					{
 965:../../Source/tasks.c **** 						/* The priority of the running task is being raised,
 966:../../Source/tasks.c **** 						but the running task must already be the highest
 967:../../Source/tasks.c **** 						priority task able to run so no yield is required. */
 968:../../Source/tasks.c **** 					}
 969:../../Source/tasks.c **** 				}
 970:../../Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 971:../../Source/tasks.c **** 				{
 972:../../Source/tasks.c **** 					/* Setting the priority of the running task down means
 973:../../Source/tasks.c **** 					there may now be another task of higher priority that
 974:../../Source/tasks.c **** 					is ready to execute. */
 975:../../Source/tasks.c **** 					xYieldRequired = pdTRUE;
 976:../../Source/tasks.c **** 				}
 977:../../Source/tasks.c **** 				else
 978:../../Source/tasks.c **** 				{
 979:../../Source/tasks.c **** 					/* Setting the priority of any other task down does not
 980:../../Source/tasks.c **** 					require a yield as the running task must be above the
 981:../../Source/tasks.c **** 					new priority of the task being modified. */
 982:../../Source/tasks.c **** 				}
 983:../../Source/tasks.c **** 
 984:../../Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
 985:../../Source/tasks.c **** 				before its uxPriority member is changed so the
 986:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
 987:../../Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 988:../../Source/tasks.c **** 
 989:../../Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 990:../../Source/tasks.c **** 				{
 991:../../Source/tasks.c **** 					/* Only change the priority being used if the task is not
 992:../../Source/tasks.c **** 					currently using an inherited priority. */
 993:../../Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 994:../../Source/tasks.c **** 					{
 995:../../Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 996:../../Source/tasks.c **** 					}
 997:../../Source/tasks.c **** 
 998:../../Source/tasks.c **** 					/* The base priority gets set whatever. */
 999:../../Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1000:../../Source/tasks.c **** 				}
1001:../../Source/tasks.c **** 				#else
1002:../../Source/tasks.c **** 				{
1003:../../Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1004:../../Source/tasks.c **** 				}
1005:../../Source/tasks.c **** 				#endif
1006:../../Source/tasks.c **** 
1007:../../Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - 
1008:../../Source/tasks.c **** 
1009:../../Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1010:../../Source/tasks.c **** 				nothing more than change it's priority variable. However, if
1011:../../Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1012:../../Source/tasks.c **** 				in the list appropriate to its new priority. */
1013:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGeneri
1014:../../Source/tasks.c **** 				{
1015:../../Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1016:../../Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1017:../../Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1018:../../Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
1019:../../Source/tasks.c **** 					{
1020:../../Source/tasks.c **** 						/* It is known that the task is in its ready list so
1021:../../Source/tasks.c **** 						there is no need to check again and the port level
1022:../../Source/tasks.c **** 						reset macro can be called directly. */
1023:../../Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1024:../../Source/tasks.c **** 					}
1025:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1026:../../Source/tasks.c **** 				}
1027:../../Source/tasks.c **** 
1028:../../Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
1029:../../Source/tasks.c **** 				{
1030:../../Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1031:../../Source/tasks.c **** 				}
1032:../../Source/tasks.c **** 
1033:../../Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1034:../../Source/tasks.c **** 				optimised task selection is not being used. */
1035:../../Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1036:../../Source/tasks.c **** 			}
1037:../../Source/tasks.c **** 		}
1038:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1039:../../Source/tasks.c **** 	}
1040:../../Source/tasks.c **** 
1041:../../Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1042:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1043:../../Source/tasks.c **** 
1044:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1045:../../Source/tasks.c **** 
1046:../../Source/tasks.c **** 	void vTaskSuspend( xTaskHandle xTaskToSuspend )
1047:../../Source/tasks.c **** 	{
1048:../../Source/tasks.c **** 	tskTCB *pxTCB;
1049:../../Source/tasks.c **** 
1050:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1051:../../Source/tasks.c **** 		{
1052:../../Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1053:../../Source/tasks.c **** 			being suspended. */
1054:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1055:../../Source/tasks.c **** 
1056:../../Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1057:../../Source/tasks.c **** 
1058:../../Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
1059:../../Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
1060:../../Source/tasks.c **** 			{
1061:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1062:../../Source/tasks.c **** 			}
1063:../../Source/tasks.c **** 
1064:../../Source/tasks.c **** 			/* Is the task waiting on an event also? */
1065:../../Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1066:../../Source/tasks.c **** 			{
1067:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1068:../../Source/tasks.c **** 			}
1069:../../Source/tasks.c **** 
1070:../../Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
1071:../../Source/tasks.c **** 		}
1072:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1073:../../Source/tasks.c **** 
1074:../../Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1075:../../Source/tasks.c **** 		{
1076:../../Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1077:../../Source/tasks.c **** 			{
1078:../../Source/tasks.c **** 				/* The current task has just been suspended. */
1079:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
1080:../../Source/tasks.c **** 			}
1081:../../Source/tasks.c **** 			else
1082:../../Source/tasks.c **** 			{
1083:../../Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1084:../../Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1085:../../Source/tasks.c **** 				must be adjusted to point to a different task. */
1086:../../Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
1087:../../Source/tasks.c **** 				{
1088:../../Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1089:../../Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1090:../../Source/tasks.c **** 					be set to point to it no matter what its relative priority
1091:../../Source/tasks.c **** 					is. */
1092:../../Source/tasks.c **** 					pxCurrentTCB = NULL;
1093:../../Source/tasks.c **** 				}
1094:../../Source/tasks.c **** 				else
1095:../../Source/tasks.c **** 				{
1096:../../Source/tasks.c **** 					vTaskSwitchContext();
1097:../../Source/tasks.c **** 				}
1098:../../Source/tasks.c **** 			}
1099:../../Source/tasks.c **** 		}
1100:../../Source/tasks.c **** 	}
1101:../../Source/tasks.c **** 
1102:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1103:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1104:../../Source/tasks.c **** 
1105:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1106:../../Source/tasks.c **** 
1107:../../Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
1108:../../Source/tasks.c **** 	{
1109:../../Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
1110:../../Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
1111:../../Source/tasks.c **** 
1112:../../Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1113:../../Source/tasks.c **** 		configASSERT( xTask );
1114:../../Source/tasks.c **** 
1115:../../Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
1116:../../Source/tasks.c **** 		suspended list? */
1117:../../Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
1118:../../Source/tasks.c **** 		{
1119:../../Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1120:../../Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1121:../../Source/tasks.c **** 			{
1122:../../Source/tasks.c **** 				/* Is it in the suspended list because it is in the
1123:../../Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
1124:../../Source/tasks.c **** 				list because it is blocked on a task with no timeout
1125:../../Source/tasks.c **** 				specified. */
1126:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
1127:../../Source/tasks.c **** 				{
1128:../../Source/tasks.c **** 					xReturn = pdTRUE;
1129:../../Source/tasks.c **** 				}
1130:../../Source/tasks.c **** 			}
1131:../../Source/tasks.c **** 		}
1132:../../Source/tasks.c **** 
1133:../../Source/tasks.c **** 		return xReturn;
1134:../../Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1135:../../Source/tasks.c **** 
1136:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1137:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1138:../../Source/tasks.c **** 
1139:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1140:../../Source/tasks.c **** 
1141:../../Source/tasks.c **** 	void vTaskResume( xTaskHandle xTaskToResume )
1142:../../Source/tasks.c **** 	{
1143:../../Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
1144:../../Source/tasks.c **** 
1145:../../Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1146:../../Source/tasks.c **** 		configASSERT( xTaskToResume );
1147:../../Source/tasks.c **** 
1148:../../Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1149:../../Source/tasks.c **** 		currently executing task. */
1150:../../Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1151:../../Source/tasks.c **** 		{
1152:../../Source/tasks.c **** 			taskENTER_CRITICAL();
1153:../../Source/tasks.c **** 			{
1154:../../Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1155:../../Source/tasks.c **** 				{
1156:../../Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1157:../../Source/tasks.c **** 
1158:../../Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1159:../../Source/tasks.c **** 					lists even if the scheduler is suspended. */
1160:../../Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
1161:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1162:../../Source/tasks.c **** 
1163:../../Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1164:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1165:../../Source/tasks.c **** 					{
1166:../../Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1167:../../Source/tasks.c **** 						but will leave the lists in the correct state for the
1168:../../Source/tasks.c **** 						next yield. */
1169:../../Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1170:../../Source/tasks.c **** 					}
1171:../../Source/tasks.c **** 				}
1172:../../Source/tasks.c **** 			}
1173:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
1174:../../Source/tasks.c **** 		}
1175:../../Source/tasks.c **** 	}
1176:../../Source/tasks.c **** 
1177:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1178:../../Source/tasks.c **** 
1179:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1180:../../Source/tasks.c **** 
1181:../../Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1182:../../Source/tasks.c **** 
1183:../../Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
1184:../../Source/tasks.c **** 	{
1185:../../Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
1186:../../Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
1187:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1188:../../Source/tasks.c **** 
1189:../../Source/tasks.c **** 		configASSERT( xTaskToResume );
1190:../../Source/tasks.c **** 
1191:../../Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1192:../../Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1193:../../Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1194:../../Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1195:../../Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1196:../../Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1197:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1198:../../Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1199:../../Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1200:../../Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1201:../../Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1202:../../Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1203:../../Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1204:../../Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1205:../../Source/tasks.c **** 		provided on the following link:
1206:../../Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1207:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1208:../../Source/tasks.c **** 
1209:../../Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1210:../../Source/tasks.c **** 		{
1211:../../Source/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1212:../../Source/tasks.c **** 			{
1213:../../Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1214:../../Source/tasks.c **** 
1215:../../Source/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1216:../../Source/tasks.c **** 				{
1217:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1218:../../Source/tasks.c **** 					{
1219:../../Source/tasks.c **** 						xYieldRequired = pdTRUE;
1220:../../Source/tasks.c **** 					}
1221:../../Source/tasks.c **** 
1222:../../Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
1223:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1224:../../Source/tasks.c **** 				}
1225:../../Source/tasks.c **** 				else
1226:../../Source/tasks.c **** 				{
1227:../../Source/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1228:../../Source/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1229:../../Source/tasks.c **** 					yield will be performed if necessary. */
1230:../../Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1231:../../Source/tasks.c **** 				}
1232:../../Source/tasks.c **** 			}
1233:../../Source/tasks.c **** 		}
1234:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1235:../../Source/tasks.c **** 
1236:../../Source/tasks.c **** 		return xYieldRequired;
1237:../../Source/tasks.c **** 	}
1238:../../Source/tasks.c **** 
1239:../../Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1240:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1241:../../Source/tasks.c **** 
1242:../../Source/tasks.c **** void vTaskStartScheduler( void )
1243:../../Source/tasks.c **** {
1244:../../Source/tasks.c **** portBASE_TYPE xReturn;
1245:../../Source/tasks.c **** 
1246:../../Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1247:../../Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1248:../../Source/tasks.c **** 	{
1249:../../Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1250:../../Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1251:../../Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1252:../../Source/tasks.c **** 	}
1253:../../Source/tasks.c **** 	#else
1254:../../Source/tasks.c **** 	{
1255:../../Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1256:../../Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1257:../../Source/tasks.c **** 	}
1258:../../Source/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1259:../../Source/tasks.c **** 
1260:../../Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1261:../../Source/tasks.c **** 	{
1262:../../Source/tasks.c **** 		if( xReturn == pdPASS )
1263:../../Source/tasks.c **** 		{
1264:../../Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1265:../../Source/tasks.c **** 		}
1266:../../Source/tasks.c **** 	}
1267:../../Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1268:../../Source/tasks.c **** 
1269:../../Source/tasks.c **** 	if( xReturn == pdPASS )
1270:../../Source/tasks.c **** 	{
1271:../../Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1272:../../Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1273:../../Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1274:../../Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1275:../../Source/tasks.c **** 		starts to run. */
1276:../../Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1277:../../Source/tasks.c **** 
1278:../../Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1279:../../Source/tasks.c **** 		{
1280:../../Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1281:../../Source/tasks.c **** 			structure specific to the task that will run first. */
1282:../../Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1283:../../Source/tasks.c **** 		}
1284:../../Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1285:../../Source/tasks.c **** 
1286:../../Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1287:../../Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
1288:../../Source/tasks.c **** 
1289:../../Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1290:../../Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1291:../../Source/tasks.c **** 		the run time counter time base. */
1292:../../Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1293:../../Source/tasks.c **** 
1294:../../Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1295:../../Source/tasks.c **** 		portable interface. */
1296:../../Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
1297:../../Source/tasks.c **** 		{
1298:../../Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1299:../../Source/tasks.c **** 			function will not return. */
1300:../../Source/tasks.c **** 		}
1301:../../Source/tasks.c **** 		else
1302:../../Source/tasks.c **** 		{
1303:../../Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1304:../../Source/tasks.c **** 		}
1305:../../Source/tasks.c **** 	}
1306:../../Source/tasks.c **** 	else
1307:../../Source/tasks.c **** 	{
1308:../../Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1309:../../Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1310:../../Source/tasks.c **** 		or the timer task. */
1311:../../Source/tasks.c **** 		configASSERT( xReturn );
1312:../../Source/tasks.c **** 	}
1313:../../Source/tasks.c **** }
1314:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1315:../../Source/tasks.c **** 
1316:../../Source/tasks.c **** void vTaskEndScheduler( void )
1317:../../Source/tasks.c **** {
1318:../../Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1319:../../Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1320:../../Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1321:../../Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1322:../../Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1323:../../Source/tasks.c **** 	vPortEndScheduler();
1324:../../Source/tasks.c **** }
1325:../../Source/tasks.c **** /*----------------------------------------------------------*/
1326:../../Source/tasks.c **** 
1327:../../Source/tasks.c **** void vTaskSuspendAll( void )
1328:../../Source/tasks.c **** {
1329:../../Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1330:../../Source/tasks.c **** 	portBASE_TYPE. */
1331:../../Source/tasks.c **** 	++uxSchedulerSuspended;
1332:../../Source/tasks.c **** }
1333:../../Source/tasks.c **** /*----------------------------------------------------------*/
1334:../../Source/tasks.c **** 
1335:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1336:../../Source/tasks.c **** 
1337:../../Source/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void )
1338:../../Source/tasks.c **** 	{
1339:../../Source/tasks.c **** 	portTickType xReturn;
1340:../../Source/tasks.c **** 
1341:../../Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1342:../../Source/tasks.c **** 		{
1343:../../Source/tasks.c **** 			xReturn = 0;
1344:../../Source/tasks.c **** 		}
1345:../../Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1346:../../Source/tasks.c **** 		{
1347:../../Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1348:../../Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1349:../../Source/tasks.c **** 			processed. */
1350:../../Source/tasks.c **** 			xReturn = 0;
1351:../../Source/tasks.c **** 		}
1352:../../Source/tasks.c **** 		else
1353:../../Source/tasks.c **** 		{
1354:../../Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1355:../../Source/tasks.c **** 		}
1356:../../Source/tasks.c **** 
1357:../../Source/tasks.c **** 		return xReturn;
1358:../../Source/tasks.c **** 	}
1359:../../Source/tasks.c **** 
1360:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1361:../../Source/tasks.c **** /*----------------------------------------------------------*/
1362:../../Source/tasks.c **** 
1363:../../Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1364:../../Source/tasks.c **** {
1365:../../Source/tasks.c **** tskTCB *pxTCB;
1366:../../Source/tasks.c **** portBASE_TYPE xAlreadyYielded = pdFALSE;
1367:../../Source/tasks.c **** 
1368:../../Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1369:../../Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1370:../../Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1371:../../Source/tasks.c **** 
1372:../../Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1373:../../Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1374:../../Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1375:../../Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1376:../../Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1377:../../Source/tasks.c **** 	taskENTER_CRITICAL();
1378:../../Source/tasks.c **** 	{
1379:../../Source/tasks.c **** 		--uxSchedulerSuspended;
1380:../../Source/tasks.c **** 
1381:../../Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1382:../../Source/tasks.c **** 		{
1383:../../Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
1384:../../Source/tasks.c **** 			{
1385:../../Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1386:../../Source/tasks.c **** 				appropriate ready list. */
1387:../../Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
1388:../../Source/tasks.c **** 				{
1389:../../Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
1390:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1391:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
1392:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1393:../../Source/tasks.c **** 
1394:../../Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1395:../../Source/tasks.c **** 					the current task then we should yield. */
1396:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1397:../../Source/tasks.c **** 					{
1398:../../Source/tasks.c **** 						xYieldPending = pdTRUE;
1399:../../Source/tasks.c **** 					}
1400:../../Source/tasks.c **** 				}
1401:../../Source/tasks.c **** 
1402:../../Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1403:../../Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1404:../../Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1405:../../Source/tasks.c **** 				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
1406:../../Source/tasks.c **** 				{
1407:../../Source/tasks.c **** 					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
1408:../../Source/tasks.c **** 					{
1409:../../Source/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
1410:../../Source/tasks.c **** 						{
1411:../../Source/tasks.c **** 							xYieldPending = pdTRUE;
1412:../../Source/tasks.c **** 						}
1413:../../Source/tasks.c **** 						--uxPendedTicks;
1414:../../Source/tasks.c **** 					}
1415:../../Source/tasks.c **** 				}
1416:../../Source/tasks.c **** 
1417:../../Source/tasks.c **** 				if( xYieldPending == pdTRUE )
1418:../../Source/tasks.c **** 				{
1419:../../Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
1420:../../Source/tasks.c **** 					{
1421:../../Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
1422:../../Source/tasks.c **** 					}
1423:../../Source/tasks.c **** 					#endif
1424:../../Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1425:../../Source/tasks.c **** 				}
1426:../../Source/tasks.c **** 			}
1427:../../Source/tasks.c **** 		}
1428:../../Source/tasks.c **** 	}
1429:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
1430:../../Source/tasks.c **** 
1431:../../Source/tasks.c **** 	return xAlreadyYielded;
1432:../../Source/tasks.c **** }
1433:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1434:../../Source/tasks.c **** 
1435:../../Source/tasks.c **** portTickType xTaskGetTickCount( void )
1436:../../Source/tasks.c **** {
1437:../../Source/tasks.c **** portTickType xTicks;
1438:../../Source/tasks.c **** 
1439:../../Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1440:../../Source/tasks.c **** 	taskENTER_CRITICAL();
1441:../../Source/tasks.c **** 	{
1442:../../Source/tasks.c **** 		xTicks = xTickCount;
1443:../../Source/tasks.c **** 	}
1444:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
1445:../../Source/tasks.c **** 
1446:../../Source/tasks.c **** 	return xTicks;
1447:../../Source/tasks.c **** }
1448:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1449:../../Source/tasks.c **** 
1450:../../Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1451:../../Source/tasks.c **** {
1452:../../Source/tasks.c **** portTickType xReturn;
1453:../../Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1454:../../Source/tasks.c **** 
1455:../../Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1456:../../Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1457:../../Source/tasks.c **** 	above the maximum system call priority are keep permanently enabled, even
1458:../../Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1459:../../Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1460:../../Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1461:../../Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1462:../../Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
1463:../../Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1464:../../Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
1465:../../Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1466:../../Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1467:../../Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
1468:../../Source/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1469:../../Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1470:../../Source/tasks.c **** 
1471:../../Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1472:../../Source/tasks.c **** 	xReturn = xTickCount;
1473:../../Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1474:../../Source/tasks.c **** 
1475:../../Source/tasks.c **** 	return xReturn;
1476:../../Source/tasks.c **** }
1477:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1478:../../Source/tasks.c **** 
1479:../../Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1480:../../Source/tasks.c **** {
1481:../../Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1482:../../Source/tasks.c **** 	portBASE_TYPE. */
1483:../../Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1484:../../Source/tasks.c **** }
1485:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1486:../../Source/tasks.c **** 
1487:../../Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1488:../../Source/tasks.c **** 
1489:../../Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1490:../../Source/tasks.c **** 	{
1491:../../Source/tasks.c **** 	tskTCB *pxTCB;
1492:../../Source/tasks.c **** 
1493:../../Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1494:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1495:../../Source/tasks.c **** 		configASSERT( pxTCB );
1496:../../Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1497:../../Source/tasks.c **** 	}
1498:../../Source/tasks.c **** 
1499:../../Source/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1500:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1501:../../Source/tasks.c **** 
1502:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1503:../../Source/tasks.c **** 
1504:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetSystemState( xTaskStatusType *pxTaskStatusArray, unsigned portBASE
1505:../../Source/tasks.c **** 	{
1506:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTask = 0, uxQueue = configMAX_PRIORITIES;
1507:../../Source/tasks.c **** 
1508:../../Source/tasks.c **** 		vTaskSuspendAll();
1509:../../Source/tasks.c **** 		{
1510:../../Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
1511:../../Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
1512:../../Source/tasks.c **** 			{
1513:../../Source/tasks.c **** 				/* Fill in an xTaskStatusType structure with information on each
1514:../../Source/tasks.c **** 				task in the Ready state. */
1515:../../Source/tasks.c **** 				do
1516:../../Source/tasks.c **** 				{
1517:../../Source/tasks.c **** 					uxQueue--;
1518:../../Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[
1519:../../Source/tasks.c **** 
1520:../../Source/tasks.c **** 				} while( uxQueue > ( unsigned portBASE_TYPE ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception 
1521:../../Source/tasks.c **** 
1522:../../Source/tasks.c **** 				/* Fill in an xTaskStatusType structure with information on each
1523:../../Source/tasks.c **** 				task in the Blocked state. */
1524:../../Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxDelayedT
1525:../../Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxOverflow
1526:../../Source/tasks.c **** 
1527:../../Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
1528:../../Source/tasks.c **** 				{
1529:../../Source/tasks.c **** 					/* Fill in an xTaskStatusType structure with information on
1530:../../Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
1531:../../Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermina
1532:../../Source/tasks.c **** 				}
1533:../../Source/tasks.c **** 				#endif
1534:../../Source/tasks.c **** 
1535:../../Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
1536:../../Source/tasks.c **** 				{
1537:../../Source/tasks.c **** 					/* Fill in an xTaskStatusType structure with information on
1538:../../Source/tasks.c **** 					each task in the Suspended state. */
1539:../../Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, 
1540:../../Source/tasks.c **** 				}
1541:../../Source/tasks.c **** 				#endif
1542:../../Source/tasks.c **** 
1543:../../Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
1544:../../Source/tasks.c **** 				{
1545:../../Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1546:../../Source/tasks.c **** 					{
1547:../../Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1548:../../Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1549:../../Source/tasks.c **** 						#else
1550:../../Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1551:../../Source/tasks.c **** 						#endif
1552:../../Source/tasks.c **** 					}
1553:../../Source/tasks.c **** 				}
1554:../../Source/tasks.c **** 				#else
1555:../../Source/tasks.c **** 				{
1556:../../Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1557:../../Source/tasks.c **** 					{
1558:../../Source/tasks.c **** 						*pulTotalRunTime = 0;
1559:../../Source/tasks.c **** 					}
1560:../../Source/tasks.c **** 				}
1561:../../Source/tasks.c **** 				#endif
1562:../../Source/tasks.c **** 			}
1563:../../Source/tasks.c **** 		}
1564:../../Source/tasks.c **** 		( void ) xTaskResumeAll();
1565:../../Source/tasks.c **** 
1566:../../Source/tasks.c **** 		return uxTask;
1567:../../Source/tasks.c **** 	}
1568:../../Source/tasks.c **** 
1569:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1570:../../Source/tasks.c **** /*----------------------------------------------------------*/
1571:../../Source/tasks.c **** 
1572:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1573:../../Source/tasks.c **** 
1574:../../Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1575:../../Source/tasks.c **** 	{
1576:../../Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1577:../../Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1578:../../Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1579:../../Source/tasks.c **** 		return xIdleTaskHandle;
1580:../../Source/tasks.c **** 	}
1581:../../Source/tasks.c **** 
1582:../../Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1583:../../Source/tasks.c **** /*----------------------------------------------------------*/
1584:../../Source/tasks.c **** 
1585:../../Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1586:../../Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1587:../../Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1588:../../Source/tasks.c **** 1. */
1589:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1590:../../Source/tasks.c **** 
1591:../../Source/tasks.c **** 	void vTaskStepTick( portTickType xTicksToJump )
1592:../../Source/tasks.c **** 	{
1593:../../Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
1594:../../Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
1595:../../Source/tasks.c **** 		each stepped tick. */
1596:../../Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1597:../../Source/tasks.c **** 		xTickCount += xTicksToJump;
1598:../../Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
1599:../../Source/tasks.c **** 	}
1600:../../Source/tasks.c **** 
1601:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1602:../../Source/tasks.c **** /*----------------------------------------------------------*/
1603:../../Source/tasks.c **** 
1604:../../Source/tasks.c **** portBASE_TYPE xTaskIncrementTick( void )
1605:../../Source/tasks.c **** {
1606:../../Source/tasks.c **** tskTCB * pxTCB;
1607:../../Source/tasks.c **** portTickType xItemValue;
1608:../../Source/tasks.c **** portBASE_TYPE xSwitchRequired = pdFALSE;
1609:../../Source/tasks.c **** 
1610:../../Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1611:../../Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1612:../../Source/tasks.c **** 	tasks to be unblocked. */
1613:../../Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1614:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1615:../../Source/tasks.c **** 	{
1616:../../Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
1617:../../Source/tasks.c **** 		delayed lists if it wraps to 0. */
1618:../../Source/tasks.c **** 		++xTickCount;
1619:../../Source/tasks.c **** 
1620:../../Source/tasks.c **** 		{
1621:../../Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1622:../../Source/tasks.c **** 			block. */
1623:../../Source/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
1624:../../Source/tasks.c **** 
1625:../../Source/tasks.c **** 			if( xConstTickCount == ( portTickType ) 0U )
1626:../../Source/tasks.c **** 			{
1627:../../Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
1628:../../Source/tasks.c **** 			}
1629:../../Source/tasks.c **** 
1630:../../Source/tasks.c **** 			/* See if this tick has made a timeout expire.  Tasks are stored in the
1631:../../Source/tasks.c **** 			queue in the order of their wake time - meaning once one tasks has been
1632:../../Source/tasks.c **** 			found whose block time has not expired there is no need not look any
1633:../../Source/tasks.c **** 			further	down the list. */
1634:../../Source/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
1635:../../Source/tasks.c **** 			{
1636:../../Source/tasks.c **** 				for( ;; )
1637:../../Source/tasks.c **** 				{
1638:../../Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1639:../../Source/tasks.c **** 					{
1640:../../Source/tasks.c **** 						/* The delayed list is empty.  Set xNextTaskUnblockTime to
1641:../../Source/tasks.c **** 						the	maximum possible value so it is extremely unlikely that
1642:../../Source/tasks.c **** 						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
1643:../../Source/tasks.c **** 						next time through. */
1644:../../Source/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
1645:../../Source/tasks.c **** 						break;
1646:../../Source/tasks.c **** 					}
1647:../../Source/tasks.c **** 					else
1648:../../Source/tasks.c **** 					{
1649:../../Source/tasks.c **** 						/* The delayed list is not empty, get the value of the item
1650:../../Source/tasks.c **** 						at the head of the delayed list.  This is the time at which
1651:../../Source/tasks.c **** 						the task at the head of the delayed list must be removed
1652:../../Source/tasks.c **** 						from the Blocked state. */
1653:../../Source/tasks.c **** 						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1654:../../Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
1655:../../Source/tasks.c **** 
1656:../../Source/tasks.c **** 						if( xConstTickCount < xItemValue )
1657:../../Source/tasks.c **** 						{
1658:../../Source/tasks.c **** 							/* It is not time to unblock this item yet, but the item
1659:../../Source/tasks.c **** 							value is the time at which the task at the head of the
1660:../../Source/tasks.c **** 							blocked list must be removed from the Blocked state -
1661:../../Source/tasks.c **** 							so record the item value in xNextTaskUnblockTime. */
1662:../../Source/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
1663:../../Source/tasks.c **** 							break;
1664:../../Source/tasks.c **** 						}
1665:../../Source/tasks.c **** 
1666:../../Source/tasks.c **** 						/* It is time to remove the item from the Blocked state. */
1667:../../Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
1668:../../Source/tasks.c **** 
1669:../../Source/tasks.c **** 						/* Is the task waiting on an event also?  If so remove it
1670:../../Source/tasks.c **** 						from the event list. */
1671:../../Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1672:../../Source/tasks.c **** 						{
1673:../../Source/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1674:../../Source/tasks.c **** 						}
1675:../../Source/tasks.c **** 
1676:../../Source/tasks.c **** 						/* Place the unblocked task into the appropriate ready
1677:../../Source/tasks.c **** 						list. */
1678:../../Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
1679:../../Source/tasks.c **** 
1680:../../Source/tasks.c **** 						/* A task being unblocked cannot cause an immediate context
1681:../../Source/tasks.c **** 						switch if preemption is turned off. */
1682:../../Source/tasks.c **** 						#if (  configUSE_PREEMPTION == 1 )
1683:../../Source/tasks.c **** 						{
1684:../../Source/tasks.c **** 							/* Preemption is on, but a context switch should only
1685:../../Source/tasks.c **** 							be performed if the unblocked task has a priority that
1686:../../Source/tasks.c **** 							is equal to or higher than the currently executing
1687:../../Source/tasks.c **** 							task. */
1688:../../Source/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1689:../../Source/tasks.c **** 							{
1690:../../Source/tasks.c **** 								xSwitchRequired = pdTRUE;
1691:../../Source/tasks.c **** 							}
1692:../../Source/tasks.c **** 						}
1693:../../Source/tasks.c **** 						#endif /* configUSE_PREEMPTION */
1694:../../Source/tasks.c **** 					}
1695:../../Source/tasks.c **** 				}
1696:../../Source/tasks.c **** 			}
1697:../../Source/tasks.c **** 		}
1698:../../Source/tasks.c **** 
1699:../../Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
1700:../../Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
1701:../../Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
1702:../../Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1703:../../Source/tasks.c **** 		{
1704:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned p
1705:../../Source/tasks.c **** 			{
1706:../../Source/tasks.c **** 				xSwitchRequired = pdTRUE;
1707:../../Source/tasks.c **** 			}
1708:../../Source/tasks.c **** 		}
1709:../../Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1710:../../Source/tasks.c **** 
1711:../../Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1712:../../Source/tasks.c **** 		{
1713:../../Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
1714:../../Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
1715:../../Source/tasks.c **** 			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
1716:../../Source/tasks.c **** 			{
1717:../../Source/tasks.c **** 				vApplicationTickHook();
1718:../../Source/tasks.c **** 			}
1719:../../Source/tasks.c **** 		}
1720:../../Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
1721:../../Source/tasks.c **** 	}
1722:../../Source/tasks.c **** 	else
1723:../../Source/tasks.c **** 	{
1724:../../Source/tasks.c **** 		++uxPendedTicks;
1725:../../Source/tasks.c **** 
1726:../../Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1727:../../Source/tasks.c **** 		scheduler is locked. */
1728:../../Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1729:../../Source/tasks.c **** 		{
1730:../../Source/tasks.c **** 			vApplicationTickHook();
1731:../../Source/tasks.c **** 		}
1732:../../Source/tasks.c **** 		#endif
1733:../../Source/tasks.c **** 	}
1734:../../Source/tasks.c **** 
1735:../../Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
1736:../../Source/tasks.c **** 	{
1737:../../Source/tasks.c **** 		if( xYieldPending != pdFALSE )
1738:../../Source/tasks.c **** 		{
1739:../../Source/tasks.c **** 			xSwitchRequired = pdTRUE;
1740:../../Source/tasks.c **** 		}
1741:../../Source/tasks.c **** 	}
1742:../../Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
1743:../../Source/tasks.c **** 
1744:../../Source/tasks.c **** 	return xSwitchRequired;
1745:../../Source/tasks.c **** }
1746:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1747:../../Source/tasks.c **** 
1748:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1749:../../Source/tasks.c **** 
1750:../../Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1751:../../Source/tasks.c **** 	{
1752:../../Source/tasks.c **** 	tskTCB *xTCB;
1753:../../Source/tasks.c **** 
1754:../../Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1755:../../Source/tasks.c **** 		if( xTask == NULL )
1756:../../Source/tasks.c **** 		{
1757:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1758:../../Source/tasks.c **** 		}
1759:../../Source/tasks.c **** 		else
1760:../../Source/tasks.c **** 		{
1761:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1762:../../Source/tasks.c **** 		}
1763:../../Source/tasks.c **** 
1764:../../Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1765:../../Source/tasks.c **** 		the value can be accessed from an interrupt. */
1766:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1767:../../Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1768:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1769:../../Source/tasks.c **** 	}
1770:../../Source/tasks.c **** 
1771:../../Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1772:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1773:../../Source/tasks.c **** 
1774:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1775:../../Source/tasks.c **** 
1776:../../Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1777:../../Source/tasks.c **** 	{
1778:../../Source/tasks.c **** 	tskTCB *xTCB;
1779:../../Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1780:../../Source/tasks.c **** 
1781:../../Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1782:../../Source/tasks.c **** 		if( xTask == NULL )
1783:../../Source/tasks.c **** 		{
1784:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1785:../../Source/tasks.c **** 		}
1786:../../Source/tasks.c **** 		else
1787:../../Source/tasks.c **** 		{
1788:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1789:../../Source/tasks.c **** 		}
1790:../../Source/tasks.c **** 
1791:../../Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1792:../../Source/tasks.c **** 		the value can be accessed from an interrupt. */
1793:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1794:../../Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1795:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1796:../../Source/tasks.c **** 
1797:../../Source/tasks.c **** 		return xReturn;
1798:../../Source/tasks.c **** 	}
1799:../../Source/tasks.c **** 
1800:../../Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1801:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1802:../../Source/tasks.c **** 
1803:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1804:../../Source/tasks.c **** 
1805:../../Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1806:../../Source/tasks.c **** 	{
1807:../../Source/tasks.c **** 	tskTCB *xTCB;
1808:../../Source/tasks.c **** 	portBASE_TYPE xReturn;
1809:../../Source/tasks.c **** 
1810:../../Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1811:../../Source/tasks.c **** 		if( xTask == NULL )
1812:../../Source/tasks.c **** 		{
1813:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1814:../../Source/tasks.c **** 		}
1815:../../Source/tasks.c **** 		else
1816:../../Source/tasks.c **** 		{
1817:../../Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1818:../../Source/tasks.c **** 		}
1819:../../Source/tasks.c **** 
1820:../../Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1821:../../Source/tasks.c **** 		{
1822:../../Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1823:../../Source/tasks.c **** 		}
1824:../../Source/tasks.c **** 		else
1825:../../Source/tasks.c **** 		{
1826:../../Source/tasks.c **** 			xReturn = pdFAIL;
1827:../../Source/tasks.c **** 		}
1828:../../Source/tasks.c **** 
1829:../../Source/tasks.c **** 		return xReturn;
1830:../../Source/tasks.c **** 	}
1831:../../Source/tasks.c **** 
1832:../../Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1833:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1834:../../Source/tasks.c **** 
1835:../../Source/tasks.c **** void vTaskSwitchContext( void )
1836:../../Source/tasks.c **** {
1837:../../Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1838:../../Source/tasks.c **** 	{
1839:../../Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1840:../../Source/tasks.c **** 		switch. */
1841:../../Source/tasks.c **** 		xYieldPending = pdTRUE;
1842:../../Source/tasks.c **** 	}
1843:../../Source/tasks.c **** 	else
1844:../../Source/tasks.c **** 	{
1845:../../Source/tasks.c **** 		xYieldPending = pdFALSE;
1846:../../Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1847:../../Source/tasks.c **** 
1848:../../Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1849:../../Source/tasks.c **** 		{
1850:../../Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1851:../../Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1852:../../Source/tasks.c **** 				#else
1853:../../Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1854:../../Source/tasks.c **** 				#endif
1855:../../Source/tasks.c **** 
1856:../../Source/tasks.c **** 				/* Add the amount of time the task has been running to the
1857:../../Source/tasks.c **** 				accumulated	time so far.  The time the task started running was
1858:../../Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
1859:../../Source/tasks.c **** 				protection here	so count values are only valid until the timer
1860:../../Source/tasks.c **** 				overflows.  The guard against negative values is to protect
1861:../../Source/tasks.c **** 				against suspect run time stat counter implementations - which
1862:../../Source/tasks.c **** 				are provided by the application, not the kernel. */
1863:../../Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
1864:../../Source/tasks.c **** 				{
1865:../../Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
1866:../../Source/tasks.c **** 				}
1867:../../Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
1868:../../Source/tasks.c **** 		}
1869:../../Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
1870:../../Source/tasks.c **** 
1871:../../Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1872:../../Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1873:../../Source/tasks.c **** 
1874:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
1875:../../Source/tasks.c **** 
1876:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1877:../../Source/tasks.c **** 
1878:../../Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1879:../../Source/tasks.c **** 		{
1880:../../Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1881:../../Source/tasks.c **** 			structure specific to this task. */
1882:../../Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1883:../../Source/tasks.c **** 		}
1884:../../Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1885:../../Source/tasks.c **** 	}
1886:../../Source/tasks.c **** }
1887:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1888:../../Source/tasks.c **** 
1889:../../Source/tasks.c **** void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
1890:../../Source/tasks.c **** {
1891:../../Source/tasks.c **** portTickType xTimeToWake;
1892:../../Source/tasks.c **** 
1893:../../Source/tasks.c **** 	configASSERT( pxEventList );
1894:../../Source/tasks.c **** 
1895:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1896:../../Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1897:../../Source/tasks.c **** 
1898:../../Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1899:../../Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1900:../../Source/tasks.c **** 	is the first to be woken by the event. */
1901:../../Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1902:../../Source/tasks.c **** 
1903:../../Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1904:../../Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1905:../../Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1906:../../Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
1907:../../Source/tasks.c **** 	{
1908:../../Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
1909:../../Source/tasks.c **** 		check, and the port reset macro can be called directly. */
1910:../../Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1911:../../Source/tasks.c **** 	}
1912:../../Source/tasks.c **** 
1913:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1914:../../Source/tasks.c **** 	{
1915:../../Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1916:../../Source/tasks.c **** 		{
1917:../../Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1918:../../Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1919:../../Source/tasks.c **** 			indefinitely. */
1920:../../Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
1921:../../Source/tasks.c **** 		}
1922:../../Source/tasks.c **** 		else
1923:../../Source/tasks.c **** 		{
1924:../../Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1925:../../Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1926:../../Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1927:../../Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1928:../../Source/tasks.c **** 		}
1929:../../Source/tasks.c **** 	}
1930:../../Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
1931:../../Source/tasks.c **** 	{
1932:../../Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1933:../../Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1934:../../Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1935:../../Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1936:../../Source/tasks.c **** 	}
1937:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
1938:../../Source/tasks.c **** }
1939:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1940:../../Source/tasks.c **** 
1941:../../Source/tasks.c **** #if configUSE_TIMERS == 1
1942:../../Source/tasks.c **** 
1943:../../Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
1944:../../Source/tasks.c **** 	{
1945:../../Source/tasks.c **** 	portTickType xTimeToWake;
1946:../../Source/tasks.c **** 
1947:../../Source/tasks.c **** 		configASSERT( pxEventList );
1948:../../Source/tasks.c **** 
1949:../../Source/tasks.c **** 		/* This function should not be called by application code hence the
1950:../../Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1951:../../Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1952:../../Source/tasks.c **** 		it should be called from a critical section. */
1953:../../Source/tasks.c **** 
1954:../../Source/tasks.c **** 
1955:../../Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1956:../../Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1957:../../Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1958:../../Source/tasks.c **** 		can be used in place of vListInsert. */
1959:../../Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1960:../../Source/tasks.c **** 
1961:../../Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1962:../../Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1963:../../Source/tasks.c **** 		function is called form a critical section. */
1964:../../Source/tasks.c **** 		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
1965:../../Source/tasks.c **** 		{
1966:../../Source/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
1967:../../Source/tasks.c **** 			check, and the port reset macro can be called directly. */
1968:../../Source/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1969:../../Source/tasks.c **** 		}
1970:../../Source/tasks.c **** 
1971:../../Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1972:../../Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1973:../../Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1974:../../Source/tasks.c **** 
1975:../../Source/tasks.c **** 		traceTASK_DELAY_UNTIL();
1976:../../Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1977:../../Source/tasks.c **** 	}
1978:../../Source/tasks.c **** 
1979:../../Source/tasks.c **** #endif /* configUSE_TIMERS */
1980:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1981:../../Source/tasks.c **** 
1982:../../Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1983:../../Source/tasks.c **** {
1984:../../Source/tasks.c **** tskTCB *pxUnblockedTCB;
1985:../../Source/tasks.c **** portBASE_TYPE xReturn;
1986:../../Source/tasks.c **** 
1987:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1988:../../Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1989:../../Source/tasks.c **** 
1990:../../Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1991:../../Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1992:../../Source/tasks.c **** 	it to the ready list.
1993:../../Source/tasks.c **** 
1994:../../Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1995:../../Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1996:../../Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1997:../../Source/tasks.c **** 
1998:../../Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1999:../../Source/tasks.c **** 	pxEventList is not empty. */
2000:../../Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
2001:../../Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2002:../../Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
2003:../../Source/tasks.c **** 
2004:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2005:../../Source/tasks.c **** 	{
2006:../../Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
2007:../../Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
2008:../../Source/tasks.c **** 	}
2009:../../Source/tasks.c **** 	else
2010:../../Source/tasks.c **** 	{
2011:../../Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
2012:../../Source/tasks.c **** 		task pending until the scheduler is resumed. */
2013:../../Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
2014:../../Source/tasks.c **** 	}
2015:../../Source/tasks.c **** 
2016:../../Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
2017:../../Source/tasks.c **** 	{
2018:../../Source/tasks.c **** 		/* Return true if the task removed from the event list has
2019:../../Source/tasks.c **** 		a higher priority than the calling task.  This allows
2020:../../Source/tasks.c **** 		the calling task to know if it should force a context
2021:../../Source/tasks.c **** 		switch now. */
2022:../../Source/tasks.c **** 		xReturn = pdTRUE;
2023:../../Source/tasks.c **** 
2024:../../Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2025:../../Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2026:../../Source/tasks.c **** 		xYieldPending = pdTRUE;
2027:../../Source/tasks.c **** 	}
2028:../../Source/tasks.c **** 	else
2029:../../Source/tasks.c **** 	{
2030:../../Source/tasks.c **** 		xReturn = pdFALSE;
2031:../../Source/tasks.c **** 	}
2032:../../Source/tasks.c **** 
2033:../../Source/tasks.c **** 	return xReturn;
2034:../../Source/tasks.c **** }
2035:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2036:../../Source/tasks.c **** 
2037:../../Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
2038:../../Source/tasks.c **** {
2039:../../Source/tasks.c **** 	configASSERT( pxTimeOut );
2040:../../Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
2041:../../Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
2042:../../Source/tasks.c **** }
2043:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2044:../../Source/tasks.c **** 
2045:../../Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
2046:../../Source/tasks.c **** {
2047:../../Source/tasks.c **** portBASE_TYPE xReturn;
2048:../../Source/tasks.c **** 
2049:../../Source/tasks.c **** 	configASSERT( pxTimeOut );
2050:../../Source/tasks.c **** 	configASSERT( pxTicksToWait );
2051:../../Source/tasks.c **** 
2052:../../Source/tasks.c **** 	taskENTER_CRITICAL();
2053:../../Source/tasks.c **** 	{
2054:../../Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2055:../../Source/tasks.c **** 		const portTickType xConstTickCount = xTickCount;
2056:../../Source/tasks.c **** 
2057:../../Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2058:../../Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2059:../../Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2060:../../Source/tasks.c **** 			therefore never time out. */
2061:../../Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
2062:../../Source/tasks.c **** 			{
2063:../../Source/tasks.c **** 				xReturn = pdFALSE;
2064:../../Source/tasks.c **** 			}
2065:../../Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2066:../../Source/tasks.c **** 		#endif
2067:../../Source/tasks.c **** 
2068:../../Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
2069:../../Source/tasks.c **** 		{
2070:../../Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2071:../../Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2072:../../Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2073:../../Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2074:../../Source/tasks.c **** 			xReturn = pdTRUE;
2075:../../Source/tasks.c **** 		}
2076:../../Source/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
2077:../../Source/tasks.c **** 		{
2078:../../Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2079:../../Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
2080:../../Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
2081:../../Source/tasks.c **** 			xReturn = pdFALSE;
2082:../../Source/tasks.c **** 		}
2083:../../Source/tasks.c **** 		else
2084:../../Source/tasks.c **** 		{
2085:../../Source/tasks.c **** 			xReturn = pdTRUE;
2086:../../Source/tasks.c **** 		}
2087:../../Source/tasks.c **** 	}
2088:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
2089:../../Source/tasks.c **** 
2090:../../Source/tasks.c **** 	return xReturn;
2091:../../Source/tasks.c **** }
2092:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2093:../../Source/tasks.c **** 
2094:../../Source/tasks.c **** void vTaskMissedYield( void )
2095:../../Source/tasks.c **** {
2096:../../Source/tasks.c **** 	xYieldPending = pdTRUE;
2097:../../Source/tasks.c **** }
2098:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2099:../../Source/tasks.c **** 
2100:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2101:../../Source/tasks.c **** 
2102:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
2103:../../Source/tasks.c **** 	{
2104:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2105:../../Source/tasks.c **** 	tskTCB *pxTCB;
2106:../../Source/tasks.c **** 
2107:../../Source/tasks.c **** 		if( xTask != NULL )
2108:../../Source/tasks.c **** 		{
2109:../../Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2110:../../Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2111:../../Source/tasks.c **** 		}
2112:../../Source/tasks.c **** 		else
2113:../../Source/tasks.c **** 		{
2114:../../Source/tasks.c **** 			uxReturn = 0U;
2115:../../Source/tasks.c **** 		}
2116:../../Source/tasks.c **** 
2117:../../Source/tasks.c **** 		return uxReturn;
2118:../../Source/tasks.c **** 	}
2119:../../Source/tasks.c **** 
2120:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2121:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2122:../../Source/tasks.c **** 
2123:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2124:../../Source/tasks.c **** 
2125:../../Source/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
2126:../../Source/tasks.c **** 	{
2127:../../Source/tasks.c **** 	tskTCB *pxTCB;
2128:../../Source/tasks.c **** 
2129:../../Source/tasks.c **** 		if( xTask != NULL )
2130:../../Source/tasks.c **** 		{
2131:../../Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
2132:../../Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2133:../../Source/tasks.c **** 		}
2134:../../Source/tasks.c **** 	}
2135:../../Source/tasks.c **** 
2136:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2137:../../Source/tasks.c **** 
2138:../../Source/tasks.c **** /*
2139:../../Source/tasks.c ****  * -----------------------------------------------------------
2140:../../Source/tasks.c ****  * The Idle task.
2141:../../Source/tasks.c ****  * ----------------------------------------------------------
2142:../../Source/tasks.c ****  *
2143:../../Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2144:../../Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2145:../../Source/tasks.c ****  *
2146:../../Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
2147:../../Source/tasks.c ****  *
2148:../../Source/tasks.c ****  */
2149:../../Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2150:../../Source/tasks.c **** {
2151:../../Source/tasks.c **** 	/* Stop warnings. */
2152:../../Source/tasks.c **** 	( void ) pvParameters;
2153:../../Source/tasks.c **** 
2154:../../Source/tasks.c **** 	for( ;; )
2155:../../Source/tasks.c **** 	{
2156:../../Source/tasks.c **** 		/* See if any tasks have been deleted. */
2157:../../Source/tasks.c **** 		prvCheckTasksWaitingTermination();
2158:../../Source/tasks.c **** 
2159:../../Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2160:../../Source/tasks.c **** 		{
2161:../../Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2162:../../Source/tasks.c **** 			see if any other task has become available.  If we are using
2163:../../Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
2164:../../Source/tasks.c **** 			will automatically get the processor anyway. */
2165:../../Source/tasks.c **** 			taskYIELD();
2166:../../Source/tasks.c **** 		}
2167:../../Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2168:../../Source/tasks.c **** 
2169:../../Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2170:../../Source/tasks.c **** 		{
2171:../../Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
2172:../../Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2173:../../Source/tasks.c **** 			to run then the idle task should yield before the end of the
2174:../../Source/tasks.c **** 			timeslice.
2175:../../Source/tasks.c **** 
2176:../../Source/tasks.c **** 			A critical region is not required here as we are just reading from
2177:../../Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2178:../../Source/tasks.c **** 			the ready list at the idle priority contains more than one task
2179:../../Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
2180:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
2181:../../Source/tasks.c **** 			{
2182:../../Source/tasks.c **** 				taskYIELD();
2183:../../Source/tasks.c **** 			}
2184:../../Source/tasks.c **** 		}
2185:../../Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2186:../../Source/tasks.c **** 
2187:../../Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2188:../../Source/tasks.c **** 		{
2189:../../Source/tasks.c **** 			extern void vApplicationIdleHook( void );
2190:../../Source/tasks.c **** 
2191:../../Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2192:../../Source/tasks.c **** 			allows the application designer to add background functionality
2193:../../Source/tasks.c **** 			without the overhead of a separate task.
2194:../../Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2195:../../Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2196:../../Source/tasks.c **** 			vApplicationIdleHook();
2197:../../Source/tasks.c **** 		}
2198:../../Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2199:../../Source/tasks.c **** 
2200:../../Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2201:../../Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2202:../../Source/tasks.c **** 		user defined low power mode	implementations require
2203:../../Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2204:../../Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2205:../../Source/tasks.c **** 		{
2206:../../Source/tasks.c **** 		portTickType xExpectedIdleTime;
2207:../../Source/tasks.c **** 
2208:../../Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2209:../../Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2210:../../Source/tasks.c **** 			test of the expected idle time is performed without the
2211:../../Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2212:../../Source/tasks.c **** 			valid. */
2213:../../Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2214:../../Source/tasks.c **** 
2215:../../Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2216:../../Source/tasks.c **** 			{
2217:../../Source/tasks.c **** 				vTaskSuspendAll();
2218:../../Source/tasks.c **** 				{
2219:../../Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2220:../../Source/tasks.c **** 					time can be sampled again, and this time its value can
2221:../../Source/tasks.c **** 					be used. */
2222:../../Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2223:../../Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2224:../../Source/tasks.c **** 
2225:../../Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2226:../../Source/tasks.c **** 					{
2227:../../Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
2228:../../Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2229:../../Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
2230:../../Source/tasks.c **** 					}
2231:../../Source/tasks.c **** 				}
2232:../../Source/tasks.c **** 				( void ) xTaskResumeAll();
2233:../../Source/tasks.c **** 			}
2234:../../Source/tasks.c **** 		}
2235:../../Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2236:../../Source/tasks.c **** 	}
2237:../../Source/tasks.c **** }
2238:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2239:../../Source/tasks.c **** 
2240:../../Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2241:../../Source/tasks.c **** 
2242:../../Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2243:../../Source/tasks.c **** 	{
2244:../../Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2245:../../Source/tasks.c **** 
2246:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2247:../../Source/tasks.c **** 		{
2248:../../Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2249:../../Source/tasks.c **** 			eReturn = eAbortSleep;
2250:../../Source/tasks.c **** 		}
2251:../../Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
2252:../../Source/tasks.c **** 		{
2253:../../Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2254:../../Source/tasks.c **** 			eReturn = eAbortSleep;
2255:../../Source/tasks.c **** 		}
2256:../../Source/tasks.c **** 		else
2257:../../Source/tasks.c **** 		{
2258:../../Source/tasks.c **** 			#if configUSE_TIMERS == 0
2259:../../Source/tasks.c **** 			{
2260:../../Source/tasks.c **** 				/* The idle task exists in addition to the application tasks. */
2261:../../Source/tasks.c **** 				const unsigned portBASE_TYPE uxNonApplicationTasks = 1;
2262:../../Source/tasks.c **** 
2263:../../Source/tasks.c **** 				/* If timers are not being used and all the tasks are in the
2264:../../Source/tasks.c **** 				suspended list (which might mean they have an infinite block
2265:../../Source/tasks.c **** 				time rather than actually being suspended) then it is safe to
2266:../../Source/tasks.c **** 				turn all clocks off and just wait for external interrupts. */
2267:../../Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicati
2268:../../Source/tasks.c **** 				{
2269:../../Source/tasks.c **** 					eReturn = eNoTasksWaitingTimeout;
2270:../../Source/tasks.c **** 				}
2271:../../Source/tasks.c **** 			}
2272:../../Source/tasks.c **** 			#endif /* configUSE_TIMERS */
2273:../../Source/tasks.c **** 		}
2274:../../Source/tasks.c **** 
2275:../../Source/tasks.c **** 		return eReturn;
2276:../../Source/tasks.c **** 	}
2277:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2278:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2279:../../Source/tasks.c **** 
2280:../../Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
2281:../../Source/tasks.c **** {
2282:../../Source/tasks.c **** unsigned portBASE_TYPE x;
2283:../../Source/tasks.c **** 
2284:../../Source/tasks.c **** 	/* Store the task name in the TCB. */
2285:../../Source/tasks.c **** 	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++
2286:../../Source/tasks.c **** 	{
2287:../../Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
2288:../../Source/tasks.c **** 
2289:../../Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2290:../../Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
2291:../../Source/tasks.c **** 		string is not accessible (extremely unlikely). */
2292:../../Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
2293:../../Source/tasks.c **** 		{
2294:../../Source/tasks.c **** 			break;
2295:../../Source/tasks.c **** 		}
2296:../../Source/tasks.c **** 	}
2297:../../Source/tasks.c **** 
2298:../../Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
2299:../../Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
2300:../../Source/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
2301:../../Source/tasks.c **** 
2302:../../Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2303:../../Source/tasks.c **** 	remove the privilege bit if one is present. */
2304:../../Source/tasks.c **** 	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
2305:../../Source/tasks.c **** 	{
2306:../../Source/tasks.c **** 		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
2307:../../Source/tasks.c **** 	}
2308:../../Source/tasks.c **** 
2309:../../Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
2310:../../Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2311:../../Source/tasks.c **** 	{
2312:../../Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
2313:../../Source/tasks.c **** 	}
2314:../../Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
2315:../../Source/tasks.c **** 
2316:../../Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
2317:../../Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
2318:../../Source/tasks.c **** 
2319:../../Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2320:../../Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2321:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
2322:../../Source/tasks.c **** 
2323:../../Source/tasks.c **** 	/* Event lists are always in priority order. */
2324:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( por
2325:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
2326:../../Source/tasks.c **** 
2327:../../Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2328:../../Source/tasks.c **** 	{
2329:../../Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2330:../../Source/tasks.c **** 	}
2331:../../Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2332:../../Source/tasks.c **** 
2333:../../Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2334:../../Source/tasks.c **** 	{
2335:../../Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2336:../../Source/tasks.c **** 	}
2337:../../Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2338:../../Source/tasks.c **** 
2339:../../Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2340:../../Source/tasks.c **** 	{
2341:../../Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2342:../../Source/tasks.c **** 	}
2343:../../Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2344:../../Source/tasks.c **** 
2345:../../Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2346:../../Source/tasks.c **** 	{
2347:../../Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2348:../../Source/tasks.c **** 	}
2349:../../Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2350:../../Source/tasks.c **** 	{
2351:../../Source/tasks.c **** 		( void ) xRegions;
2352:../../Source/tasks.c **** 		( void ) usStackDepth;
2353:../../Source/tasks.c **** 	}
2354:../../Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2355:../../Source/tasks.c **** 
2356:../../Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2357:../../Source/tasks.c **** 	{
2358:../../Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
2359:../../Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2360:../../Source/tasks.c **** 	}
2361:../../Source/tasks.c **** 	#endif /* configUSE_NEWLIB_REENTRANT */
2362:../../Source/tasks.c **** }
2363:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2364:../../Source/tasks.c **** 
2365:../../Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2366:../../Source/tasks.c **** 
2367:../../Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2368:../../Source/tasks.c **** 	{
2369:../../Source/tasks.c **** 	tskTCB *pxTCB;
2370:../../Source/tasks.c **** 
2371:../../Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2372:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2373:../../Source/tasks.c **** 
2374:../../Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2375:../../Source/tasks.c **** 	}
2376:../../Source/tasks.c **** 
2377:../../Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2378:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2379:../../Source/tasks.c **** 
2380:../../Source/tasks.c **** static void prvInitialiseTaskLists( void )
2381:../../Source/tasks.c **** {
2382:../../Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2383:../../Source/tasks.c **** 
2384:../../Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX
2385:../../Source/tasks.c **** 	{
2386:../../Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
2387:../../Source/tasks.c **** 	}
2388:../../Source/tasks.c **** 
2389:../../Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
2390:../../Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
2391:../../Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
2392:../../Source/tasks.c **** 
2393:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2394:../../Source/tasks.c **** 	{
2395:../../Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
2396:../../Source/tasks.c **** 	}
2397:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
2398:../../Source/tasks.c **** 
2399:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2400:../../Source/tasks.c **** 	{
2401:../../Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
2402:../../Source/tasks.c **** 	}
2403:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2404:../../Source/tasks.c **** 
2405:../../Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2406:../../Source/tasks.c **** 	using list2. */
2407:../../Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
2408:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
2409:../../Source/tasks.c **** }
2410:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2411:../../Source/tasks.c **** 
2412:../../Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2413:../../Source/tasks.c **** {
2414:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2415:../../Source/tasks.c **** 	{
2416:../../Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2417:../../Source/tasks.c **** 
2418:../../Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2419:../../Source/tasks.c **** 		too often in the idle task. */
2420:../../Source/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2421:../../Source/tasks.c **** 		{
2422:../../Source/tasks.c **** 			vTaskSuspendAll();
2423:../../Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2424:../../Source/tasks.c **** 			( void ) xTaskResumeAll();
2425:../../Source/tasks.c **** 
2426:../../Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
2427:../../Source/tasks.c **** 			{
2428:../../Source/tasks.c **** 				tskTCB *pxTCB;
2429:../../Source/tasks.c **** 
2430:../../Source/tasks.c **** 				taskENTER_CRITICAL();
2431:../../Source/tasks.c **** 				{
2432:../../Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
2433:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
2434:../../Source/tasks.c **** 					--uxCurrentNumberOfTasks;
2435:../../Source/tasks.c **** 					--uxTasksDeleted;
2436:../../Source/tasks.c **** 				}
2437:../../Source/tasks.c **** 				taskEXIT_CRITICAL();
2438:../../Source/tasks.c **** 
2439:../../Source/tasks.c **** 				prvDeleteTCB( pxTCB );
2440:../../Source/tasks.c **** 			}
2441:../../Source/tasks.c **** 		}
2442:../../Source/tasks.c **** 	}
2443:../../Source/tasks.c **** 	#endif /* vTaskDelete */
2444:../../Source/tasks.c **** }
2445:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2446:../../Source/tasks.c **** 
2447:../../Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2448:../../Source/tasks.c **** {
 130               	.LM0:
 131               	.LFBB1:
 132 0000 CF93      		push r28
 133 0002 DF93      		push r29
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 2 */
 137               	.L__stack_usage = 2
 138 0004 EC01      		movw r28,r24
2449:../../Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2450:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 140               	.LM1:
 141 0006 E091 0000 		lds r30,pxCurrentTCB
 142 000a F091 0000 		lds r31,pxCurrentTCB+1
 143 000e 9383      		std Z+3,r25
 144 0010 8283      		std Z+2,r24
2451:../../Source/tasks.c **** 
2452:../../Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 146               	.LM2:
 147 0012 8091 0000 		lds r24,xTickCount
 148 0016 9091 0000 		lds r25,xTickCount+1
 149               	.LBB4:
 150               	.LBB5:
2453:../../Source/tasks.c **** 	{
2454:../../Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2455:../../Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 152               	.LM3:
 153 001a 6091 0000 		lds r22,pxCurrentTCB
 154 001e 7091 0000 		lds r23,pxCurrentTCB+1
 155               	.LBE5:
 156               	.LBE4:
2452:../../Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 158               	.LM4:
 159 0022 C817      		cp r28,r24
 160 0024 D907      		cpc r29,r25
 161 0026 00F4      		brsh .L2
 162               	.LBB8:
 163               	.LBB6:
 165               	.LM5:
 166 0028 8091 0000 		lds r24,pxOverflowDelayedTaskList
 167 002c 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 168 0030 6E5F      		subi r22,-2
 169 0032 7F4F      		sbci r23,-1
 170               	/* epilogue start */
 171               	.LBE6:
 172               	.LBE8:
2456:../../Source/tasks.c **** 	}
2457:../../Source/tasks.c **** 	else
2458:../../Source/tasks.c **** 	{
2459:../../Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2460:../../Source/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2461:../../Source/tasks.c **** 
2462:../../Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2463:../../Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2464:../../Source/tasks.c **** 		too. */
2465:../../Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
2466:../../Source/tasks.c **** 		{
2467:../../Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
2468:../../Source/tasks.c **** 		}
2469:../../Source/tasks.c **** 	}
2470:../../Source/tasks.c **** }
 174               	.LM6:
 175 0034 DF91      		pop r29
 176 0036 CF91      		pop r28
 177               	.LBB9:
 178               	.LBB7:
2455:../../Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 180               	.LM7:
 181 0038 0C94 0000 		jmp vListInsert
 182               	.L2:
 183               	.LBE7:
 184               	.LBE9:
2460:../../Source/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 186               	.LM8:
 187 003c 8091 0000 		lds r24,pxDelayedTaskList
 188 0040 9091 0000 		lds r25,pxDelayedTaskList+1
 189 0044 6E5F      		subi r22,-2
 190 0046 7F4F      		sbci r23,-1
 191 0048 0E94 0000 		call vListInsert
2465:../../Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 193               	.LM9:
 194 004c 8091 0000 		lds r24,xNextTaskUnblockTime
 195 0050 9091 0000 		lds r25,xNextTaskUnblockTime+1
 196 0054 C817      		cp r28,r24
 197 0056 D907      		cpc r29,r25
 198 0058 00F4      		brsh .L1
2467:../../Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 200               	.LM10:
 201 005a D093 0000 		sts xNextTaskUnblockTime+1,r29
 202 005e C093 0000 		sts xNextTaskUnblockTime,r28
 203               	.L1:
 204               	/* epilogue start */
 206               	.LM11:
 207 0062 DF91      		pop r29
 208 0064 CF91      		pop r28
 209 0066 0895      		ret
 211               	.Lscope1:
 213               		.stabd	78,0,0
 222               	.global	xTaskGenericCreate
 224               	xTaskGenericCreate:
 225               		.stabd	46,0,0
 488:../../Source/tasks.c **** {
 227               	.LM12:
 228               	.LFBB2:
 229 0068 3F92      		push r3
 230 006a 4F92      		push r4
 231 006c 5F92      		push r5
 232 006e 6F92      		push r6
 233 0070 7F92      		push r7
 234 0072 8F92      		push r8
 235 0074 9F92      		push r9
 236 0076 AF92      		push r10
 237 0078 BF92      		push r11
 238 007a CF92      		push r12
 239 007c DF92      		push r13
 240 007e EF92      		push r14
 241 0080 FF92      		push r15
 242 0082 0F93      		push r16
 243 0084 1F93      		push r17
 244 0086 CF93      		push r28
 245 0088 DF93      		push r29
 246               	/* prologue: function */
 247               	/* frame size = 0 */
 248               	/* stack size = 17 */
 249               	.L__stack_usage = 17
 250 008a 4C01      		movw r8,r24
 251 008c 162F      		mov r17,r22
 252 008e 372E      		mov r3,r23
 253 0090 5A01      		movw r10,r20
 254 0092 3901      		movw r6,r18
 255               	.LBB17:
 256               	.LBB18:
2471:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2472:../../Source/tasks.c **** 
2473:../../Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2474:../../Source/tasks.c **** {
2475:../../Source/tasks.c **** tskTCB *pxNewTCB;
2476:../../Source/tasks.c **** 
2477:../../Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2478:../../Source/tasks.c **** 	the implementation of the port malloc function. */
2479:../../Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 258               	.LM13:
 259 0094 81E2      		ldi r24,lo8(33)
 260 0096 90E0      		ldi r25,0
 261 0098 0E94 0000 		call pvPortMalloc
 262 009c EC01      		movw r28,r24
2480:../../Source/tasks.c **** 
2481:../../Source/tasks.c **** 	if( pxNewTCB != NULL )
 264               	.LM14:
 265 009e 0097      		sbiw r24,0
 266 00a0 01F4      		brne .+2
 267 00a2 00C0      		rjmp .L5
2482:../../Source/tasks.c **** 	{
2483:../../Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2484:../../Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2485:../../Source/tasks.c **** 		be deleted later if required. */
2486:../../Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * siz
 269               	.LM15:
 270 00a4 C114      		cp r12,__zero_reg__
 271 00a6 D104      		cpc r13,__zero_reg__
 272 00a8 01F4      		brne .L6
 273 00aa C501      		movw r24,r10
 274 00ac 0E94 0000 		call pvPortMalloc
 275 00b0 6C01      		movw r12,r24
 276               	.L6:
 277 00b2 D88E      		std Y+24,r13
 278 00b4 CF8A      		std Y+23,r12
2487:../../Source/tasks.c **** 
2488:../../Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 280               	.LM16:
 281 00b6 C114      		cp r12,__zero_reg__
 282 00b8 D104      		cpc r13,__zero_reg__
 283 00ba 01F4      		brne .L7
2489:../../Source/tasks.c **** 		{
2490:../../Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2491:../../Source/tasks.c **** 			vPortFree( pxNewTCB );
 285               	.LM17:
 286 00bc CE01      		movw r24,r28
 287 00be 0E94 0000 		call vPortFree
 288 00c2 00C0      		rjmp .L5
 289               	.L7:
2492:../../Source/tasks.c **** 			pxNewTCB = NULL;
2493:../../Source/tasks.c **** 		}
2494:../../Source/tasks.c **** 		else
2495:../../Source/tasks.c **** 		{
2496:../../Source/tasks.c **** 			/* Just to help debugging. */
2497:../../Source/tasks.c **** 			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof
 291               	.LM18:
 292 00c4 A501      		movw r20,r10
 293 00c6 65EA      		ldi r22,lo8(-91)
 294 00c8 70E0      		ldi r23,0
 295 00ca C601      		movw r24,r12
 296 00cc 0E94 0000 		call memset
 297               	.LBE18:
 298               	.LBE17:
 299               	.LBB19:
 523:../../Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 301               	.LM19:
 302 00d0 21E0      		ldi r18,1
 303 00d2 A21A      		sub r10,r18
 304 00d4 B108      		sbc r11,__zero_reg__
 305 00d6 4F88      		ldd r4,Y+23
 306 00d8 588C      		ldd r5,Y+24
 307 00da 4A0C      		add r4,r10
 308 00dc 5B1C      		adc r5,r11
 309 00de E12F      		mov r30,r17
 310 00e0 F32D      		mov r31,r3
 311 00e2 80E0      		ldi r24,0
 312 00e4 90E0      		ldi r25,0
 313               	.L9:
 487:../../Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 315               	.LM20:
 316 00e6 BF01      		movw r22,r30
 317               	.LBB20:
 318               	.LBB21:
2287:../../Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 320               	.LM21:
 321 00e8 4191      		ld r20,Z+
 487:../../Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 323               	.LM22:
 324 00ea 9E01      		movw r18,r28
 325 00ec 280F      		add r18,r24
 326 00ee 391F      		adc r19,r25
2287:../../Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 328               	.LM23:
 329 00f0 D901      		movw r26,r18
 330 00f2 5996      		adiw r26,25
 331 00f4 4C93      		st X,r20
2292:../../Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
 333               	.LM24:
 334 00f6 DB01      		movw r26,r22
 335 00f8 2C91      		ld r18,X
 336 00fa 2223      		tst r18
 337 00fc 01F0      		breq .L8
 338 00fe 0196      		adiw r24,1
2285:../../Source/tasks.c **** 	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++
 340               	.LM25:
 341 0100 8830      		cpi r24,8
 342 0102 9105      		cpc r25,__zero_reg__
 343 0104 01F4      		brne .L9
 344               	.L8:
2300:../../Source/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
 346               	.LM26:
 347 0106 18A2      		std Y+32,__zero_reg__
 348 0108 102F      		mov r17,r16
 349 010a 0430      		cpi r16,lo8(4)
 350 010c 00F0      		brlo .L10
 351 010e 13E0      		ldi r17,lo8(3)
 352               	.L10:
2309:../../Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 354               	.LM27:
 355 0110 1E8B      		std Y+22,r17
2316:../../Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 357               	.LM28:
 358 0112 6E01      		movw r12,r28
 359 0114 B2E0      		ldi r27,2
 360 0116 CB0E      		add r12,r27
 361 0118 D11C      		adc r13,__zero_reg__
 362 011a C601      		movw r24,r12
 363 011c 0E94 0000 		call vListInitialiseItem
2317:../../Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 365               	.LM29:
 366 0120 CE01      		movw r24,r28
 367 0122 0C96      		adiw r24,12
 368 0124 0E94 0000 		call vListInitialiseItem
2321:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 370               	.LM30:
 371 0128 D987      		std Y+9,r29
 372 012a C887      		std Y+8,r28
2324:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( por
 374               	.LM31:
 375 012c 84E0      		ldi r24,lo8(4)
 376 012e 90E0      		ldi r25,0
 377 0130 811B      		sub r24,r17
 378 0132 9109      		sbc r25,__zero_reg__
 379 0134 9D87      		std Y+13,r25
 380 0136 8C87      		std Y+12,r24
2325:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 382               	.LM32:
 383 0138 DB8B      		std Y+19,r29
 384 013a CA8B      		std Y+18,r28
 385               	.LBE21:
 386               	.LBE20:
 556:../../Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 388               	.LM33:
 389 013c A301      		movw r20,r6
 390 013e B401      		movw r22,r8
 391 0140 C201      		movw r24,r4
 392 0142 0E94 0000 		call pxPortInitialiseStack
 393 0146 9983      		std Y+1,r25
 394 0148 8883      		st Y,r24
 560:../../Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 396               	.LM34:
 397 014a E114      		cp r14,__zero_reg__
 398 014c F104      		cpc r15,__zero_reg__
 399 014e 01F0      		breq .L11
 565:../../Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 401               	.LM35:
 402 0150 F701      		movw r30,r14
 403 0152 D183      		std Z+1,r29
 404 0154 C083      		st Z,r28
 405               	.L11:
 570:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 407               	.LM36:
 408               	/* #APP */
 409               	 ;  570 "../../Source/tasks.c" 1
 410 0156 0FB6      		in		__tmp_reg__, __SREG__
 411               	 ;  0 "" 2
 412               	 ;  570 "../../Source/tasks.c" 1
 413 0158 F894      		cli
 414               	 ;  0 "" 2
 415               	 ;  570 "../../Source/tasks.c" 1
 416 015a 0F92      		push	__tmp_reg__
 417               	 ;  0 "" 2
 572:../../Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 419               	.LM37:
 420               	/* #NOAPP */
 421 015c 8091 0000 		lds r24,uxCurrentNumberOfTasks
 422 0160 8F5F      		subi r24,lo8(-(1))
 423 0162 8093 0000 		sts uxCurrentNumberOfTasks,r24
 573:../../Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 425               	.LM38:
 426 0166 8091 0000 		lds r24,pxCurrentTCB
 427 016a 9091 0000 		lds r25,pxCurrentTCB+1
 428 016e 892B      		or r24,r25
 429 0170 01F4      		brne .L12
 577:../../Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 431               	.LM39:
 432 0172 D093 0000 		sts pxCurrentTCB+1,r29
 433 0176 C093 0000 		sts pxCurrentTCB,r28
 579:../../Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 435               	.LM40:
 436 017a 8091 0000 		lds r24,uxCurrentNumberOfTasks
 437 017e 8130      		cpi r24,lo8(1)
 438 0180 01F0      		breq .+2
 439 0182 00C0      		rjmp .L14
 440 0184 E12C      		mov r14,__zero_reg__
 441 0186 F12C      		mov r15,__zero_reg__
 442               	.LBB22:
 443               	.LBB23:
2386:../../Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 445               	.LM41:
 446 0188 19E0      		ldi r17,lo8(9)
 447               	.L13:
 448 018a 1E9D      		mul r17,r14
 449 018c C001      		movw r24,r0
 450 018e 1F9D      		mul r17,r15
 451 0190 900D      		add r25,r0
 452 0192 1124      		clr __zero_reg__
 453 0194 8050      		subi r24,lo8(-(pxReadyTasksLists))
 454 0196 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 455 0198 0E94 0000 		call vListInitialise
 456 019c FFEF      		ldi r31,-1
 457 019e EF1A      		sub r14,r31
 458 01a0 FF0A      		sbc r15,r31
2384:../../Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX
 460               	.LM42:
 461 01a2 24E0      		ldi r18,4
 462 01a4 E216      		cp r14,r18
 463 01a6 F104      		cpc r15,__zero_reg__
 464 01a8 01F4      		brne .L13
2389:../../Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 466               	.LM43:
 467 01aa 80E0      		ldi r24,lo8(xDelayedTaskList1)
 468 01ac 90E0      		ldi r25,hi8(xDelayedTaskList1)
 469 01ae 0E94 0000 		call vListInitialise
2390:../../Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 471               	.LM44:
 472 01b2 80E0      		ldi r24,lo8(xDelayedTaskList2)
 473 01b4 90E0      		ldi r25,hi8(xDelayedTaskList2)
 474 01b6 0E94 0000 		call vListInitialise
2391:../../Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 476               	.LM45:
 477 01ba 80E0      		ldi r24,lo8(xPendingReadyList)
 478 01bc 90E0      		ldi r25,hi8(xPendingReadyList)
 479 01be 0E94 0000 		call vListInitialise
2395:../../Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 481               	.LM46:
 482 01c2 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 483 01c4 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 484 01c6 0E94 0000 		call vListInitialise
2407:../../Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 486               	.LM47:
 487 01ca 80E0      		ldi r24,lo8(xDelayedTaskList1)
 488 01cc 90E0      		ldi r25,hi8(xDelayedTaskList1)
 489 01ce 9093 0000 		sts pxDelayedTaskList+1,r25
 490 01d2 8093 0000 		sts pxDelayedTaskList,r24
2408:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 492               	.LM48:
 493 01d6 80E0      		ldi r24,lo8(xDelayedTaskList2)
 494 01d8 90E0      		ldi r25,hi8(xDelayedTaskList2)
 495 01da 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 496 01de 8093 0000 		sts pxOverflowDelayedTaskList,r24
 497 01e2 00C0      		rjmp .L14
 498               	.L12:
 499               	.LBE23:
 500               	.LBE22:
 592:../../Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 502               	.LM49:
 503 01e4 8091 0000 		lds r24,xSchedulerRunning
 504 01e8 8111      		cpse r24,__zero_reg__
 505 01ea 00C0      		rjmp .L14
 594:../../Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 507               	.LM50:
 508 01ec E091 0000 		lds r30,pxCurrentTCB
 509 01f0 F091 0000 		lds r31,pxCurrentTCB+1
 510 01f4 8689      		ldd r24,Z+22
 511 01f6 0817      		cp r16,r24
 512 01f8 00F0      		brlo .L14
 596:../../Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 514               	.LM51:
 515 01fa D093 0000 		sts pxCurrentTCB+1,r29
 516 01fe C093 0000 		sts pxCurrentTCB,r28
 517               	.L14:
 601:../../Source/tasks.c **** 			uxTaskNumber++;
 519               	.LM52:
 520 0202 8091 0000 		lds r24,uxTaskNumber
 521 0206 8F5F      		subi r24,lo8(-(1))
 522 0208 8093 0000 		sts uxTaskNumber,r24
 611:../../Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 524               	.LM53:
 525 020c 8E89      		ldd r24,Y+22
 526 020e 9091 0000 		lds r25,uxTopReadyPriority
 527 0212 9817      		cp r25,r24
 528 0214 00F4      		brsh .L16
 611:../../Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 530               	.LM54:
 531 0216 8093 0000 		sts uxTopReadyPriority,r24
 532               	.L16:
 611:../../Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 534               	.LM55:
 535 021a A9E0      		ldi r26,lo8(9)
 536 021c 8A9F      		mul r24,r26
 537 021e C001      		movw r24,r0
 538 0220 1124      		clr __zero_reg__
 539 0222 B601      		movw r22,r12
 540 0224 8050      		subi r24,lo8(-(pxReadyTasksLists))
 541 0226 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 542 0228 0E94 0000 		call vListInsertEnd
 616:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
 544               	.LM56:
 545               	/* #APP */
 546               	 ;  616 "../../Source/tasks.c" 1
 547 022c 0F90      		pop		__tmp_reg__
 548               	 ;  0 "" 2
 549               	 ;  616 "../../Source/tasks.c" 1
 550 022e 0FBE      		out		__SREG__, __tmp_reg__
 551               	 ;  0 "" 2
 552               	/* #NOAPP */
 553               	.LBE19:
 626:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 555               	.LM57:
 556 0230 8091 0000 		lds r24,xSchedulerRunning
 557 0234 8823      		tst r24
 558 0236 01F0      		breq .L20
 630:../../Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 560               	.LM58:
 561 0238 E091 0000 		lds r30,pxCurrentTCB
 562 023c F091 0000 		lds r31,pxCurrentTCB+1
 563 0240 8689      		ldd r24,Z+22
 564 0242 8017      		cp r24,r16
 565 0244 00F4      		brsh .L20
 632:../../Source/tasks.c **** 				taskYIELD_IF_USING_PREEMPTION();
 567               	.LM59:
 568 0246 0E94 0000 		call vPortYield
 569               	.L20:
 613:../../Source/tasks.c **** 			xReturn = pdPASS;
 571               	.LM60:
 572 024a 81E0      		ldi r24,lo8(1)
 573 024c 00C0      		rjmp .L32
 574               	.L5:
 575               	.LBB24:
 620:../../Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 577               	.LM61:
 578 024e 8FEF      		ldi r24,lo8(-1)
 579               	.L32:
 580               	/* epilogue start */
 581               	.LBE24:
 638:../../Source/tasks.c **** }
 583               	.LM62:
 584 0250 DF91      		pop r29
 585 0252 CF91      		pop r28
 586 0254 1F91      		pop r17
 587 0256 0F91      		pop r16
 588 0258 FF90      		pop r15
 589 025a EF90      		pop r14
 590 025c DF90      		pop r13
 591 025e CF90      		pop r12
 592 0260 BF90      		pop r11
 593 0262 AF90      		pop r10
 594 0264 9F90      		pop r9
 595 0266 8F90      		pop r8
 596 0268 7F90      		pop r7
 597 026a 6F90      		pop r6
 598 026c 5F90      		pop r5
 599 026e 4F90      		pop r4
 600 0270 3F90      		pop r3
 601 0272 0895      		ret
 613               	.Lscope2:
 615               		.stabd	78,0,0
 618               	.global	vTaskDelete
 620               	vTaskDelete:
 621               		.stabd	46,0,0
 644:../../Source/tasks.c **** 	{
 623               	.LM63:
 624               	.LFBB3:
 625 0274 0F93      		push r16
 626 0276 1F93      		push r17
 627 0278 CF93      		push r28
 628 027a DF93      		push r29
 629               	/* prologue: function */
 630               	/* frame size = 0 */
 631               	/* stack size = 4 */
 632               	.L__stack_usage = 4
 647:../../Source/tasks.c **** 		taskENTER_CRITICAL();
 634               	.LM64:
 635               	/* #APP */
 636               	 ;  647 "../../Source/tasks.c" 1
 637 027c 0FB6      		in		__tmp_reg__, __SREG__
 638               	 ;  0 "" 2
 639               	 ;  647 "../../Source/tasks.c" 1
 640 027e F894      		cli
 641               	 ;  0 "" 2
 642               	 ;  647 "../../Source/tasks.c" 1
 643 0280 0F92      		push	__tmp_reg__
 644               	 ;  0 "" 2
 650:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 646               	.LM65:
 647               	/* #NOAPP */
 648 0282 0097      		sbiw r24,0
 649 0284 01F4      		brne .L37
 650:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 651               	.LM66:
 652 0286 C091 0000 		lds r28,pxCurrentTCB
 653 028a D091 0000 		lds r29,pxCurrentTCB+1
 654 028e 00C0      		rjmp .L34
 655               	.L37:
 650:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 657               	.LM67:
 658 0290 EC01      		movw r28,r24
 659               	.L34:
 656:../../Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 661               	.LM68:
 662 0292 8E01      		movw r16,r28
 663 0294 0E5F      		subi r16,-2
 664 0296 1F4F      		sbci r17,-1
 665 0298 C801      		movw r24,r16
 666 029a 0E94 0000 		call uxListRemove
 662:../../Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 668               	.LM69:
 669 029e 8C89      		ldd r24,Y+20
 670 02a0 9D89      		ldd r25,Y+21
 671 02a2 892B      		or r24,r25
 672 02a4 01F0      		breq .L35
 664:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 674               	.LM70:
 675 02a6 CE01      		movw r24,r28
 676 02a8 0C96      		adiw r24,12
 677 02aa 0E94 0000 		call uxListRemove
 678               	.L35:
 667:../../Source/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 680               	.LM71:
 681 02ae B801      		movw r22,r16
 682 02b0 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 683 02b2 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 684 02b4 0E94 0000 		call vListInsertEnd
 672:../../Source/tasks.c **** 			++uxTasksDeleted;
 686               	.LM72:
 687 02b8 8091 0000 		lds r24,uxTasksDeleted
 688 02bc 8F5F      		subi r24,lo8(-(1))
 689 02be 8093 0000 		sts uxTasksDeleted,r24
 676:../../Source/tasks.c **** 			uxTaskNumber++;
 691               	.LM73:
 692 02c2 8091 0000 		lds r24,uxTaskNumber
 693 02c6 8F5F      		subi r24,lo8(-(1))
 694 02c8 8093 0000 		sts uxTaskNumber,r24
 680:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
 696               	.LM74:
 697               	/* #APP */
 698               	 ;  680 "../../Source/tasks.c" 1
 699 02cc 0F90      		pop		__tmp_reg__
 700               	 ;  0 "" 2
 701               	 ;  680 "../../Source/tasks.c" 1
 702 02ce 0FBE      		out		__SREG__, __tmp_reg__
 703               	 ;  0 "" 2
 683:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 705               	.LM75:
 706               	/* #NOAPP */
 707 02d0 8091 0000 		lds r24,xSchedulerRunning
 708 02d4 8823      		tst r24
 709 02d6 01F0      		breq .L33
 685:../../Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 711               	.LM76:
 712 02d8 8091 0000 		lds r24,pxCurrentTCB
 713 02dc 9091 0000 		lds r25,pxCurrentTCB+1
 714 02e0 C817      		cp r28,r24
 715 02e2 D907      		cpc r29,r25
 716 02e4 01F4      		brne .L33
 687:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
 718               	.LM77:
 719 02e6 0E94 0000 		call vPortYield
 720               	.L33:
 721               	/* epilogue start */
 690:../../Source/tasks.c **** 	}
 723               	.LM78:
 724 02ea DF91      		pop r29
 725 02ec CF91      		pop r28
 726 02ee 1F91      		pop r17
 727 02f0 0F91      		pop r16
 728 02f2 0895      		ret
 733               	.Lscope3:
 735               		.stabd	78,0,0
 736               		.section	.rodata.str1.1,"aMS",@progbits,1
 737               	.LC0:
 738 0000 4944 4C45 		.string	"IDLE"
 738      00
 739               		.text
 741               	.global	vTaskStartScheduler
 743               	vTaskStartScheduler:
 744               		.stabd	46,0,0
1243:../../Source/tasks.c **** {
 746               	.LM79:
 747               	.LFBB4:
 748 02f4 AF92      		push r10
 749 02f6 BF92      		push r11
 750 02f8 CF92      		push r12
 751 02fa DF92      		push r13
 752 02fc EF92      		push r14
 753 02fe FF92      		push r15
 754 0300 0F93      		push r16
 755               	/* prologue: function */
 756               	/* frame size = 0 */
 757               	/* stack size = 7 */
 758               	.L__stack_usage = 7
1256:../../Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 760               	.LM80:
 761 0302 A12C      		mov r10,__zero_reg__
 762 0304 B12C      		mov r11,__zero_reg__
 763 0306 C12C      		mov r12,__zero_reg__
 764 0308 D12C      		mov r13,__zero_reg__
 765 030a E12C      		mov r14,__zero_reg__
 766 030c F12C      		mov r15,__zero_reg__
 767 030e 00E0      		ldi r16,0
 768 0310 20E0      		ldi r18,0
 769 0312 30E0      		ldi r19,0
 770 0314 45E5      		ldi r20,lo8(85)
 771 0316 50E0      		ldi r21,0
 772 0318 60E0      		ldi r22,lo8(.LC0)
 773 031a 70E0      		ldi r23,hi8(.LC0)
 774 031c 80E0      		ldi r24,lo8(gs(prvIdleTask))
 775 031e 90E0      		ldi r25,hi8(gs(prvIdleTask))
 776 0320 0E94 0000 		call xTaskGenericCreate
1269:../../Source/tasks.c **** 	if( xReturn == pdPASS )
 778               	.LM81:
 779 0324 8130      		cpi r24,lo8(1)
 780 0326 01F4      		brne .L44
1276:../../Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 782               	.LM82:
 783               	/* #APP */
 784               	 ;  1276 "../../Source/tasks.c" 1
 785 0328 F894      		cli
 786               	 ;  0 "" 2
1286:../../Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 788               	.LM83:
 789               	/* #NOAPP */
 790 032a 8093 0000 		sts xSchedulerRunning,r24
1287:../../Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 792               	.LM84:
 793 032e 1092 0000 		sts xTickCount+1,__zero_reg__
 794 0332 1092 0000 		sts xTickCount,__zero_reg__
 795               	/* epilogue start */
1313:../../Source/tasks.c **** }
 797               	.LM85:
 798 0336 0F91      		pop r16
 799 0338 FF90      		pop r15
 800 033a EF90      		pop r14
 801 033c DF90      		pop r13
 802 033e CF90      		pop r12
 803 0340 BF90      		pop r11
 804 0342 AF90      		pop r10
1296:../../Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 806               	.LM86:
 807 0344 0C94 0000 		jmp xPortStartScheduler
 808               	.L44:
 809               	/* epilogue start */
1313:../../Source/tasks.c **** }
 811               	.LM87:
 812 0348 0F91      		pop r16
 813 034a FF90      		pop r15
 814 034c EF90      		pop r14
 815 034e DF90      		pop r13
 816 0350 CF90      		pop r12
 817 0352 BF90      		pop r11
 818 0354 AF90      		pop r10
 819 0356 0895      		ret
 821               	.Lscope4:
 823               		.stabd	78,0,0
 825               	.global	vTaskEndScheduler
 827               	vTaskEndScheduler:
 828               		.stabd	46,0,0
1317:../../Source/tasks.c **** {
 830               	.LM88:
 831               	.LFBB5:
 832               	/* prologue: function */
 833               	/* frame size = 0 */
 834               	/* stack size = 0 */
 835               	.L__stack_usage = 0
1321:../../Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 837               	.LM89:
 838               	/* #APP */
 839               	 ;  1321 "../../Source/tasks.c" 1
 840 0358 F894      		cli
 841               	 ;  0 "" 2
1322:../../Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 843               	.LM90:
 844               	/* #NOAPP */
 845 035a 1092 0000 		sts xSchedulerRunning,__zero_reg__
1323:../../Source/tasks.c **** 	vPortEndScheduler();
 847               	.LM91:
 848 035e 0C94 0000 		jmp vPortEndScheduler
 850               	.Lscope5:
 852               		.stabd	78,0,0
 854               	.global	vTaskSuspendAll
 856               	vTaskSuspendAll:
 857               		.stabd	46,0,0
1328:../../Source/tasks.c **** {
 859               	.LM92:
 860               	.LFBB6:
 861               	/* prologue: function */
 862               	/* frame size = 0 */
 863               	/* stack size = 0 */
 864               	.L__stack_usage = 0
1331:../../Source/tasks.c **** 	++uxSchedulerSuspended;
 866               	.LM93:
 867 0362 8091 0000 		lds r24,uxSchedulerSuspended
 868 0366 8F5F      		subi r24,lo8(-(1))
 869 0368 8093 0000 		sts uxSchedulerSuspended,r24
 870 036c 0895      		ret
 872               	.Lscope6:
 874               		.stabd	78,0,0
 876               	.global	xTaskGetTickCount
 878               	xTaskGetTickCount:
 879               		.stabd	46,0,0
1436:../../Source/tasks.c **** {
 881               	.LM94:
 882               	.LFBB7:
 883               	/* prologue: function */
 884               	/* frame size = 0 */
 885               	/* stack size = 0 */
 886               	.L__stack_usage = 0
1440:../../Source/tasks.c **** 	taskENTER_CRITICAL();
 888               	.LM95:
 889               	/* #APP */
 890               	 ;  1440 "../../Source/tasks.c" 1
 891 036e 0FB6      		in		__tmp_reg__, __SREG__
 892               	 ;  0 "" 2
 893               	 ;  1440 "../../Source/tasks.c" 1
 894 0370 F894      		cli
 895               	 ;  0 "" 2
 896               	 ;  1440 "../../Source/tasks.c" 1
 897 0372 0F92      		push	__tmp_reg__
 898               	 ;  0 "" 2
1442:../../Source/tasks.c **** 		xTicks = xTickCount;
 900               	.LM96:
 901               	/* #NOAPP */
 902 0374 2091 0000 		lds r18,xTickCount
 903 0378 3091 0000 		lds r19,xTickCount+1
1444:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
 905               	.LM97:
 906               	/* #APP */
 907               	 ;  1444 "../../Source/tasks.c" 1
 908 037c 0F90      		pop		__tmp_reg__
 909               	 ;  0 "" 2
 910               	 ;  1444 "../../Source/tasks.c" 1
 911 037e 0FBE      		out		__SREG__, __tmp_reg__
 912               	 ;  0 "" 2
1447:../../Source/tasks.c **** }
 914               	.LM98:
 915               	/* #NOAPP */
 916 0380 C901      		movw r24,r18
 917 0382 0895      		ret
 922               	.Lscope7:
 924               		.stabd	78,0,0
 926               	.global	xTaskGetTickCountFromISR
 928               	xTaskGetTickCountFromISR:
 929               		.stabd	46,0,0
1451:../../Source/tasks.c **** {
 931               	.LM99:
 932               	.LFBB8:
 933               	/* prologue: function */
 934               	/* frame size = 0 */
 935               	/* stack size = 0 */
 936               	.L__stack_usage = 0
1472:../../Source/tasks.c **** 	xReturn = xTickCount;
 938               	.LM100:
 939 0384 2091 0000 		lds r18,xTickCount
 940 0388 3091 0000 		lds r19,xTickCount+1
1476:../../Source/tasks.c **** }
 942               	.LM101:
 943 038c C901      		movw r24,r18
 944 038e 0895      		ret
 949               	.Lscope8:
 951               		.stabd	78,0,0
 953               	.global	uxTaskGetNumberOfTasks
 955               	uxTaskGetNumberOfTasks:
 956               		.stabd	46,0,0
1480:../../Source/tasks.c **** {
 958               	.LM102:
 959               	.LFBB9:
 960               	/* prologue: function */
 961               	/* frame size = 0 */
 962               	/* stack size = 0 */
 963               	.L__stack_usage = 0
1483:../../Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 965               	.LM103:
 966 0390 8091 0000 		lds r24,uxCurrentNumberOfTasks
1484:../../Source/tasks.c **** }
 968               	.LM104:
 969 0394 0895      		ret
 971               	.Lscope9:
 973               		.stabd	78,0,0
 975               	.global	xTaskIncrementTick
 977               	xTaskIncrementTick:
 978               		.stabd	46,0,0
1605:../../Source/tasks.c **** {
 980               	.LM105:
 981               	.LFBB10:
 982 0396 CF92      		push r12
 983 0398 DF92      		push r13
 984 039a EF92      		push r14
 985 039c FF92      		push r15
 986 039e 0F93      		push r16
 987 03a0 1F93      		push r17
 988 03a2 CF93      		push r28
 989 03a4 DF93      		push r29
 990               	/* prologue: function */
 991               	/* frame size = 0 */
 992               	/* stack size = 8 */
 993               	.L__stack_usage = 8
1614:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 995               	.LM106:
 996 03a6 8091 0000 		lds r24,uxSchedulerSuspended
 997 03aa 8111      		cpse r24,__zero_reg__
 998 03ac 00C0      		rjmp .L52
1618:../../Source/tasks.c **** 		++xTickCount;
 1000               	.LM107:
 1001 03ae 8091 0000 		lds r24,xTickCount
 1002 03b2 9091 0000 		lds r25,xTickCount+1
 1003 03b6 0196      		adiw r24,1
 1004 03b8 9093 0000 		sts xTickCount+1,r25
 1005 03bc 8093 0000 		sts xTickCount,r24
 1006               	.LBB25:
1623:../../Source/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
 1008               	.LM108:
 1009 03c0 0091 0000 		lds r16,xTickCount
 1010 03c4 1091 0000 		lds r17,xTickCount+1
1625:../../Source/tasks.c **** 			if( xConstTickCount == ( portTickType ) 0U )
 1012               	.LM109:
 1013 03c8 0115      		cp r16,__zero_reg__
 1014 03ca 1105      		cpc r17,__zero_reg__
 1015 03cc 01F4      		brne .L53
 1016               	.LBB26:
1627:../../Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 1018               	.LM110:
 1019 03ce 8091 0000 		lds r24,pxDelayedTaskList
 1020 03d2 9091 0000 		lds r25,pxDelayedTaskList+1
 1021 03d6 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1022 03da 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1023 03de 3093 0000 		sts pxDelayedTaskList+1,r19
 1024 03e2 2093 0000 		sts pxDelayedTaskList,r18
 1025 03e6 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1026 03ea 8093 0000 		sts pxOverflowDelayedTaskList,r24
 1027 03ee 8091 0000 		lds r24,xNumOfOverflows
 1028 03f2 8F5F      		subi r24,lo8(-(1))
 1029 03f4 8093 0000 		sts xNumOfOverflows,r24
 1030 03f8 E091 0000 		lds r30,pxDelayedTaskList
 1031 03fc F091 0000 		lds r31,pxDelayedTaskList+1
 1032 0400 8081      		ld r24,Z
 1033 0402 8111      		cpse r24,__zero_reg__
 1034 0404 00C0      		rjmp .L54
1627:../../Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 1036               	.LM111:
 1037 0406 8FEF      		ldi r24,lo8(-1)
 1038 0408 9FEF      		ldi r25,lo8(-1)
 1039 040a 00C0      		rjmp .L73
 1040               	.L54:
1627:../../Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 1042               	.LM112:
 1043 040c E091 0000 		lds r30,pxDelayedTaskList
 1044 0410 F091 0000 		lds r31,pxDelayedTaskList+1
 1045 0414 0580      		ldd __tmp_reg__,Z+5
 1046 0416 F681      		ldd r31,Z+6
 1047 0418 E02D      		mov r30,__tmp_reg__
 1048 041a 0680      		ldd __tmp_reg__,Z+6
 1049 041c F781      		ldd r31,Z+7
 1050 041e E02D      		mov r30,__tmp_reg__
 1051 0420 8281      		ldd r24,Z+2
 1052 0422 9381      		ldd r25,Z+3
 1053               	.L73:
 1054 0424 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1055 0428 8093 0000 		sts xNextTaskUnblockTime,r24
 1056               	.L53:
 1057               	.LBE26:
1634:../../Source/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
 1059               	.LM113:
 1060 042c 8091 0000 		lds r24,xNextTaskUnblockTime
 1061 0430 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1062 0434 D12C      		mov r13,__zero_reg__
 1063 0436 0817      		cp r16,r24
 1064 0438 1907      		cpc r17,r25
 1065 043a 00F4      		brsh .L65
 1066 043c 00C0      		rjmp .L56
 1067               	.L66:
1690:../../Source/tasks.c **** 								xSwitchRequired = pdTRUE;
 1069               	.LM114:
 1070 043e DD24      		clr r13
 1071 0440 D394      		inc r13
 1072 0442 00C0      		rjmp .L72
 1073               	.L65:
1678:../../Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1075               	.LM115:
 1076 0444 89E0      		ldi r24,lo8(9)
 1077 0446 C82E      		mov r12,r24
 1078               	.L72:
1638:../../Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1080               	.LM116:
 1081 0448 E091 0000 		lds r30,pxDelayedTaskList
 1082 044c F091 0000 		lds r31,pxDelayedTaskList+1
 1083 0450 8081      		ld r24,Z
 1084 0452 8111      		cpse r24,__zero_reg__
 1085 0454 00C0      		rjmp .L57
1644:../../Source/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
 1087               	.LM117:
 1088 0456 8FEF      		ldi r24,lo8(-1)
 1089 0458 9FEF      		ldi r25,lo8(-1)
 1090 045a 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1091 045e 8093 0000 		sts xNextTaskUnblockTime,r24
1645:../../Source/tasks.c **** 						break;
 1093               	.LM118:
 1094 0462 00C0      		rjmp .L56
 1095               	.L57:
1653:../../Source/tasks.c **** 						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1097               	.LM119:
 1098 0464 E091 0000 		lds r30,pxDelayedTaskList
 1099 0468 F091 0000 		lds r31,pxDelayedTaskList+1
 1100 046c 0580      		ldd __tmp_reg__,Z+5
 1101 046e F681      		ldd r31,Z+6
 1102 0470 E02D      		mov r30,__tmp_reg__
 1103 0472 C681      		ldd r28,Z+6
 1104 0474 D781      		ldd r29,Z+7
1654:../../Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1106               	.LM120:
 1107 0476 2A81      		ldd r18,Y+2
 1108 0478 3B81      		ldd r19,Y+3
1656:../../Source/tasks.c **** 						if( xConstTickCount < xItemValue )
 1110               	.LM121:
 1111 047a 0217      		cp r16,r18
 1112 047c 1307      		cpc r17,r19
 1113 047e 00F4      		brsh .L58
1662:../../Source/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
 1115               	.LM122:
 1116 0480 3093 0000 		sts xNextTaskUnblockTime+1,r19
 1117 0484 2093 0000 		sts xNextTaskUnblockTime,r18
1663:../../Source/tasks.c **** 							break;
 1119               	.LM123:
 1120 0488 00C0      		rjmp .L56
 1121               	.L58:
1667:../../Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1123               	.LM124:
 1124 048a 7E01      		movw r14,r28
 1125 048c 82E0      		ldi r24,2
 1126 048e E80E      		add r14,r24
 1127 0490 F11C      		adc r15,__zero_reg__
 1128 0492 C701      		movw r24,r14
 1129 0494 0E94 0000 		call uxListRemove
1671:../../Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1131               	.LM125:
 1132 0498 2C89      		ldd r18,Y+20
 1133 049a 3D89      		ldd r19,Y+21
 1134 049c 232B      		or r18,r19
 1135 049e 01F0      		breq .L59
1673:../../Source/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1137               	.LM126:
 1138 04a0 CE01      		movw r24,r28
 1139 04a2 0C96      		adiw r24,12
 1140 04a4 0E94 0000 		call uxListRemove
 1141               	.L59:
1678:../../Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1143               	.LM127:
 1144 04a8 2E89      		ldd r18,Y+22
 1145 04aa 8091 0000 		lds r24,uxTopReadyPriority
 1146 04ae 8217      		cp r24,r18
 1147 04b0 00F4      		brsh .L60
1678:../../Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1149               	.LM128:
 1150 04b2 2093 0000 		sts uxTopReadyPriority,r18
 1151               	.L60:
1678:../../Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1153               	.LM129:
 1154 04b6 C29E      		mul r12,r18
 1155 04b8 C001      		movw r24,r0
 1156 04ba 1124      		clr __zero_reg__
 1157 04bc B701      		movw r22,r14
 1158 04be 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1159 04c0 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1160 04c2 0E94 0000 		call vListInsertEnd
1688:../../Source/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1162               	.LM130:
 1163 04c6 E091 0000 		lds r30,pxCurrentTCB
 1164 04ca F091 0000 		lds r31,pxCurrentTCB+1
 1165 04ce 9E89      		ldd r25,Y+22
 1166 04d0 8689      		ldd r24,Z+22
 1167 04d2 9817      		cp r25,r24
 1168 04d4 00F0      		brlo .+2
 1169 04d6 00C0      		rjmp .L66
 1170 04d8 00C0      		rjmp .L72
 1171               	.L56:
 1172               	.LBE25:
1704:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned p
 1174               	.LM131:
 1175 04da E091 0000 		lds r30,pxCurrentTCB
 1176 04de F091 0000 		lds r31,pxCurrentTCB+1
 1177 04e2 E689      		ldd r30,Z+22
 1178 04e4 89E0      		ldi r24,lo8(9)
 1179 04e6 E89F      		mul r30,r24
 1180 04e8 F001      		movw r30,r0
 1181 04ea 1124      		clr __zero_reg__
 1182 04ec E050      		subi r30,lo8(-(pxReadyTasksLists))
 1183 04ee F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1184 04f0 8081      		ld r24,Z
 1185 04f2 8230      		cpi r24,lo8(2)
 1186 04f4 00F4      		brsh .L67
 1187 04f6 00C0      		rjmp .L63
 1188               	.L52:
1724:../../Source/tasks.c **** 		++uxPendedTicks;
 1190               	.LM132:
 1191 04f8 8091 0000 		lds r24,uxPendedTicks
 1192 04fc 8F5F      		subi r24,lo8(-(1))
 1193 04fe 8093 0000 		sts uxPendedTicks,r24
1608:../../Source/tasks.c **** portBASE_TYPE xSwitchRequired = pdFALSE;
 1195               	.LM133:
 1196 0502 D12C      		mov r13,__zero_reg__
 1197 0504 00C0      		rjmp .L63
 1198               	.L67:
1706:../../Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 1200               	.LM134:
 1201 0506 DD24      		clr r13
 1202 0508 D394      		inc r13
 1203               	.L63:
1737:../../Source/tasks.c **** 		if( xYieldPending != pdFALSE )
 1205               	.LM135:
 1206 050a 8091 0000 		lds r24,xYieldPending
 1207 050e 8823      		tst r24
 1208 0510 01F0      		breq .L64
1739:../../Source/tasks.c **** 			xSwitchRequired = pdTRUE;
 1210               	.LM136:
 1211 0512 DD24      		clr r13
 1212 0514 D394      		inc r13
 1213               	.L64:
1745:../../Source/tasks.c **** }
 1215               	.LM137:
 1216 0516 8D2D      		mov r24,r13
 1217               	/* epilogue start */
 1218 0518 DF91      		pop r29
 1219 051a CF91      		pop r28
 1220 051c 1F91      		pop r17
 1221 051e 0F91      		pop r16
 1222 0520 FF90      		pop r15
 1223 0522 EF90      		pop r14
 1224 0524 DF90      		pop r13
 1225 0526 CF90      		pop r12
 1226 0528 0895      		ret
 1238               	.Lscope10:
 1240               		.stabd	78,0,0
 1242               	.global	xTaskResumeAll
 1244               	xTaskResumeAll:
 1245               		.stabd	46,0,0
1364:../../Source/tasks.c **** {
 1247               	.LM138:
 1248               	.LFBB11:
 1249 052a EF92      		push r14
 1250 052c FF92      		push r15
 1251 052e 0F93      		push r16
 1252 0530 1F93      		push r17
 1253 0532 CF93      		push r28
 1254 0534 DF93      		push r29
 1255               	/* prologue: function */
 1256               	/* frame size = 0 */
 1257               	/* stack size = 6 */
 1258               	.L__stack_usage = 6
1377:../../Source/tasks.c **** 	taskENTER_CRITICAL();
 1260               	.LM139:
 1261               	/* #APP */
 1262               	 ;  1377 "../../Source/tasks.c" 1
 1263 0536 0FB6      		in		__tmp_reg__, __SREG__
 1264               	 ;  0 "" 2
 1265               	 ;  1377 "../../Source/tasks.c" 1
 1266 0538 F894      		cli
 1267               	 ;  0 "" 2
 1268               	 ;  1377 "../../Source/tasks.c" 1
 1269 053a 0F92      		push	__tmp_reg__
 1270               	 ;  0 "" 2
1379:../../Source/tasks.c **** 		--uxSchedulerSuspended;
 1272               	.LM140:
 1273               	/* #NOAPP */
 1274 053c 8091 0000 		lds r24,uxSchedulerSuspended
 1275 0540 8150      		subi r24,lo8(-(-1))
 1276 0542 8093 0000 		sts uxSchedulerSuspended,r24
1381:../../Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1278               	.LM141:
 1279 0546 8091 0000 		lds r24,uxSchedulerSuspended
 1280 054a 8823      		tst r24
 1281 054c 01F0      		breq .L75
 1282               	.L78:
1366:../../Source/tasks.c **** portBASE_TYPE xAlreadyYielded = pdFALSE;
 1284               	.LM142:
 1285 054e 80E0      		ldi r24,0
 1286 0550 00C0      		rjmp .L76
 1287               	.L75:
1383:../../Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1289               	.LM143:
 1290 0552 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1291 0556 8111      		cpse r24,__zero_reg__
 1292 0558 00C0      		rjmp .L90
 1293 055a 00C0      		rjmp .L78
 1294               	.L81:
1389:../../Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 1296               	.LM144:
 1297 055c E091 0000 		lds r30,xPendingReadyList+5
 1298 0560 F091 0000 		lds r31,xPendingReadyList+5+1
 1299 0564 C681      		ldd r28,Z+6
 1300 0566 D781      		ldd r29,Z+7
1390:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1302               	.LM145:
 1303 0568 CE01      		movw r24,r28
 1304 056a 0C96      		adiw r24,12
 1305 056c 0E94 0000 		call uxListRemove
1391:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1307               	.LM146:
 1308 0570 8E01      		movw r16,r28
 1309 0572 0E5F      		subi r16,-2
 1310 0574 1F4F      		sbci r17,-1
 1311 0576 C801      		movw r24,r16
 1312 0578 0E94 0000 		call uxListRemove
1392:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1314               	.LM147:
 1315 057c 8E89      		ldd r24,Y+22
 1316 057e 9091 0000 		lds r25,uxTopReadyPriority
 1317 0582 9817      		cp r25,r24
 1318 0584 00F4      		brsh .L79
1392:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1320               	.LM148:
 1321 0586 8093 0000 		sts uxTopReadyPriority,r24
 1322               	.L79:
1392:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1324               	.LM149:
 1325 058a F89E      		mul r15,r24
 1326 058c C001      		movw r24,r0
 1327 058e 1124      		clr __zero_reg__
 1328 0590 B801      		movw r22,r16
 1329 0592 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1330 0594 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1331 0596 0E94 0000 		call vListInsertEnd
1396:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1333               	.LM150:
 1334 059a E091 0000 		lds r30,pxCurrentTCB
 1335 059e F091 0000 		lds r31,pxCurrentTCB+1
 1336 05a2 9E89      		ldd r25,Y+22
 1337 05a4 8689      		ldd r24,Z+22
 1338 05a6 9817      		cp r25,r24
 1339 05a8 00F0      		brlo .L93
1398:../../Source/tasks.c **** 						xYieldPending = pdTRUE;
 1341               	.LM151:
 1342 05aa E092 0000 		sts xYieldPending,r14
 1343 05ae 00C0      		rjmp .L93
 1344               	.L90:
1392:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1346               	.LM152:
 1347 05b0 99E0      		ldi r25,lo8(9)
 1348 05b2 F92E      		mov r15,r25
1398:../../Source/tasks.c **** 						xYieldPending = pdTRUE;
 1350               	.LM153:
 1351 05b4 EE24      		clr r14
 1352 05b6 E394      		inc r14
 1353               	.L93:
1387:../../Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1355               	.LM154:
 1356 05b8 8091 0000 		lds r24,xPendingReadyList
 1357 05bc 8111      		cpse r24,__zero_reg__
 1358 05be 00C0      		rjmp .L81
1405:../../Source/tasks.c **** 				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 1360               	.LM155:
 1361 05c0 8091 0000 		lds r24,uxPendedTicks
 1362 05c4 8111      		cpse r24,__zero_reg__
 1363 05c6 00C0      		rjmp .L82
 1364               	.L86:
1417:../../Source/tasks.c **** 				if( xYieldPending == pdTRUE )
 1366               	.LM156:
 1367 05c8 8091 0000 		lds r24,xYieldPending
 1368 05cc 8130      		cpi r24,lo8(1)
 1369 05ce 01F0      		breq .+2
 1370 05d0 00C0      		rjmp .L78
 1371 05d2 00C0      		rjmp .L83
 1372               	.L85:
1409:../../Source/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
 1374               	.LM157:
 1375 05d4 0E94 0000 		call xTaskIncrementTick
 1376 05d8 8111      		cpse r24,__zero_reg__
1411:../../Source/tasks.c **** 							xYieldPending = pdTRUE;
 1378               	.LM158:
 1379 05da C093 0000 		sts xYieldPending,r28
 1380               	.L84:
1413:../../Source/tasks.c **** 						--uxPendedTicks;
 1382               	.LM159:
 1383 05de 8091 0000 		lds r24,uxPendedTicks
 1384 05e2 8150      		subi r24,lo8(-(-1))
 1385 05e4 8093 0000 		sts uxPendedTicks,r24
 1386 05e8 00C0      		rjmp .L94
 1387               	.L82:
1411:../../Source/tasks.c **** 							xYieldPending = pdTRUE;
 1389               	.LM160:
 1390 05ea C1E0      		ldi r28,lo8(1)
 1391               	.L94:
1407:../../Source/tasks.c **** 					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 1393               	.LM161:
 1394 05ec 8091 0000 		lds r24,uxPendedTicks
 1395 05f0 8111      		cpse r24,__zero_reg__
 1396 05f2 00C0      		rjmp .L85
 1397 05f4 00C0      		rjmp .L86
 1398               	.L83:
1424:../../Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1400               	.LM162:
 1401 05f6 0E94 0000 		call vPortYield
1421:../../Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
 1403               	.LM163:
 1404 05fa 81E0      		ldi r24,lo8(1)
 1405               	.L76:
1429:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
 1407               	.LM164:
 1408               	/* #APP */
 1409               	 ;  1429 "../../Source/tasks.c" 1
 1410 05fc 0F90      		pop		__tmp_reg__
 1411               	 ;  0 "" 2
 1412               	 ;  1429 "../../Source/tasks.c" 1
 1413 05fe 0FBE      		out		__SREG__, __tmp_reg__
 1414               	 ;  0 "" 2
 1415               	/* epilogue start */
1432:../../Source/tasks.c **** }
 1417               	.LM165:
 1418               	/* #NOAPP */
 1419 0600 DF91      		pop r29
 1420 0602 CF91      		pop r28
 1421 0604 1F91      		pop r17
 1422 0606 0F91      		pop r16
 1423 0608 FF90      		pop r15
 1424 060a EF90      		pop r14
 1425 060c 0895      		ret
 1431               	.Lscope11:
 1433               		.stabd	78,0,0
 1437               	prvIdleTask:
 1438               		.stabd	46,0,0
2150:../../Source/tasks.c **** {
 1440               	.LM166:
 1441               	.LFBB12:
 1442               	/* prologue: function */
 1443               	/* frame size = 0 */
 1444               	/* stack size = 0 */
 1445               	.L__stack_usage = 0
 1446 060e 00C0      		rjmp .L105
 1447               	.L98:
 1448               	.LBB34:
 1449               	.LBB35:
2422:../../Source/tasks.c **** 			vTaskSuspendAll();
 1451               	.LM167:
 1452 0610 0E94 0000 		call vTaskSuspendAll
2423:../../Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 1454               	.LM168:
 1455 0614 C091 0000 		lds r28,xTasksWaitingTermination
2424:../../Source/tasks.c **** 			( void ) xTaskResumeAll();
 1457               	.LM169:
 1458 0618 0E94 0000 		call xTaskResumeAll
2426:../../Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 1460               	.LM170:
 1461 061c CC23      		tst r28
 1462 061e 01F0      		breq .L105
 1463               	.LBB36:
2430:../../Source/tasks.c **** 				taskENTER_CRITICAL();
 1465               	.LM171:
 1466               	/* #APP */
 1467               	 ;  2430 "../../Source/tasks.c" 1
 1468 0620 0FB6      		in		__tmp_reg__, __SREG__
 1469               	 ;  0 "" 2
 1470               	 ;  2430 "../../Source/tasks.c" 1
 1471 0622 F894      		cli
 1472               	 ;  0 "" 2
 1473               	 ;  2430 "../../Source/tasks.c" 1
 1474 0624 0F92      		push	__tmp_reg__
 1475               	 ;  0 "" 2
2432:../../Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 1477               	.LM172:
 1478               	/* #NOAPP */
 1479 0626 E091 0000 		lds r30,xTasksWaitingTermination+5
 1480 062a F091 0000 		lds r31,xTasksWaitingTermination+5+1
 1481 062e C681      		ldd r28,Z+6
 1482 0630 D781      		ldd r29,Z+7
2433:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1484               	.LM173:
 1485 0632 CE01      		movw r24,r28
 1486 0634 0296      		adiw r24,2
 1487 0636 0E94 0000 		call uxListRemove
2434:../../Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 1489               	.LM174:
 1490 063a 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1491 063e 8150      		subi r24,lo8(-(-1))
 1492 0640 8093 0000 		sts uxCurrentNumberOfTasks,r24
2435:../../Source/tasks.c **** 					--uxTasksDeleted;
 1494               	.LM175:
 1495 0644 8091 0000 		lds r24,uxTasksDeleted
 1496 0648 8150      		subi r24,lo8(-(-1))
 1497 064a 8093 0000 		sts uxTasksDeleted,r24
2437:../../Source/tasks.c **** 				taskEXIT_CRITICAL();
 1499               	.LM176:
 1500               	/* #APP */
 1501               	 ;  2437 "../../Source/tasks.c" 1
 1502 064e 0F90      		pop		__tmp_reg__
 1503               	 ;  0 "" 2
 1504               	 ;  2437 "../../Source/tasks.c" 1
 1505 0650 0FBE      		out		__SREG__, __tmp_reg__
 1506               	 ;  0 "" 2
 1507               	/* #NOAPP */
 1508               	.LBB37:
 1509               	.LBB38:
2498:../../Source/tasks.c **** 		}
2499:../../Source/tasks.c **** 	}
2500:../../Source/tasks.c **** 
2501:../../Source/tasks.c **** 	return pxNewTCB;
2502:../../Source/tasks.c **** }
2503:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2504:../../Source/tasks.c **** 
2505:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2506:../../Source/tasks.c **** 
2507:../../Source/tasks.c **** 	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xLi
2508:../../Source/tasks.c **** 	{
2509:../../Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2510:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTask = 0;
2511:../../Source/tasks.c **** 
2512:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( unsigned portBASE_TYPE ) 0 )
2513:../../Source/tasks.c **** 		{
2514:../../Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2515:../../Source/tasks.c **** 
2516:../../Source/tasks.c **** 			/* Populate an xTaskStatusType structure within the
2517:../../Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
2518:../../Source/tasks.c **** 			pxList.  See the definition of xTaskStatusType in task.h for the
2519:../../Source/tasks.c **** 			meaning of each xTaskStatusType structure member. */
2520:../../Source/tasks.c **** 			do
2521:../../Source/tasks.c **** 			{
2522:../../Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2523:../../Source/tasks.c **** 
2524:../../Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xHandle = ( xTaskHandle ) pxNextTCB;
2525:../../Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].pcTaskName = ( const signed char * ) &( pxNextTCB->pcTaskName [ 0 ]
2526:../../Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
2527:../../Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
2528:../../Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
2529:../../Source/tasks.c **** 
2530:../../Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
2531:../../Source/tasks.c **** 				{
2532:../../Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
2533:../../Source/tasks.c **** 				}
2534:../../Source/tasks.c **** 				#else
2535:../../Source/tasks.c **** 				{
2536:../../Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2537:../../Source/tasks.c **** 				}
2538:../../Source/tasks.c **** 				#endif
2539:../../Source/tasks.c **** 
2540:../../Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1 )
2541:../../Source/tasks.c **** 				{
2542:../../Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
2543:../../Source/tasks.c **** 				}
2544:../../Source/tasks.c **** 				#else
2545:../../Source/tasks.c **** 				{
2546:../../Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
2547:../../Source/tasks.c **** 				}
2548:../../Source/tasks.c **** 				#endif
2549:../../Source/tasks.c **** 
2550:../../Source/tasks.c **** 				#if ( portSTACK_GROWTH > 0 )
2551:../../Source/tasks.c **** 				{
2552:../../Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned char
2553:../../Source/tasks.c **** 				}
2554:../../Source/tasks.c **** 				#else
2555:../../Source/tasks.c **** 				{
2556:../../Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned char
2557:../../Source/tasks.c **** 				}
2558:../../Source/tasks.c **** 				#endif
2559:../../Source/tasks.c **** 
2560:../../Source/tasks.c **** 				uxTask++;
2561:../../Source/tasks.c **** 
2562:../../Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2563:../../Source/tasks.c **** 		}
2564:../../Source/tasks.c **** 
2565:../../Source/tasks.c **** 		return uxTask;
2566:../../Source/tasks.c **** 	}
2567:../../Source/tasks.c **** 
2568:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2569:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2570:../../Source/tasks.c **** 
2571:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2572:../../Source/tasks.c **** 
2573:../../Source/tasks.c **** 	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2574:../../Source/tasks.c **** 	{
2575:../../Source/tasks.c **** 	unsigned short usCount = 0U;
2576:../../Source/tasks.c **** 
2577:../../Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2578:../../Source/tasks.c **** 		{
2579:../../Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2580:../../Source/tasks.c **** 			usCount++;
2581:../../Source/tasks.c **** 		}
2582:../../Source/tasks.c **** 
2583:../../Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2584:../../Source/tasks.c **** 
2585:../../Source/tasks.c **** 		return usCount;
2586:../../Source/tasks.c **** 	}
2587:../../Source/tasks.c **** 
2588:../../Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
2589:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2590:../../Source/tasks.c **** 
2591:../../Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2592:../../Source/tasks.c **** 
2593:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2594:../../Source/tasks.c **** 	{
2595:../../Source/tasks.c **** 	tskTCB *pxTCB;
2596:../../Source/tasks.c **** 	unsigned char *pcEndOfStack;
2597:../../Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2598:../../Source/tasks.c **** 
2599:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2600:../../Source/tasks.c **** 
2601:../../Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2602:../../Source/tasks.c **** 		{
2603:../../Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2604:../../Source/tasks.c **** 		}
2605:../../Source/tasks.c **** 		#else
2606:../../Source/tasks.c **** 		{
2607:../../Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2608:../../Source/tasks.c **** 		}
2609:../../Source/tasks.c **** 		#endif
2610:../../Source/tasks.c **** 
2611:../../Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) prvTaskCheckFreeStackSpace( pcEndOfStack );
2612:../../Source/tasks.c **** 
2613:../../Source/tasks.c **** 		return uxReturn;
2614:../../Source/tasks.c **** 	}
2615:../../Source/tasks.c **** 
2616:../../Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
2617:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2618:../../Source/tasks.c **** 
2619:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2620:../../Source/tasks.c **** 
2621:../../Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2622:../../Source/tasks.c **** 	{
2623:../../Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2624:../../Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
2625:../../Source/tasks.c **** 		want to allocate and clean RAM statically. */
2626:../../Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2627:../../Source/tasks.c **** 
2628:../../Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2629:../../Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2630:../../Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 1511               	.LM177:
 1512 0652 8F89      		ldd r24,Y+23
 1513 0654 988D      		ldd r25,Y+24
 1514 0656 0E94 0000 		call vPortFree
2631:../../Source/tasks.c **** 		vPortFree( pxTCB );
 1516               	.LM178:
 1517 065a CE01      		movw r24,r28
 1518 065c 0E94 0000 		call vPortFree
 1519               	.L105:
 1520               	.LBE38:
 1521               	.LBE37:
 1522               	.LBE36:
2420:../../Source/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 1524               	.LM179:
 1525 0660 8091 0000 		lds r24,uxTasksDeleted
 1526 0664 8111      		cpse r24,__zero_reg__
 1527 0666 00C0      		rjmp .L98
 1528               	.LBE35:
 1529               	.LBE34:
2180:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 1531               	.LM180:
 1532 0668 8091 0000 		lds r24,pxReadyTasksLists
 1533 066c 8230      		cpi r24,lo8(2)
 1534 066e 00F0      		brlo .L99
2182:../../Source/tasks.c **** 				taskYIELD();
 1536               	.LM181:
 1537 0670 0E94 0000 		call vPortYield
 1538               	.L99:
 1539               	.LBB39:
2196:../../Source/tasks.c **** 			vApplicationIdleHook();
 1541               	.LM182:
 1542 0674 0E94 0000 		call vApplicationIdleHook
 1543               	.LBE39:
2236:../../Source/tasks.c **** 	}
 1545               	.LM183:
 1546 0678 00C0      		rjmp .L105
 1551               	.Lscope12:
 1553               		.stabd	78,0,0
 1556               	.global	vTaskDelay
 1558               	vTaskDelay:
 1559               		.stabd	46,0,0
 774:../../Source/tasks.c **** 	{
 1561               	.LM184:
 1562               	.LFBB13:
 1563 067a 0F93      		push r16
 1564 067c 1F93      		push r17
 1565 067e CF93      		push r28
 1566 0680 DF93      		push r29
 1567               	/* prologue: function */
 1568               	/* frame size = 0 */
 1569               	/* stack size = 4 */
 1570               	.L__stack_usage = 4
 1571 0682 8C01      		movw r16,r24
 779:../../Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 1573               	.LM185:
 1574 0684 0097      		sbiw r24,0
 1575 0686 01F4      		brne .L107
 1576               	.L109:
 816:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
 1578               	.LM186:
 1579 0688 0E94 0000 		call vPortYield
 1580 068c 00C0      		rjmp .L106
 1581               	.L107:
 781:../../Source/tasks.c **** 			vTaskSuspendAll();
 1583               	.LM187:
 1584 068e 0E94 0000 		call vTaskSuspendAll
 795:../../Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1586               	.LM188:
 1587 0692 C091 0000 		lds r28,xTickCount
 1588 0696 D091 0000 		lds r29,xTickCount+1
 1589 069a C00F      		add r28,r16
 1590 069c D11F      		adc r29,r17
 800:../../Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 1592               	.LM189:
 1593 069e 8091 0000 		lds r24,pxCurrentTCB
 1594 06a2 9091 0000 		lds r25,pxCurrentTCB+1
 1595 06a6 0296      		adiw r24,2
 1596 06a8 0E94 0000 		call uxListRemove
 807:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1598               	.LM190:
 1599 06ac CE01      		movw r24,r28
 1600 06ae 0E94 0000 		call prvAddCurrentTaskToDelayedList
 809:../../Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 1602               	.LM191:
 1603 06b2 0E94 0000 		call xTaskResumeAll
 814:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1605               	.LM192:
 1606 06b6 8823      		tst r24
 1607 06b8 01F0      		breq .L109
 1608               	.L106:
 1609               	/* epilogue start */
 818:../../Source/tasks.c **** 	}
 1611               	.LM193:
 1612 06ba DF91      		pop r29
 1613 06bc CF91      		pop r28
 1614 06be 1F91      		pop r17
 1615 06c0 0F91      		pop r16
 1616 06c2 0895      		ret
 1621               	.Lscope13:
 1623               		.stabd	78,0,0
 1627               	.global	vTaskDelayUntil
 1629               	vTaskDelayUntil:
 1630               		.stabd	46,0,0
 698:../../Source/tasks.c **** 	{
 1632               	.LM194:
 1633               	.LFBB14:
 1634 06c4 0F93      		push r16
 1635 06c6 1F93      		push r17
 1636 06c8 CF93      		push r28
 1637 06ca DF93      		push r29
 1638               	/* prologue: function */
 1639               	/* frame size = 0 */
 1640               	/* stack size = 4 */
 1641               	.L__stack_usage = 4
 1642 06cc 8C01      		movw r16,r24
 1643 06ce EB01      		movw r28,r22
 705:../../Source/tasks.c **** 		vTaskSuspendAll();
 1645               	.LM195:
 1646 06d0 0E94 0000 		call vTaskSuspendAll
 1647               	.LBB40:
 709:../../Source/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
 1649               	.LM196:
 1650 06d4 4091 0000 		lds r20,xTickCount
 1651 06d8 5091 0000 		lds r21,xTickCount+1
 712:../../Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1653               	.LM197:
 1654 06dc F801      		movw r30,r16
 1655 06de 2081      		ld r18,Z
 1656 06e0 3181      		ldd r19,Z+1
 1657 06e2 C20F      		add r28,r18
 1658 06e4 D31F      		adc r29,r19
 714:../../Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 1660               	.LM198:
 1661 06e6 4217      		cp r20,r18
 1662 06e8 5307      		cpc r21,r19
 1663 06ea 00F4      		brsh .L114
 721:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 1665               	.LM199:
 1666 06ec C217      		cp r28,r18
 1667 06ee D307      		cpc r29,r19
 1668 06f0 00F4      		brsh .L120
 721:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 1670               	.LM200:
 1671 06f2 81E0      		ldi r24,lo8(1)
 1672 06f4 00C0      		rjmp .L127
 1673               	.L114:
 733:../../Source/tasks.c **** 					xShouldDelay = pdTRUE;
 1675               	.LM201:
 1676 06f6 81E0      		ldi r24,lo8(1)
 731:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 1678               	.LM202:
 1679 06f8 C217      		cp r28,r18
 1680 06fa D307      		cpc r29,r19
 1681 06fc 00F0      		brlo .L115
 1682               	.L127:
 731:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 1684               	.LM203:
 1685 06fe 4C17      		cp r20,r28
 1686 0700 5D07      		cpc r21,r29
 1687 0702 00F0      		brlo .L115
 1688               	.L120:
 700:../../Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 1690               	.LM204:
 1691 0704 80E0      		ldi r24,0
 1692               	.L115:
 738:../../Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 1694               	.LM205:
 1695 0706 F801      		movw r30,r16
 1696 0708 D183      		std Z+1,r29
 1697 070a C083      		st Z,r28
 740:../../Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 1699               	.LM206:
 1700 070c 8823      		tst r24
 1701 070e 01F0      		breq .L118
 747:../../Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 1703               	.LM207:
 1704 0710 8091 0000 		lds r24,pxCurrentTCB
 1705 0714 9091 0000 		lds r25,pxCurrentTCB+1
 1706 0718 0296      		adiw r24,2
 1707 071a 0E94 0000 		call uxListRemove
 755:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1709               	.LM208:
 1710 071e CE01      		movw r24,r28
 1711 0720 0E94 0000 		call prvAddCurrentTaskToDelayedList
 1712               	.L118:
 1713               	.LBE40:
 758:../../Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 1715               	.LM209:
 1716 0724 0E94 0000 		call xTaskResumeAll
 762:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1718               	.LM210:
 1719 0728 8111      		cpse r24,__zero_reg__
 1720 072a 00C0      		rjmp .L113
 764:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
 1722               	.LM211:
 1723 072c 0E94 0000 		call vPortYield
 1724               	.L113:
 1725               	/* epilogue start */
 766:../../Source/tasks.c **** 	}
 1727               	.LM212:
 1728 0730 DF91      		pop r29
 1729 0732 CF91      		pop r28
 1730 0734 1F91      		pop r17
 1731 0736 0F91      		pop r16
 1732 0738 0895      		ret
 1741               	.Lscope14:
 1743               		.stabd	78,0,0
 1745               	.global	vTaskSwitchContext
 1747               	vTaskSwitchContext:
 1748               		.stabd	46,0,0
1836:../../Source/tasks.c **** {
 1750               	.LM213:
 1751               	.LFBB15:
 1752               	/* prologue: function */
 1753               	/* frame size = 0 */
 1754               	/* stack size = 0 */
 1755               	.L__stack_usage = 0
1837:../../Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 1757               	.LM214:
 1758 073a 8091 0000 		lds r24,uxSchedulerSuspended
 1759 073e 8823      		tst r24
 1760 0740 01F0      		breq .L129
1841:../../Source/tasks.c **** 		xYieldPending = pdTRUE;
 1762               	.LM215:
 1763 0742 81E0      		ldi r24,lo8(1)
 1764 0744 8093 0000 		sts xYieldPending,r24
 1765 0748 0895      		ret
 1766               	.L129:
1845:../../Source/tasks.c **** 		xYieldPending = pdFALSE;
 1768               	.LM216:
 1769 074a 1092 0000 		sts xYieldPending,__zero_reg__
1874:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1771               	.LM217:
 1772 074e 99E0      		ldi r25,lo8(9)
 1773 0750 00C0      		rjmp .L131
 1774               	.L132:
1874:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1776               	.LM218:
 1777 0752 8091 0000 		lds r24,uxTopReadyPriority
 1778 0756 8150      		subi r24,lo8(-(-1))
 1779 0758 8093 0000 		sts uxTopReadyPriority,r24
 1780               	.L131:
1874:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1782               	.LM219:
 1783 075c E091 0000 		lds r30,uxTopReadyPriority
 1784 0760 9E9F      		mul r25,r30
 1785 0762 F001      		movw r30,r0
 1786 0764 1124      		clr __zero_reg__
 1787 0766 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1788 0768 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1789 076a 8081      		ld r24,Z
 1790 076c 8823      		tst r24
 1791 076e 01F0      		breq .L132
 1792               	.LBB41:
1874:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1794               	.LM220:
 1795 0770 E091 0000 		lds r30,uxTopReadyPriority
 1796 0774 89E0      		ldi r24,lo8(9)
 1797 0776 E89F      		mul r30,r24
 1798 0778 F001      		movw r30,r0
 1799 077a 1124      		clr __zero_reg__
 1800 077c E050      		subi r30,lo8(-(pxReadyTasksLists))
 1801 077e F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1802 0780 A181      		ldd r26,Z+1
 1803 0782 B281      		ldd r27,Z+2
 1804 0784 1296      		adiw r26,2
 1805 0786 0D90      		ld __tmp_reg__,X+
 1806 0788 BC91      		ld r27,X
 1807 078a A02D      		mov r26,__tmp_reg__
 1808 078c B283      		std Z+2,r27
 1809 078e A183      		std Z+1,r26
 1810 0790 CF01      		movw r24,r30
 1811 0792 0396      		adiw r24,3
 1812 0794 A817      		cp r26,r24
 1813 0796 B907      		cpc r27,r25
 1814 0798 01F4      		brne .L133
1874:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1816               	.LM221:
 1817 079a 1296      		adiw r26,2
 1818 079c 8D91      		ld r24,X+
 1819 079e 9C91      		ld r25,X
 1820 07a0 1397      		sbiw r26,2+1
 1821 07a2 9283      		std Z+2,r25
 1822 07a4 8183      		std Z+1,r24
 1823               	.L133:
1874:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1825               	.LM222:
 1826 07a6 0180      		ldd __tmp_reg__,Z+1
 1827 07a8 F281      		ldd r31,Z+2
 1828 07aa E02D      		mov r30,__tmp_reg__
 1829 07ac 8681      		ldd r24,Z+6
 1830 07ae 9781      		ldd r25,Z+7
 1831 07b0 9093 0000 		sts pxCurrentTCB+1,r25
 1832 07b4 8093 0000 		sts pxCurrentTCB,r24
 1833 07b8 0895      		ret
 1834               	.LBE41:
 1839               	.Lscope15:
 1841               		.stabd	78,0,0
 1845               	.global	vTaskPlaceOnEventList
 1847               	vTaskPlaceOnEventList:
 1848               		.stabd	46,0,0
1890:../../Source/tasks.c **** {
 1850               	.LM223:
 1851               	.LFBB16:
 1852 07ba CF93      		push r28
 1853 07bc DF93      		push r29
 1854               	/* prologue: function */
 1855               	/* frame size = 0 */
 1856               	/* stack size = 2 */
 1857               	.L__stack_usage = 2
 1858 07be EB01      		movw r28,r22
1901:../../Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 1860               	.LM224:
 1861 07c0 6091 0000 		lds r22,pxCurrentTCB
 1862 07c4 7091 0000 		lds r23,pxCurrentTCB+1
 1863 07c8 645F      		subi r22,-12
 1864 07ca 7F4F      		sbci r23,-1
 1865 07cc 0E94 0000 		call vListInsert
1906:../../Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 1867               	.LM225:
 1868 07d0 8091 0000 		lds r24,pxCurrentTCB
 1869 07d4 9091 0000 		lds r25,pxCurrentTCB+1
 1870 07d8 0296      		adiw r24,2
 1871 07da 0E94 0000 		call uxListRemove
1934:../../Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 1873               	.LM226:
 1874 07de 8091 0000 		lds r24,xTickCount
 1875 07e2 9091 0000 		lds r25,xTickCount+1
1935:../../Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 1877               	.LM227:
 1878 07e6 8C0F      		add r24,r28
 1879 07e8 9D1F      		adc r25,r29
 1880               	/* epilogue start */
1938:../../Source/tasks.c **** }
 1882               	.LM228:
 1883 07ea DF91      		pop r29
 1884 07ec CF91      		pop r28
1935:../../Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 1886               	.LM229:
 1887 07ee 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 1889               	.Lscope16:
 1891               		.stabd	78,0,0
 1894               	.global	xTaskRemoveFromEventList
 1896               	xTaskRemoveFromEventList:
 1897               		.stabd	46,0,0
1983:../../Source/tasks.c **** {
 1899               	.LM230:
 1900               	.LFBB17:
 1901 07f2 0F93      		push r16
 1902 07f4 1F93      		push r17
 1903 07f6 CF93      		push r28
 1904 07f8 DF93      		push r29
 1905               	/* prologue: function */
 1906               	/* frame size = 0 */
 1907               	/* stack size = 4 */
 1908               	.L__stack_usage = 4
2000:../../Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 1910               	.LM231:
 1911 07fa DC01      		movw r26,r24
 1912 07fc 1596      		adiw r26,5
 1913 07fe ED91      		ld r30,X+
 1914 0800 FC91      		ld r31,X
 1915 0802 1697      		sbiw r26,5+1
 1916 0804 C681      		ldd r28,Z+6
 1917 0806 D781      		ldd r29,Z+7
2002:../../Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 1919               	.LM232:
 1920 0808 8E01      		movw r16,r28
 1921 080a 045F      		subi r16,-12
 1922 080c 1F4F      		sbci r17,-1
 1923 080e C801      		movw r24,r16
 1924 0810 0E94 0000 		call uxListRemove
2004:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1926               	.LM233:
 1927 0814 8091 0000 		lds r24,uxSchedulerSuspended
 1928 0818 8111      		cpse r24,__zero_reg__
 1929 081a 00C0      		rjmp .L136
2006:../../Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 1931               	.LM234:
 1932 081c 8E01      		movw r16,r28
 1933 081e 0E5F      		subi r16,-2
 1934 0820 1F4F      		sbci r17,-1
 1935 0822 C801      		movw r24,r16
 1936 0824 0E94 0000 		call uxListRemove
2007:../../Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 1938               	.LM235:
 1939 0828 8E89      		ldd r24,Y+22
 1940 082a 9091 0000 		lds r25,uxTopReadyPriority
 1941 082e 9817      		cp r25,r24
 1942 0830 00F4      		brsh .L137
2007:../../Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 1944               	.LM236:
 1945 0832 8093 0000 		sts uxTopReadyPriority,r24
 1946               	.L137:
2007:../../Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 1948               	.LM237:
 1949 0836 B9E0      		ldi r27,lo8(9)
 1950 0838 8B9F      		mul r24,r27
 1951 083a C001      		movw r24,r0
 1952 083c 1124      		clr __zero_reg__
 1953 083e B801      		movw r22,r16
 1954 0840 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1955 0842 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1956 0844 00C0      		rjmp .L141
 1957               	.L136:
2013:../../Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 1959               	.LM238:
 1960 0846 B801      		movw r22,r16
 1961 0848 80E0      		ldi r24,lo8(xPendingReadyList)
 1962 084a 90E0      		ldi r25,hi8(xPendingReadyList)
 1963               	.L141:
 1964 084c 0E94 0000 		call vListInsertEnd
2016:../../Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1966               	.LM239:
 1967 0850 E091 0000 		lds r30,pxCurrentTCB
 1968 0854 F091 0000 		lds r31,pxCurrentTCB+1
 1969 0858 9E89      		ldd r25,Y+22
 1970 085a 8689      		ldd r24,Z+22
 1971 085c 9817      		cp r25,r24
 1972 085e 00F0      		brlo .L140
2026:../../Source/tasks.c **** 		xYieldPending = pdTRUE;
 1974               	.LM240:
 1975 0860 81E0      		ldi r24,lo8(1)
 1976 0862 8093 0000 		sts xYieldPending,r24
 1977 0866 00C0      		rjmp .L139
 1978               	.L140:
2030:../../Source/tasks.c **** 		xReturn = pdFALSE;
 1980               	.LM241:
 1981 0868 80E0      		ldi r24,0
 1982               	.L139:
 1983               	/* epilogue start */
2034:../../Source/tasks.c **** }
 1985               	.LM242:
 1986 086a DF91      		pop r29
 1987 086c CF91      		pop r28
 1988 086e 1F91      		pop r17
 1989 0870 0F91      		pop r16
 1990 0872 0895      		ret
 1996               	.Lscope17:
 1998               		.stabd	78,0,0
 2001               	.global	vTaskSetTimeOutState
 2003               	vTaskSetTimeOutState:
 2004               		.stabd	46,0,0
2038:../../Source/tasks.c **** {
 2006               	.LM243:
 2007               	.LFBB18:
 2008               	/* prologue: function */
 2009               	/* frame size = 0 */
 2010               	/* stack size = 0 */
 2011               	.L__stack_usage = 0
2040:../../Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2013               	.LM244:
 2014 0874 2091 0000 		lds r18,xNumOfOverflows
 2015 0878 FC01      		movw r30,r24
 2016 087a 2083      		st Z,r18
2041:../../Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2018               	.LM245:
 2019 087c 2091 0000 		lds r18,xTickCount
 2020 0880 3091 0000 		lds r19,xTickCount+1
 2021 0884 3283      		std Z+2,r19
 2022 0886 2183      		std Z+1,r18
 2023 0888 0895      		ret
 2025               	.Lscope18:
 2027               		.stabd	78,0,0
 2031               	.global	xTaskCheckForTimeOut
 2033               	xTaskCheckForTimeOut:
 2034               		.stabd	46,0,0
2046:../../Source/tasks.c **** {
 2036               	.LM246:
 2037               	.LFBB19:
 2038               	/* prologue: function */
 2039               	/* frame size = 0 */
 2040               	/* stack size = 0 */
 2041               	.L__stack_usage = 0
2052:../../Source/tasks.c **** 	taskENTER_CRITICAL();
 2043               	.LM247:
 2044               	/* #APP */
 2045               	 ;  2052 "../../Source/tasks.c" 1
 2046 088a 0FB6      		in		__tmp_reg__, __SREG__
 2047               	 ;  0 "" 2
 2048               	 ;  2052 "../../Source/tasks.c" 1
 2049 088c F894      		cli
 2050               	 ;  0 "" 2
 2051               	 ;  2052 "../../Source/tasks.c" 1
 2052 088e 0F92      		push	__tmp_reg__
 2053               	 ;  0 "" 2
 2054               	/* #NOAPP */
 2055               	.LBB42:
2055:../../Source/tasks.c **** 		const portTickType xConstTickCount = xTickCount;
 2057               	.LM248:
 2058 0890 4091 0000 		lds r20,xTickCount
 2059 0894 5091 0000 		lds r21,xTickCount+1
2068:../../Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 2061               	.LM249:
 2062 0898 F091 0000 		lds r31,xNumOfOverflows
 2063 089c DC01      		movw r26,r24
 2064 089e EC91      		ld r30,X
 2065 08a0 1196      		adiw r26,1
 2066 08a2 2D91      		ld r18,X+
 2067 08a4 3C91      		ld r19,X
 2068 08a6 1297      		sbiw r26,1+1
 2069 08a8 FE17      		cp r31,r30
 2070 08aa 01F0      		breq .L144
2068:../../Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 2072               	.LM250:
 2073 08ac 4217      		cp r20,r18
 2074 08ae 5307      		cpc r21,r19
 2075 08b0 00F4      		brsh .L147
 2076               	.L144:
2076:../../Source/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 2078               	.LM251:
 2079 08b2 DB01      		movw r26,r22
 2080 08b4 ED91      		ld r30,X+
 2081 08b6 FC91      		ld r31,X
 2082 08b8 DA01      		movw r26,r20
 2083 08ba A21B      		sub r26,r18
 2084 08bc B30B      		sbc r27,r19
 2085 08be AE17      		cp r26,r30
 2086 08c0 BF07      		cpc r27,r31
 2087 08c2 00F4      		brsh .L147
2079:../../Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 2089               	.LM252:
 2090 08c4 241B      		sub r18,r20
 2091 08c6 350B      		sbc r19,r21
 2092 08c8 2E0F      		add r18,r30
 2093 08ca 3F1F      		adc r19,r31
 2094 08cc FB01      		movw r30,r22
 2095 08ce 3183      		std Z+1,r19
 2096 08d0 2083      		st Z,r18
2080:../../Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2098               	.LM253:
 2099 08d2 0E94 0000 		call vTaskSetTimeOutState
2081:../../Source/tasks.c **** 			xReturn = pdFALSE;
 2101               	.LM254:
 2102 08d6 80E0      		ldi r24,0
 2103 08d8 00C0      		rjmp .L145
 2104               	.L147:
2074:../../Source/tasks.c **** 			xReturn = pdTRUE;
 2106               	.LM255:
 2107 08da 81E0      		ldi r24,lo8(1)
 2108               	.L145:
 2109               	.LBE42:
2088:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
 2111               	.LM256:
 2112               	/* #APP */
 2113               	 ;  2088 "../../Source/tasks.c" 1
 2114 08dc 0F90      		pop		__tmp_reg__
 2115               	 ;  0 "" 2
 2116               	 ;  2088 "../../Source/tasks.c" 1
 2117 08de 0FBE      		out		__SREG__, __tmp_reg__
 2118               	 ;  0 "" 2
2091:../../Source/tasks.c **** }
 2120               	.LM257:
 2121               	/* #NOAPP */
 2122 08e0 0895      		ret
 2130               	.Lscope19:
 2132               		.stabd	78,0,0
 2134               	.global	vTaskMissedYield
 2136               	vTaskMissedYield:
 2137               		.stabd	46,0,0
2095:../../Source/tasks.c **** {
 2139               	.LM258:
 2140               	.LFBB20:
 2141               	/* prologue: function */
 2142               	/* frame size = 0 */
 2143               	/* stack size = 0 */
 2144               	.L__stack_usage = 0
2096:../../Source/tasks.c **** 	xYieldPending = pdTRUE;
 2146               	.LM259:
 2147 08e2 81E0      		ldi r24,lo8(1)
 2148 08e4 8093 0000 		sts xYieldPending,r24
 2149 08e8 0895      		ret
 2151               	.Lscope20:
 2153               		.stabd	78,0,0
 2154               		.data
 2157               	xNextTaskUnblockTime:
 2158 0000 FFFF      		.word	-1
 2159               		.local	xNumOfOverflows
 2160               		.comm	xNumOfOverflows,1,1
 2161               		.local	xYieldPending
 2162               		.comm	xYieldPending,1,1
 2163               		.local	uxPendedTicks
 2164               		.comm	uxPendedTicks,1,1
 2165               		.local	uxSchedulerSuspended
 2166               		.comm	uxSchedulerSuspended,1,1
 2167               		.local	xSchedulerRunning
 2168               		.comm	xSchedulerRunning,1,1
 2169               		.local	uxTopReadyPriority
 2170               		.comm	uxTopReadyPriority,1,1
 2171               		.local	xTickCount
 2172               		.comm	xTickCount,2,1
 2173               		.local	uxCurrentNumberOfTasks
 2174               		.comm	uxCurrentNumberOfTasks,1,1
 2175               		.local	uxTasksDeleted
 2176               		.comm	uxTasksDeleted,1,1
 2177               		.local	pxOverflowDelayedTaskList
 2178               		.comm	pxOverflowDelayedTaskList,2,1
 2179               		.local	pxDelayedTaskList
 2180               		.comm	pxDelayedTaskList,2,1
 2181               	.global	pxCurrentTCB
 2182               		.section .bss
 2185               	pxCurrentTCB:
 2186 0000 0000      		.zero	2
 2187               		.local	uxTaskNumber
 2188               		.comm	uxTaskNumber,1,1
 2189               		.local	pxReadyTasksLists
 2190               		.comm	pxReadyTasksLists,36,1
 2191               		.local	xDelayedTaskList1
 2192               		.comm	xDelayedTaskList1,9,1
 2193               		.local	xDelayedTaskList2
 2194               		.comm	xDelayedTaskList2,9,1
 2195               		.local	xPendingReadyList
 2196               		.comm	xPendingReadyList,9,1
 2197               		.local	xTasksWaitingTermination
 2198               		.comm	xTasksWaitingTermination,9,1
 2218               		.text
 2220               	.Letext0:
 2221               		.ident	"GCC: (GNU) 4.7.2"
 2222               	.global __do_copy_data
 2223               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/cc5Dr4AO.s:2      *ABS*:0000003e __SP_H__
     /tmp/cc5Dr4AO.s:3      *ABS*:0000003d __SP_L__
     /tmp/cc5Dr4AO.s:4      *ABS*:0000003f __SREG__
     /tmp/cc5Dr4AO.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cc5Dr4AO.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cc5Dr4AO.s:127    .text:00000000 prvAddCurrentTaskToDelayedList
     /tmp/cc5Dr4AO.s:2185   .bss:00000000 pxCurrentTCB
     /tmp/cc5Dr4AO.s:2170   .bss:00000008 xTickCount
     /tmp/cc5Dr4AO.s:2176   .bss:0000000c pxOverflowDelayedTaskList
     /tmp/cc5Dr4AO.s:2178   .bss:0000000e pxDelayedTaskList
     /tmp/cc5Dr4AO.s:2157   .data:00000000 xNextTaskUnblockTime
     /tmp/cc5Dr4AO.s:224    .text:00000068 xTaskGenericCreate
     /tmp/cc5Dr4AO.s:2172   .bss:0000000a uxCurrentNumberOfTasks
     /tmp/cc5Dr4AO.s:2188   .bss:00000011 pxReadyTasksLists
     /tmp/cc5Dr4AO.s:2190   .bss:00000035 xDelayedTaskList1
     /tmp/cc5Dr4AO.s:2192   .bss:0000003e xDelayedTaskList2
     /tmp/cc5Dr4AO.s:2194   .bss:00000047 xPendingReadyList
     /tmp/cc5Dr4AO.s:2196   .bss:00000050 xTasksWaitingTermination
     /tmp/cc5Dr4AO.s:2166   .bss:00000006 xSchedulerRunning
     /tmp/cc5Dr4AO.s:2180   .bss:00000010 uxTaskNumber
     /tmp/cc5Dr4AO.s:2168   .bss:00000007 uxTopReadyPriority
     /tmp/cc5Dr4AO.s:620    .text:00000274 vTaskDelete
     /tmp/cc5Dr4AO.s:2174   .bss:0000000b uxTasksDeleted
     /tmp/cc5Dr4AO.s:743    .text:000002f4 vTaskStartScheduler
     /tmp/cc5Dr4AO.s:1437   .text:0000060e prvIdleTask
     /tmp/cc5Dr4AO.s:827    .text:00000358 vTaskEndScheduler
     /tmp/cc5Dr4AO.s:856    .text:00000362 vTaskSuspendAll
     /tmp/cc5Dr4AO.s:2164   .bss:00000005 uxSchedulerSuspended
     /tmp/cc5Dr4AO.s:878    .text:0000036e xTaskGetTickCount
     /tmp/cc5Dr4AO.s:928    .text:00000384 xTaskGetTickCountFromISR
     /tmp/cc5Dr4AO.s:955    .text:00000390 uxTaskGetNumberOfTasks
     /tmp/cc5Dr4AO.s:977    .text:00000396 xTaskIncrementTick
                             .bss:00000002 xNumOfOverflows
     /tmp/cc5Dr4AO.s:2162   .bss:00000004 uxPendedTicks
     /tmp/cc5Dr4AO.s:2160   .bss:00000003 xYieldPending
     /tmp/cc5Dr4AO.s:1244   .text:0000052a xTaskResumeAll
     /tmp/cc5Dr4AO.s:1558   .text:0000067a vTaskDelay
     /tmp/cc5Dr4AO.s:1629   .text:000006c4 vTaskDelayUntil
     /tmp/cc5Dr4AO.s:1747   .text:0000073a vTaskSwitchContext
     /tmp/cc5Dr4AO.s:1847   .text:000007ba vTaskPlaceOnEventList
     /tmp/cc5Dr4AO.s:1896   .text:000007f2 xTaskRemoveFromEventList
     /tmp/cc5Dr4AO.s:2003   .text:00000874 vTaskSetTimeOutState
     /tmp/cc5Dr4AO.s:2033   .text:0000088a xTaskCheckForTimeOut
     /tmp/cc5Dr4AO.s:2136   .text:000008e2 vTaskMissedYield

UNDEFINED SYMBOLS
vListInsert
pvPortMalloc
vPortFree
memset
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vListInsertEnd
vPortYield
uxListRemove
xPortStartScheduler
vPortEndScheduler
vApplicationIdleHook
__do_copy_data
__do_clear_bss
